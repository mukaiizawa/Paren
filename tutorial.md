Parenチュートリアル

# 概要
このチュートリアルはParenの基本的な概念や文法を早巡りすることを目的とする。読者には計算機科学の初等的な知識があることを前提とし、いくつかの専門用語は定義することなしに使用している。

Paren（パレン）はS式によって記述されるプログラミング言語Lispの方言である。

また、このドキュメントでは早巡りを目的としているため、すべての機能について説明しているわけではない。

# 書式
この文書内の書式は次の規則で記述してある。

    記号 定義
    ----------------------------------------
    [ ]  []内は省略可能
    { }  {}内から一つ選択
    |    []、{}内の代替候補の区切り文字
    ...  直前の構文の一回以上の繰り返し
    ::=  左辺を右辺で定義
    --   左辺の右辺による説明
    =>   左辺の評価結果は右辺

# 序章
この章ではいくつかの簡単なプログラムを示すことを目的とする。

## Parenの実行
Parenを起動するとreplが実行される。

    $ paren
    ) 

')'がプロンプトである。プロンプトに続けてプログラムを記述すると評価され結果が印字される。

    ) 1
    1
    ) (+ 1 2 3 4)
    10
    ) (* (+ 1 2) 3 4)
    36

Parenのプログラムは演算子を前置し、被演算子と共に括弧で括る。このように演算子を前置する記法を前置記法といい、Parenの特徴の一つである。

## hello world
あるプログラミング言語を習得する唯一の方法は、その言語でプログラムを書くことである。そしてそれは、慣習により次のプログラムを書くことから始まる。

    文字列'hello world'を印字せよ。

文字列を印字するにはprintを使用する。

    ) (print "hello world")
    hello world
    "hello world"

上記のプログラムを評価すると二行出力される。一行目がprintがコンソールへ印字した文字列であり、二行がprintの評価結果をreplが印字したものである。

すべての式はprintのように必ず値を返す。この仕様はParenの特徴の一つである。

## 複写関数
もうひとつの例として標準入力から標準出力に複写する関数copyを作成する。

    ; copy 第一版
    (function copy ()
      (let (ch nil)
        (while (/= ch -1)
          (<- ch (read-byte))
          (write-byte ch))))

関数を定義するにはfunctionマクロを使用する。例ではcopyという引数がない関数を定義している。

関数の本体では、read-byteで取得したバイトでシンボルchを束縛している。その後、chを参照してwrite-byteで標準出力に書き出している。

このプログラムは、

    Parenのすべての式は評価されると値を返す。

という性質を用いてより簡潔に書ける。

    ; copy 第二版
    (function copy ()
      (let (ch nil)
        (while (/= (<- c (read-byte)) -1)
          (write-byte ch))))

束縛オペレータ―はシンボルに束縛した値を返すため、このように別の式の中に記述することができる。

ただし、返り値を濫用するプログラムは可読性を下げることがあるため注意が必要である。

# コメント
コメントはParenに無視されるため、プログラムの補足事項等を自由に記述することができる。

## 一行コメント
`;`から行末まではコメントと見做される。

    ; 一行コメント

## 複数行コメント
Parenには複数行に跨がれるコメントは言語仕様として存在しない。ただし、複数行に跨がるコメントが必要になった場合は後述するリードマクロで容易に定義できる。

# 数値
Parenではすべての実数は数値型として扱われる。

## 数値リテラル
数値リテラルの書式を示す。

    [base x] number
    base -- 基数
    number -- 実数

基数は省略可能で、指定しない場合は10進数と見做される。また、基数に0を指定した場合は16進数と見做される。

## 評価
数値は評価されると自身を返す。

    ) 10
    10
    ) 3.141592
    3.141592
    ) 2x1010
    10
    ) 0x14
    10

## 算術関数
代表的な算術関数を次に示す。

    関数  処理
    -------------------
    +     加算
    -     減算
    *     乗算
    /     除算
    **    冪乗
    //    切り捨て除算
    mod   余り

これらの評価例を示す。

    ) (+ 3 4 5)
    12
    ) (- 10 4 5)
    1
    ) (* 3 4 5)
    60
    ) (/ 3 4 5)
    0.15
    ) (/ 3)
    0.33333
    ) (** 2 3)
    8
    ) (// 5 4)
    1
    ) (mod 6 4)
    2

# 文字列
文字列は文字列リテラルやstring関数等で作成できる。

## 文字列リテラル
文字列は評価されると自身を返す。文字列リテラルはダブルクォートで囲まれた文字の列である。

    ) "hello paren"
    "hello paren"

## 文字列の結合
文字列の結合はstringを使用する。

    ) (string "hello" "_" "paren")
    "hello_paren"

## 文字列の長さの取得
文字列の長さを取得するには組み込み関数のstrlenを使用する。

    ) (strlen "hello paren")
    11

## 部分文字列の取得
部分文字列を取得するにはsubstrを使用する。

    ) (substr "hello paren" 6)
    "paren"
    ) (substr "hello paren" 0 5)
    "hello"

第一引数のみ指定されている場合はその値以降の部分文字列を取得する。第二引数まで指定してある場合は、第一引数から第二引数の値の前までの部分文字列を取得する。ただし、どちらの場合も零から数える。

## 文字列の比較
文字列の比較は比較関数streq?で行う。

    ) (streq? "hello paren" "hello paren")
    true
    ) (streq? "Hello Paren" "hello paren")
    nil

## 正規表現
Parenで正規表現を使用したい場合はregexモジュールimportする。

詳細はregexモジュールのドキュメントを参照のこと。

# シンボル
シンボルは任意のParenオブジェクトへの参照を保持するためのオブジェクトである。既に述べた数値や文字列の他、関数やリストやシンボルなどもParenのオブジェクトであるため、シンボルで参照を保持することができる。

また、同名のシンボルはシステム上でただ一つしか存在しないため、同一のシンボルかはアドレス比較で行える。

## シンボル名
Parenのシンボル名は数字以外の英文字と一部の記号から始まり、その後、英数字と一部の記号が続く。

次のいずれもParenのシンボル名として有効である。

    var
    x1

シンボル名で使用できる文字の厳密な定義は言語仕様書の字句解析の章を参照されたい。

シンボル名が複数の単語で構成される場合は、単語の区切れをハイフンで区切る。

    user-name
    neighbor-node

## シンボルの比較
前述のように、シンボルが同一かどうかの判定はメモリの番地が一致するかだけ確認すればよい。

Parenにはそのための関数`eq?`が用意してある。

    ) (eq? 'a 'a)
    true

    ) (eq? 'a (string->symbol "a"))
    true

`eq?`はメモリ番地の比較をするだけなので高速である。

## 環境
シンボルが保持するオブジェクトへの参照は環境で管理されている。

環境とは、一つのシンボルテーブルと零又は一つの環境への参照の対のことをいう。ここで、シンボルテーブルとはシンボルとオブジェクトへの参照の対の集合のことをいう。ただし、あるシンボルテーブルに存在する同一シンボルは高々一つである。

環境の持つ環境への参照の実体を親の環境という。これに対して、ある親の環境の参照元の環境を子の環境という。

Parenには親の環境が存在しないような環境が一つだけ存在する。この環境のことを大域環境という。

ある環境EのシンボルテーブルTにシンボルSとオブジェクトへの参照Pの対(S, P)が存在しているとき、EにSがPで束縛されているという。また、Tに対(S, P)を追加することを、EにSをPで束縛するという。これは、単にSをPで束縛する、乃至、Sを束縛するともいう。

式が評価される場合、必ずどこかの環境の下で評価される。Parenを起動した直後の環境は大域環境である。

## シンボルの評価
シンボルは評価されると、保持しているオブジェクトへの参照の実体を返す。ただし、シンボルの評価結果は評価される環境によって変わりうる。

シンボルの評価は次の規則で行われる。

    シンボルSが評価された環境EのシンボルテーブルにSが存在している場合、対応するオブジェクトへの参照の実体を返す。
    そうでなければEの親の環境に対して再帰的にシンボルテーブルの探索を行う。
    親の環境を辿っていき、大域環境のシンボルテーブルにSが存在しない場合はエラーとする。

このように、あるシンボルが保持するオブジェクトへの参照は、どの環境下でシンボルが評価されたのか考えなければ意味がない。

例えば、前述した組み込みの関数`+`は大域環境に束縛されているシンボルの一つであり、評価されることによって引数の和を計算する関数が返されていたことになる。

## シンボルの束縛
シンボルを束縛するには束縛オペレーターを使用する。

    (<- symbol_value ...) => result
    symbol_value ::= sym val
    sym -- シンボル
    val -- シンボルが保持するオブジェクトの参照の実体
    result -- 最後に束縛した値

束縛オペレーターは、現在の環境にシンボルが束縛されている場合はシンボルテーブルの値を更新する。そうでなければ、親の環境に対して再帰的に探索を続けてシンボルテーブルを更新する。大域環境にもシンボルが束縛されていない場合は、大域環境に新たにシンボルを束縛する。

ある環境EにシンボルSをオブジェクトVで束縛しているとき、その環境の親の（もしくは、親の親の…）環境E'に同一のシンボルSをオブジェクトV'で束縛されていることを考える。この場合、環境Eの下では、Sの保持するオブジェクトの参照常にVになる。また、環境Eの下ではSがどのような値で環境E'に束縛されているか知るすべはない。

このように、子の環境でシンボルを束縛すると親の環境で同一のシンボルが束縛されている値が参照できなくなることからシンボルを隠すという。

シンボルを隠す行為は有用な用途があるためしばしば用いられる。

## 環境の作成
現在の環境を親にもつ環境を新しく作るにはスペシャルオペレーターletを使用する。

    (let ([let_args] ...) [body] ...) => result
    let_args ::= symbol value
    symbol -- 新しく作成する環境に束縛するシンボル
    value -- シンボルを束縛する値
    body -- 新しく作成する環境で評価する式
    result -- 新しく作成した環境で最後に評価した式の評価結果

letは新しく環境を作成し、第一引数のシンボルを束縛する。第二引数以降は作成した環境内で式を評価する。

letは唯一の環境を作る方法である。

## グローバルシンボル
大域環境に束縛されたシンボルのことをグローバルシンボルという。先に説明したように、グローバルシンボルは隠されない限りすべての環境から参照できる。

慣習として、ほかのシンボルと区別がつきやすいようにグローバルシンボル名は次のように`$`から始める。

    $global-var

## 特殊なシンボル
システムであらかじめ組み込まれている、参照しかできない特殊なシンボルが存在する。

これらは大域環境に束縛されていて、再束縛が禁止されているためどこからでも参照ができる。

    シンボル 意味
    --------------------------------------
    true     真の代表値
    nil      空の代表値

# キーワード
キーワードは同名であるならばプログラムでただ一つだけ存在するという性質を持つオブジェクトである。アドレス比較で同一か判定可能なため列挙等に使用される。

## キーワードリテラル
キーワードリテラルは`:`から始まる英数字と一部の記号の列である。

次のいずれも有効なキーワードリテラルである。

    :0123
    :keyword

使用できる文字は言語仕様書の字句定義の章を参照のこと。

## キーワードの評価
キーワードは評価されると自身を返す。

    ) :key
    :key

## キーワードの比較
シンボル同様、アドレスの比較で済むため`eq?`を使用する。

    ) (eq? :abc (string->keyword "abc"))
    true

# リスト
リストはParenにおいて最も重要なデータ型であると同時に、Parenを記述するプログラムでもある。

## コンス
コンスとは、任意のParenオブジェクトへの参照carと、コンスまたはnilへの参照cdrの対のことをいう。

リストとは、あるコンスのcdrで辿れる全体、または、nilのことをいう。コンスはリストのノードであり、carはデータへの参照、cdrは次のノードへの参照であり、nilで終端している。リストとして空の代表値nilを扱う場合には、特に空のリストということがある。

あるコンスのcdrを辿っていった終端がnilを指している場合、そのコンス全体は純リストであるという。コンスの定義により、Parenの任意のリストはすべて純リストである。純リスト以外のリストが作れないという制約はほかのLisp方言と異なる特徴の一つとなる。

コンスは組み込み関数consで作ることができる。consの第一引数、第二引数が、それぞれ作成されるコンスのcarとcdrに対応する。ただし、コンスの定義にあてはまらない引数をconsに与えるとエラーとなる。

    ) (cons 1 nil)
    (1)
    ) (cons 1 (cons 2 nil))
    (1 2)
    ) (cons (cons 1 nil) (cons 2 nil))
    ((1) 2)

Parenはコンスを印字するときにコンスのcdrで辿れる全体、つまり、リストとして印字する。

リストは次の規則で印字される。

1. 左括弧を印字
2. carが指す値を印字する
   cdrが指す値がnilなら3を行う
   そうでなければ、再びcdrが指すコンスに対して2を行う
3. 右括弧を印字

    ) (cons 1 (cons 2 (cons 3 nil)))
    (1 2 3)

    +-----+-----+
    | car | cdr |
    +-----+-----+
       |     |    +-----+-----+
       |     +--->| car | cdr |
       |          +-----+-----+
       |             |     |    +-----+-----+
       |             |     +--->| car | cdr |
       |             |          +-----+-----+
       |             |             |     |
       |             |             |     +---> nil
       1             2             3

あるコンスのcarがコンスを指している場合でもそのルールは再帰的に適用される。

    ) (cons (cons 1 nil) (cons 2 (cons 3 nil)))
    ((1) 2 3)

    +-----+-----+
    | car | cdr |
    +-----+-----+
       |     |    +-----+-----+
       |     +--->| car | cdr |
       |          +-----+-----+
       |             |     |    +-----+-----+
       |             |     +--->| car | cdr |
       |             2          +-----+-----+
       |                           |     |
       |    +-----+-----+          |     +---> nil
       +--->| car | cdr |          3
            +-----+-----+
               |     |
               |     +---> nil
               1

任意のリストはcons関数で作ることができるが、複数の要素を持つようなリストを作ろうとすると、すぐに困ったことになる。

    ) (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 nil)))))
    (1 2 3 4 5)

そのため、Parenには引数を要素に持つようなリストを作成するための関数、listが存在する。
    (list [arg] ...)

    arg -- リストの要素

次のように、要素を引数にしてリストを作成できる。

    ) (list 1 2 3 4 5)
    (1 2 3 4 5)

リストの定義により、要素がリストであるようなリストも作成することもできる。

    ) (list (list 1 (list 2 3) 4 5))
    ((1 (2 3)) 4 5)

## carとcdrの参照
コンスが指す二つのポインタcar、cdrの指す場所を得る関数があり、それぞれcarとcdrという。

    ) (list 1 2)
    (1 2)
    ) (car (list 1 2))
    1
    ) (cdr (list 1 2))
    (2)
    ) (car (cdr (list 1 2)))
    2

carとcdrは引数が空のリストである場合はnilを返す。

    ) (car nil)
    nil
    ) (cdr nil)
    nil
    ) (car (cdr (cdr (list 1))))
    nil

リストの要素を参照するときにcarとcdrを組み合わせることは頻繁にあるため、計四回までリストを辿るすべての組み合わせが定義されている。

    caar cadr cdar cddr
    caaar caadr cadar caddr cdaar cdadr cddar cdddr caaaar
    caaadr caadar caaddr cadaar cadadr caddar cadddr cdaaar cdaadr cdadar
    cdaddr cddaar cddadr cdddar cddddr

これらの関数については合成規則が分かるような等価な式を例示することにとどめる。

    (caar lis) <=> (car (car lis))
    (caddr lis) <=> (car (cdr (cdr lis)))
    lis -- 引数のリスト

## carとcdrへ代入
コンスのcarとcdrが指す場所を変更するには、それぞれcar!、cdr!関数を使用する。

    ) (car! (<- lis (list 0 0 0)) 1)
    1
    ) lis
    (1 0 0)
    ) (cdr! lis nil)
    nil
    ) lis
    (1)

cdrが指す値を書き換える際、純リストでなくなるような代入はできない。

## リストの評価
リストはまず最初に第一要素が評価される。リストの第一要素はリストであっても構わず、その場合は再帰的に処理が行われる。ここでは、第一要素の評価結果をオペレーターと呼ぶ。

    (operator [arg] ...) 
    operator -- オペレーター
    arg -- オペレーターに渡る引数

オペレーターが次のいずれか場合はこのリストを評価可能なS式という。

- 関数
- スペシャルオペレーター
- マクロ

評価可能なS式でなかった場合はエラーとなる。そうでない場合はオペレーターの種類に従って評価が行われる。

### 関数
オペレーターが関数の場合、すべての引数を評価し、その結果を関数に渡して評価する。

    ) (+ 1 (* 2 3))
    7

上記の例では二つの関数`+`、`*`のそれぞれの引数`1`と`(* 2 3)`、`2`と`3`はそれぞれ評価されてから関数が評価されている。

### スペシャルオペレーター
スペシャルオペレーターはParenに組み込まれている特殊なオペレーターで、オペレーター毎に引数の扱いが異なる。詳しくはスペシャルオペレーターの章で述べる。

### マクロ
オペレーターがマクロの場合、すべての引数を評価することなしにマクロに渡して展開した結果を評価する。ただし、マクロの定義のされ方によっては引数が評価されているようにも見える。詳しくはマクロの章で述べる。

オペレーターの定義を見ることなしにマクロかスペシャルオペレーターか関数か判断できない。一方で、Parenのマクロは完全に調和した機能であることを意味する。

## プログラムとデータ
既に述べたようにParenのプログラム、つまりS式はParenのデータである。

一方で、Parenのデータのうち、評価可能なS式はParenのプログラムである。

データとプログラムが相互に変換可能であるという事実は、プログラムを書くプログラムを書きやすくする。実際、マクロはこの事実を上手く利用した機能であり、Parenを強力な言語にしている。

例えば次の式のように評価結果が評価可能なS式であるようなS式は簡単に思いつく。

    ) (list + 1 2 3)
    (+ 1 2 3)

ここで垣間見た可能性についてマクロの章で詳しく述べる。

# 関数
関数はParenの根幹をなすオブジェクトである。関数は柔軟な仮引数を定義することができる。

この文書内における関数という単語は、計算機科学における手続き程度の意味しかない。

## 関数の定義
関数を定義するにはマクロfunctionを用いる。

    (function name ([required_param] ...
                    [:opt optional_param ...]
                    [{ :rest rest_param | :key keyword_param ... }] )
        body ...)
    name -- 定義する関数名
    required_param -- 必須パラメーター
    optional_param -- オプショナルパラメーター
    keyword_param -- キーワードパラメーター
    rest_param -- レストパラメーター
    body -- 関数本体

functionは与えられた名前の関数を定義し、その関数を返す。

    ) (function double (x) (* 2 x))
    double
    ) (double 4)
    8

## 関数呼び出し
既に説明したように、関数を呼び出すには関数とその引数をリストにして評価する。

    ) (double 3)
    6
    ) (double 4)
    8

関数の実引数が仮引数に束縛できない場合はエラーとなる。関数の実引数の評価は必ず左から順に評価される。

## 仮引数
仮引数には次の種類がある。

- 必須パラメーター
- オプショナルパラメーター
- レストパラメーター
- キーワードパラメーター

複数の仮引数を同時に組み合わせることができるが、その場合は上の順番で指定しなければならない。

ただし、レストパラメーターとキーワードパラメーターは同時に指定できない。

### 必須パラメーター
必須パラメーターは関数呼び出し時に必ず与えなければならない仮引数を定義する。

関数呼び出し時に必須パラメーターが足りない場合はエラーとなる。

    ) (function avg2 (x y)
        (/ (+ x y) 2))
    ) (avg2 2 4)
    3

### オプショナルパラメーター
オプショナルパラメーターは関数呼び出し時に省略可能な仮引数を定義する。省略された場合nilが束縛される。

関数呼び出し時にオプショナルパラメーターが省略された場合は初期値が使用される。

    ) (function inc (x :opt y)
        (+ x (|| y 1)))
    x-add
    ) (inc 3)
    4
    ) (inc 3 2)
    5

オプショナルパラメーターは複数定義することもできる。

    ) (function cat-string (s1 :opt s2 s3)
        (string s1 s2 s3))
    ) (cat-string "hello")
    "hello"
    ) (cat-string "hello" " world")
    "hello world"
    ) (cat-string "hello" " world" "!!")
    "hello world!!"

ある仮引数に実引数を渡したい場合に、その仮引数までにオプショナルパラメーターがある場合は明示的にオプショナルパラメーターに実引数を指定する必要がある。

### レストパラメーター
レストパラメーターは可変長な実引数を受け取る仮引数を定義する。仮引数の`:rest`句に可変長引数を定義する。

関数呼び出し時に仮引数よりも多い実引数がリストとして束縛される。

    ) (function first-rest (first :rest rest)
        (list first rest))
    ) (first-rest 1 2 3)
    (1 (2 3))

レストパラメーターに束縛される実引数がない場合はnilが束縛される。

    ) (first-rest 1)
    (1 nil)

### キーワードパラメーター
キーワードパラメーターは、順序を問わない名前付きの仮引数を定義する。仮引数の`:key`句に指定する。

キーワードパラメーターには初期値を与えることができ、呼び出し時にキーワードパラメーターが省略された場合は初期値が使用される。キーワードパラメーターが初期値なしで定義された場合は初期値にnilを指定したものと見做される。

    ) (function k1-k2-k3 (:key k1 k2 k3)
        (list k1 k2 k3))
    k1-k2-k3
    ) (k1-k2-k3 :k1 1 :k2 2)
    (1 2 nil)
    ) (k1-k2-k3 :k1 1)
    (1 2 nil)

次のように、キーワードパラメーターの仮引数の順序と実引数の順序は一致しなくてもよい。

    ) (k1-k2-k3 :k3 3 :k1 1)
    (1 nil 3)

## 汎関数
前述したように関数はアトムの種類の一つに過ぎない。そのため、他のデータ型である数値や文字列と同様に、シンボルを束縛したり、関数に引数として渡したり、関数の返り値として返したりすることができる。

関数全体の集合のうち関数を引数に受け取る、または、返り値が関数であるように定義された関数を汎関数という。

## 汎関数ユーティリティ
Parenに組み込みで用意されている汎関数をいくつか示す。汎関数を用いることにより、高度な抽象化を用いることができる。

### リストを写像する
mapは引数のリストを写像した結果を返す汎関数である。

    (map fn list) => result
    fn -- 写像関数
    list -- 写像前のリスト
    result -- 写像後のリスト

次の例は、引数のリストを二倍する。

    ) (function double (* 2 x))
    double
    ) (map double '(1 2 3))
    (2 4 6)

### リストをグルーピングする
group-byは指定した関数が返した結果でグルーピングする。

    (group-by fn list) => result
    fn -- グループ分けするカテゴリを返す関数
    list -- グループ分けするリスト
    result -- グルーピングされたリスト

次の例は、引数のリストを絶対値ごとにグルーピングする。

    ) (group-by abs '(-1 1 2 -3 3))
    ((1 -1 1) (2 2) (3 -3 3))

### リストから要素を取り除く
removeは引数のリストの要素のち、関数が真を返す要素を取り除いたリストを返す。

    (remove fn list) => result
    fn -- 要素を取り除くか決める関数
    list -- 要素を取り除く対象のリスト
    result -- 要素を取り除いた後のリスト

次の例は、負の数を取り除いたリストを返す。

    ) (remove (f (x) (< x 0)) '(0 1 -2 3))
    (0 1 3)

## 再帰関数
関数全体の集合のうち、関数の本体で自分自身を呼ぶような関数を再帰関数と呼ぶ。

再帰関数を用いると直感的にプログラムできることがある。典型的な例として整数nの階乗を求める関数factorialを示す。

    (function factorial (n)
      (if (= n 1) 1 (* n (factorial (- n 1)))))

これはfor文を用いるより、直感的である。

    (function factorial (n)
      (let (result n)
        (while (/= n 1)
          (<- result (* result (<- n (-- n)))))
        result))

また、再帰関数全体の集合のうち自身の呼び出しごとにスタックが積まれないような関数を末尾再帰関数という。

上記のfactorialは呼び出しごとにスタックが積まれていくため末尾再帰関数ではない。

factorialは次のような末尾再起関数に変換できる。

    (function factorial (n)
      (let (rec (n acc)
             (if (= n 1) acc
                 (factorial (-- n) (* acc n))))
        (rec n 1)))

## 純粋関数
次の性質を参照透過性といい、関数全体の集合のうち、この性質を持つものを純粋関数という。

- 任意の引数に対して、返り値が環境に依存せずに一意に定まる
- 他に何も影響を与えない

また、二つ目の性質

    他に何も影響を与えない

のことを副作用という。

次のような処理は副作用がある。

- 親の環境への束縛
- 入出力

定義から、次のような関数は純粋関数ではない。

- あるグローバルシンボルの値の3倍の数を返す関数
- 引数を標準出力に印字する関数
- 引数の値を3倍に変更する関数

逆に、次の処理を行うだけの関数は純粋関数である。

- 引数を返す関数
- 引数の文字列表現を返す関数
- 引数の値の3倍の値を返す関数

可能な限りプログラムは純粋関数で構成することが望ましい。

これは、純粋関数はそうでない関数に比べてとりうる状態が少なく、一般的に汎用的な処理になりバグも発生しにくいことによる。

# 条件分岐
Parenには豊富な条件分岐のオペレータが用意されている。また、必要であればマクロを用いることにより条件分岐のオペレーターを追加することもできる。

## 真偽値
Parenではnilが偽を表し、それ以外の値は真と見做される。

## if
ifは条件分岐を行うスペシャルオペレーターである。

    (if test-then ... [else-form]) => result
    test-then ::= test-form then-form
    test-form -- 評価され真の場合にのみthen-formが評価される。
    then-form -- test-formの評価結果が真の場合にのみ評価される。
    else-form -- すべてのtest-formが偽だった場合にのみ評価される。
    result -- 最後に評価した式

任意の数のtest-formとthen-formを続けることができ、必要であればelse-formもつけることができる。

    ) (function number->roman (x)
        (if (= x 1) :one
            (= x 2) :two
            (= x 3) :three
            :more))
    ) (number->roman 1)
    :one
    ) (number->roman 4)
    :more

## when
whenは条件が真を返したときのみ複数フォームを評価したい場合に用いる。

    (when test then-form ...)
    test -- 真偽値
    then-form -- testが真の場合に評価するフォーム
    else-form -- testが偽の場合に評価するフォーム

## 述語の結合
ある式の評価結果が真か偽かを表すことを強調する場合その式を述語という。

複数の述語を結合する述語が、マクロで定義されている。

    名称 処理
    ------------------------------------------------------------------------
    &&   すべての引数の評価結果が真の場合に最後の評価結果を返す。
         ただし、評価途中に偽を返す式があったら以降の評価を中断しnilを返す。
    ||   どれか一つの引数の評価結果が真の場合にその値を返す。
         ただし、評価途中に真を返す式があったら以降の引数は評価しない。
         また、すべての引数の評価結果が偽の場合はnilを返す。
    !    述語が真の場合は偽を、偽の場合は真を返す。

# 反復
Parenには反復処理を行うためのオペレーターがいくつか存在する。

- while
- for
- dolist
- dotimes

また、このほかに必要に応じてユーザが反復処理を行うマクロを定義することができる。

## while
whileは条件を満たす間反復するマクロである。

    (while end-test-form
        body-form ...)
    end-test-form -- 反復終了判定式
    body-form -- 反復処理

次の規則で反復処理が行われる。

    1. end-test-formを評価した結果が真なら2へ偽なら反復終了
    2. body-formを逐次評価し、1へ戻る

## for
forはwhileよりも細かく反復条件を指定することができるマクロである。

    (for binding-form end-test-form step-form
        [body-form] ...)
    binding-form ::= (sym-val ...)
    sym-val ::= sym val
    end-test-form -- 反復判定式
    step-form -- 反復する度に評価される式
    body-form -- 反復処理

forは次の手順で評価される。

    1. binding-formのシンボルと値の組を環境に束縛する。
    2. end-test-formを評価した結果が真の場合3へ、偽なら反復終了
    3. body-formを逐次評価
    4. step-formを評価して1へ戻る

単純なforの使用例として1から10までの和を順次出力するプログラムを示す。

    ) (for (i 0 sum 0) (<= i 10) (<- i (++ i))
        (print (<- i (++ i))))
    0
    1
    3
    6
    10
    15
    21
    28
    36
    45
    55
    nil

# スペシャルオペレーター
スペシャルオペレーターはParenの他の評価規則に従わない特殊なオペレーターである。

スペシャルオペレーターには次の種類が存在する。

- let
- dynamic
- <-
- begin
- macro
- f
- quote
- if
- labels/goto
- throw/catch
- return
- unwind-protect
- assert

この章では主要なスペシャルオペレータについてのみ説明を行う。

## <-(シンボル束縛)
束縛オペレータ―はシンボルの章で説明した。

## begin(逐次評価)

    (begin body-form ...) => result
    body-form -- 逐次評価する式
    result -- 最後に評価した式
              ただし、実行する式がなかった場合はnil

beginは左から順に式を評価し、引数がある場合は最後の式の評価結果を返し、そうでなければnilを返す。

beginは主にifのthen節やマクロ定義時に使用される。

組み込みでは、forやwhileなど複数の式を評価するマクロの展開結果に含まれる。

このように利用者が直接見ることはないが、暗にマクロの展開結果で利用されているbeginを暗黙のbeginという。

## f(無名関数)

    (f ([required_param] ...
             [:opt optional_param ...]
             [{ :rest rest_param | :key keyword_param ... }] )
        body ...)
    required_param -- 必須パラメーター
    optional_param -- オプショナルパラメーター
    keyword_param -- キーワードパラメーター
    rest_param -- レストパラメーター
    body -- 関数本体

fは関数を作成するスペシャルオペレーターである。

fに与える引数は、名前を指定しないという点を除いてfunctionと全く同じである。

fが作る関数のことをその名前がないことにちなみ、無名関数という。無名関数は汎関数を使うときにしばしば用いられる。

関数の章で述べたmapの使用例を再喝する。

    ) (function double (* 2 x))
    double
    ) (map double '(1 2 3))
    (2 4 6)

これは、しばしば次のように書かかれる。

    ) (map (f (x) (* 2 x)) '(1 2 3))
    (2 4 6)

## if(条件分岐)
ifは条件分岐の章で述べた。

## labels/goto(ジャンプ機構)
labels及びgotoはセットで使われるジャンプ機構である。

使用頻度の低さから、この文書では説明を割愛する。

## throw/catch(例外処理機構)
これらのスペシャルオペレーターは例外処理の章で述べる。

## return(大域脱出)
returnは現在のfコンテキストから大域脱出するためのスペシャルオペレーターである。

    ) ((f () 1 (return 2) 3))
    2

マクロにより、暗黙のfで包まれている場合、想定した結果にならないことがあるため注意が必要である。

## unwind-protect(unwindからの保護)
unwind-protectはunwindされる前に必ず保護された式を評価することを保証するスペシャルオペレーターである。

有名なマクロにファイルをオープンする際に、クローズを保証するwith-open-fileマクロがある。

## macro(マクロ)
マクロの章で述べる。

## quote(評価見送り)
quoteは引数を評価しないようにするスペシャルオペレーターである。

    (quote expr)
    expr -- 評価しない式

次のように引数の値がそのまま返される。

    ) (<- a 3)
    3
    ) a
    3
    ) (quote a)
    a

このように、評価を見送ることをクォートするという。Parenでは、クォートすることが頻繁にあるため、そのための構文糖`'`がリードマクロで定義されている。

クォートする対象に`'`を前置するとその対象がクォートされる。

    ) 'a    ;; <=> (quote a)
    a

クォートは次のように定数のリストを作成するときに利用できる。

    ) '(1 2 3)
    (1 2 3)

クォートは、評価するタイミングをずらすためにマクロ定義に頻繁に利用される。

# マクロ
マクロは、プログラムが評価される前に評価されるプログラムである。このことは、同一ファイル内に評価するタイミングの異なるソースコードが混在していることを意味する。

Parenのマクロが他の言語と大きく異なるのは、マクロが言語と調和していることである。これにより、マクロが言語の拡張を容易にする。

例えば、C言語のマクロはC言語とは全く関係ない一つの言語に等しく、本質的には単に文字列の置換相当の処理を行っているに過ぎない。

## マクロ定義
マクロはスペシャルオペレーターmacroを使って定義する。

    (macro name params body ...) => result
    params ::= param ...
    param ::= '('
                  [{ param | required_param } ...  ]
                  [:opt optional_param ...]
                  [{ :rest rest_param | :key keyword_param ... }]
              ')'
    name -- マクロを束縛するシンボル
    required_param -- 必須パラメーター
    optional_param -- オプショナルパラメーター
    keyword_param -- キーワードパラメーター
    rest_param -- レストパラメーター
    body -- マクロ本体
    result -- nil

関数と類似しているが、マクロの方が引数をより柔軟に指定できる。

## マクロの評価
マクロが評価されることをマクロ展開という。

マクロ展開は展開結果にマクロが含まれなくなるまで再帰的に行われる。マクロ展開後に、展開結果が評価される。

## 組み込みのマクロ
ここではいくつかの組み込みマクロの定義を述べる。

    ) (for (i 0) (< i 5) (<- i (++ i))
        (print i))
    0
    1
    2
    3
    4
    nil

マクロは、しばしば他のマクロを用いて定義される。一つの例として組み込みマクロwhileを示す。

    (macro while (test :rest body)
      (cons 'for (cons nil (cons test (cons nil body)))))

    ) (let (i 0)
        (while (< i 5)
           (print i)
           (<- i (++ i))))
    0
    1
    2
    3
    4
    nil

チュートリアルでマクロの有用性について述べるのは限界がある。興味のある方は、On Lispをお勧めする。

# クラス
Parenは関数型言語として設計されているが、ここではマクロを用いてParenの上に構築されたオブジェクト指向言語について述べる。以後、このドメイン特化言語をPOS(Paren Object System)と呼ぶ。

## クラスの作成
クラスはマクロclassにより作成する。

    (class name ([super [feature] ...]) [field] ...)
    name -- クラスの名前
    super -- スーパークラス
    feature -- フィーチャークラス
    field -- インスタンス変数

クラスは名前、インスタンス変数を指定して作成する。

例として二次元実数空間全体の集合の元を表すクラスPointを示す。クラス名は慣習としてパスカルケースで命名する。

    (class Point () x y)

## スーパークラス
クラス定義時にスーパークラスを指定した場合スーパークラスのインスタンス変数とメソッドが継承される。

    (class A () a)
    (class B (A) b)    ; A <- B
    (class C (B) c)    ; A <- B <- C

クラスは、Objectをルートとしたツリー構造をもつ。スーパークラスを指定しない場合には、暗にObjectクラスを継承する。

    (class X ()) <=> (class X (Object))

`is-a?`関数はオブジェクトが、あるクラスのインスタンスか調べるための関数である。継承している場合も次のように真を返す。

    ) (is-a? (.new B) A)
    true
    ) (is-a? (.new C) D)
    nil
    ) (is-a? (.new E) A)
    true

## フィーチャー
フィーチャーはクラスを横断して共通のメソッドを定義する仕組みである。

    (class X (Object A B C))

上の例では、Objectクラスを継承し、A、B、Cクラスのメソッドを呼び出し可能であるようなクラスXを定義できる。

フィーチャーを指定しても、そのクラスのインスタンスとは見做されない。

    ) (is-a? (.new X) A)
    nil

## インスタンスの生成
インスタンスの生成には.newメソッドを使用する。

    ) (.new Object)
    (:class Object)

結果の通り、POSのオブジェクトはただのリストである。

生成したオブジェクトのインスタンス変数はすべてnilで初期化される。

## インスタンス変数の参照と代入
クラス定義時にインスタンス変数へのアクセサが、`'&' + インスタンス変数名`、`'&' + インスタンス変数名 + '<-'`として自動で生成される。

Pointクラスにはx及びyというインスタンス変数があったため、それぞれ`&x, &x<-`、`&y, &y<-`というアクセサが自動で生成されている。

    ) (&x<- (<- p (.new Point)) 10)
    (:class Point ...)
    ) (&x p)
    10

セッターの返り値は自身となる。そのため、メソッドチェーンによる記述も可能。

    ) (&y<- (&x<- (<- p (.new Point)) 10) 20))
    10

POSでは、他のクラスのメソッド内でアクセサを直接呼び出すことはマナー違反となる。

外に公開する関数は後述するメソッドを用いて明示的に宣言を行う。

## メソッドの定義
メソッドは、レシーバにより振る舞いを変えるような関数を定義するための仕組みである。

メソッドの定義はmethodマクロを使用する。

    (function class name ([required_param] ...
                          [:opt optional_param ...]
                          [{ :rest rest_param | :key keyword_param ... }] )
        body ...)
    name -- メソッド名
    class -- メソッドを決定するクラス
    required_param -- 必須パラメーター
    optional_param -- オプショナルパラメーター
    keyword_param -- キーワードパラメーター
    rest_param -- レストパラメーター
    body -- メソッド本体

同一クラスには同名メソッドは一つまでしか定義できない。

methodマクロはclassを指定することを除き、functionマクロと同じである。

ただし、本体のコンテキストではシンボル`self`が呼び出しオブジェクトとして暗に束縛されている。

慣習として、メソッド名は`.`から始める。例外として、外部のクラスに公開したくないメソッドは`_`から始める。

メソッドは呼び出し時に、呼び出し可能なメソッドが動的にディスパッチされて実行される。例えば、次のクラスとメソッドが定義されている場合を考える。

    (class Duck ())
    (class Cat ())
    (method Duck .sound () "quack")
    (method Cat .sound () "myaa")

この場合、呼び出される引数の型により動的にメソッドがディスパッチされる。

    ) (.sound (new Duck))
    "quack"
    ) (.sound (new Cat))
    "myaa"

## メソッドの完全修飾名
methodマクロを用いると、内部的にクラス名とメソッド名を結合した名前のシンボルを束縛する。

スーパークラスのメソッドをオーバーライドした場合などに、明示的にスーパークラスのメソッドを指定する用途などで使用できる。

以下に、簡単な例を示す。

    (class Duck ())
    (class XDuck (Duck))
    (method Duck .sound () "quack")
    (method XDuck .sound () "xquack")

    (.sound (.new XDuck)) ; xquack
    (Duck.sound (.new XDuck)) ; quack

# 初期化メソッド
POSでは、インスタンスを初期化するメソッドを.initという名称で作成する。

.initメソッドが引数不要な場合、インスタンス生成時に自動で.initも呼ばれる。

.initに引数が必要な場合はプログラマが明示的に呼ぶ必要がある。これはプログラマの責任となる。

## メソッドのディスパッチ
メソッドは次の優先順位で探索される。

    - そのクラスのメソッド
    - フィーチャーのメソッド(フィーチャーのリストの先頭から探索)
    - スーパークラスのメソッド

また、最初にディスパッチされたメソッド以外を取得する方法は公開していない。

# 例外処理機構
## 階層構造
Parenのすべてのエラー/例外はExceptionクラスを継承している。

    Object
        Exception
                Error

一般に、新たにクラスを作成する場合はErrorクラスを継承すべきである。

## 例外のスロー
例外をスローさせるにはthrowを使用する。

    (throw (.new Error))

throwの引数は必ずExceptionオブジェクトのサブクラスでなければならない。

## 例外の補足
例外を補足させるにはcatchマクロを使用する。

    (catch (handler-list) body)
    handler-list ::= (throwable-class (args) body) ...
    throwable-class -- Throwableクラスのサブクラス
    args -- 例外補足時にハンドラーの本体で参照される仮引数
    body -- 本体処理

body内で例外がスローされた場合、catchに登録されたハンドラーを左から順に探索し補足可能なクラスの場合にハンドラーの本体が実行される。

補足可能なハンドラーがなかった場合は、このcatchよりも上位に再度スローされる。

例えば、次のコードはcatchの本体にて例外がスローされた場合に、Exception2のインスタンスである場合は、Exception2のハンドラーの本体処理が実行される。

    (catch (Exception1 (f (e) body ...)
            Exception2 (f (e) body ...)    ; catch!
            Exception3 (f (e) body ...))
    ...
    (throw (.new Exception2))
    ...)

# 終章
ここまで読み進めればParenの機能についてあらかた理解したといえる。

また、core.pも読むことができると思われる。

# 付録

# Common Lispとの違い
Lisp経験者のために代表的なCommon Lispとの違いを述べる。

## シンボルの変換
両者ともシンボルの大文字小文字を区別するが、Common Lispはデフォルトで大文字に変換するのに対して、Parenでは一切変換を行わない。

## 多値を返す関数
Parenは多値を返す関数はない。

## 純リスト
Parenの任意のリストは純リストである。ドット対に対応するデータ構造はない。
