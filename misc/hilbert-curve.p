; Hirbert curve.

(import :matrix)
(import :optparse)
(import :point)

(<- $p nil
    $unit-size 3
    $size nil
    $canvas nil)

(function show (canvas)
  (domatrix (p canvas)
    (if (= (.y p) 0) (write-line))
    (write-bytes (|| (.at canvas p) "　")))
  (write-line))

(function draw-line (dir)
  (if (= dir :up)
      (dotimes (i $unit-size)
        (.put $canvas $p "｜")
        (<- $p (.add $p (point -1 0))))
      (= dir :down)
      (dotimes (i $unit-size)
        (.put $canvas $p "｜")
        (<- $p (.add $p (point 1 0))))
      (= dir :right)
      (dotimes (i $unit-size)
        (.put $canvas $p "―")
        (<- $p (.add $p (point 0 1))))
      (= dir :left)
      (dotimes (i $unit-size)
        (.put $canvas $p "―")
        (<- $p (.add $p (point 0 -1))))
      (assert nil)))

(function urd (n)
  (when (> n 0)
    (rul (-- n))
    (draw-line :up)
    (urd (-- n))
    (draw-line :right)
    (urd (-- n))
    (draw-line :down)
    (ldr (-- n))))

(function ldr (n)
  (when (> n 0)
    (dlu (-- n))
    (draw-line :left)
    (ldr (-- n))
    (draw-line :down)
    (ldr (-- n))
    (draw-line :right)
    (urd (-- n))))

(function dlu (n)
  (when (> n 0)
    (ldr(-- n))
    (draw-line :down)
    (dlu(-- n))
    (draw-line :left)
    (dlu(-- n))
    (draw-line :up)
    (rul(-- n))))

(function rul (n)
  (when (> n 0)
    (urd (-- n))
    (draw-line :right)
    (rul (-- n))
    (draw-line :up)
    (rul (-- n))
    (draw-line :left)
    (dlu (-- n))))

(function hirbert-curve (n)
  (<- $size (int (* (- (exp 2 n) (/ (exp 2 n))) $unit-size))
      $p (point (-- $size) 0)
      $canvas (.init (.new Matrix) (point $size $size)))
  (urd n)
  (show $canvas))

(function! main (args)
  (let ((op args) (.parse (.init (.new OptionParser) "n:") args))
    (if (.get op "n") (hirbert-curve (int (.get op "n")))
        (hirbert-curve 4))))
