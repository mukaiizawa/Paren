Paren言語仕様書

この資料はParenの仕様を定義する。

# 基本概念
ParenはCommon Lispと様々なオブジェクト指向言語から影響を受けた言語である。
Common Lispをよりオブジェクト指向に扱えるように工夫がされてある。
## S式
Parenはatomまたはlistにより記述される。
この記述をS式と呼ぶ。
S式は評価されると値を返す。

# メタ言語
Parenの文法を以下のEBNF表記で定義する。
    x? -- xは省略可能。
    . -- 任意の一文字
    $ -- 行末
    x* -- xの零回以上の繰り返し。
    x+ -- xの一回以上の繰り返し。
    (x | y) -- xまたはy。
    'x' -- 固定字句。文字の並びxを示す。xは複数の場合もある。
    [...] -- 文字グループ。[]内で指定された文字の何れか。
             x-yと表記された場合はxとyの間の何れかを表す。
             先頭に~を指定した場合は[]内で指定された文字以外の何れかを示す。
    = -- 定義。左辺で示される構文要素を右辺で定義される。
    \x -- エスケープシーケンス。xを文字そのものとして解釈する。

# 字句規則
字句規則はリードマクロ展開時とParen評価時の２つ存在する。
ここではParenの評価時の字句規則を示す。
## 字句の区切り(separator)
    separator = space | comment
Parenは空白又はコメントにより区切られる。
これらは要素の区切りとして使用される以外は無視される。
### 空白(space)
    space = [\t\n ]
空白はタブ文字、改行文字、半角スペースである。
### コメント(comment)
    comment = (';'.*$ | '#|'.* '|#')
セミコロンから行末まで
または、`#|`で始まり`|#`で終わる任意の文字列で表現される。
## S式(s_expr)
    s_expr = list | atom
S式はリストまたはアトムである。
### リスト(list)
    list = '()' | '(' s_expr (separator s_expr)* ')'
リストは零以上のS式を丸括弧`(`、`)`で括ったものである。
リストの要素がない場合(空のリスト)はnilと見做される。
### アトム(atom)
    atom = (symbol | keyword | number | char | string)
アトムは次のうちのいずれかである。
- シンボル
- キーワード
- 数値
- 文字
- 文字列
#### シンボル(symbol)
    symbol = xletter+
シンボルは予約文字以外の任意の文字の列である。
なお、Common Lispにおけるvertical barに挟まれた任意の文字の列
    '|' .* '|'
によるシンボルはParenでは許可しない。
#### キーワード(keyword)
    keyword = ':' xletter+
キーワードは':'から始まる任意の長さの予約外文字の列である。
##### 予約外文字(xletter)
    xletter = [^ ():;`',@\\]
予約外文字はParenで特殊な意味を持ちうる文字以外の文字である。
#### 数値(number)
    number = (0 | (+|-)?[1-9][0-9]*) '.' [0-9]*
Parenでは指数表記等はサポートしない。
#### 文字(char)
    char = '\'' (. | esc) '\''
文字はシングルクォートで囲まれた任意の一文字、
またはエスケープシーケンスである。
#### 文字列(string)
    string = '"' (. | esc)* '"'
文字列はダブルクォートで囲まれた任意の文字の列である。
##### エスケープシーケンス(esc)
    esc = '\' .
エスケープシーケンスは'\'から始まり、次の意味をもつ。
- n: 改行
- t: 水平タブ
それ以外の文字は、文字そのものを表す。

# リードマクロ
リードマクロはParenの読み込み時に実行される。
実行された結果はS式を返す。
返されたS式はParenの構文である必要がある。
組み込みのリードマクロには次の種類がある。
- `
- ~
- ,
- ,@
Parenでは、組み込み以外のリードマクロの定義は許さない。
## バッククォートリードマクロ
バッククォートリードマクロはその直後のS式を、
後述スペシャルフォーム`quote`に展開する。
他のLisp言語における`'`と同じ振る舞いをする。
評価例を示す。
    `(list 1 2 3)
    => (list 1 2 3)
## チルダリードマクロ
チルダリードマクロはその後に読み込まれるS式内に、
後述するカンマリードマクロ`,`または、
カンマアットリードマクロ`,@`が含まれている場合を除き、
バッククォートリードマクロと同じ振る舞いをする。
## カンマリードマクロ
カンマリードマクロはチルダリードマクロ内で使用できる。
チルダリードマクロ外で使用した場合はエラーとなる。
チルダリードマクロ内のフォームは評価対象外となるが、
その中のカンマリードマクロ内のフォームを評価対象にする。
評価例を示す。
    ~(list 1 `,(list 2 3))
    => (list 1 `(2 3))
## カンマアットリードマクロ
カンマアットリードマクロは評価結果を、
外側のListに結合させる点を除き、
カンマリードマクロと同じである。
評価例を示す。
    ~(list 1 ,@(list 2 3))
    => (list 1 2 3)

# マクロ
マクロはParenが読み込まれ、リードマクロが展開された後に実行される。
この実行をマクロ展開という。
マクロはリードマクロ、マクロ、スペシャルフォーム、 関数等、
ほぼすべてのParenの機能を使用してユーザが定義することができる。
マクロは使用される前に定義がされている必要がある。
マクロ展開は、展開結果にマクロが含まれなくなるまで再帰的に行われる。
展開結果がParenの文法に従っていればよいため、
展開前のフォームはしばしばParenの文法に従わない。
## 組み込みマクロ
よく使う組み込みのマクロを示す。
- defun
- and
- or
- for
### defun
`defun`は関数を定義するときにのシンタックスシュガーとなる。
    (defun double (:Number n)
        (* n n))
    <=> 
    (progn
        (def double)
        (<- double
            (fn (:Number n)
              (* n n))))
`defun`は展開されると関数を定義するフォーム群に展開される。
仮にdefunがマクロ/スペシャルフォームでなく、
Parenの評価ルールに従う場合は`double`はシンボルとして評価されてしまうことに注意。
### and, or
`and`、`or`は後述する条件分岐を実現するスペシャルフォーム、
`ifElse`に展開される。
`and`は引数がすべて真の場合に最後の引数の評価結果を返す。
    (and test1 test2 test3)
    <=>
    (ifElse test1
            (ifElse test2
                    (ifElse test3)))
`or`は引数のうち、どれかが真の場合にその評価結果を返す。
    (or test1 test2 test3)
    <=>
    (ifElse test1
            test1
            (ifElse test2
                    test2
                    (ifElse test3)
                            test3))
`and`、`or`いずれも短絡評価となる。
## for(反復)
    (let (i 0)
        (for (<- i 0) (< i 10) (++ i)
             expr1
             expr2
             ...
             exprN))
`for`は反復構造を実現するスペシャルフォームである。
第一引数が最初に実行されるフォームである。
第二引数が反復開始の度に実行され、真のである場合のみ反復される。
第三引数は反復の度に実行されるフォームである。
また、最後に評価された値が返される。
C言語系との対比を次に示す。
    for (i = 0; i < 10; i++) {
        expr1;
        expr2;
        ...
        exprN;
    }
C言語系の言語同様に、`break`、`continue`フォームもサポートする。(予定)

# スペシャルフォーム
スペシャルフォームはParenのS式の評価ルールに従わない、
フォームごとに異なる特別なルールで評価される。
スペシャルフォームには次の種類が存在する。
- def
- <-
- let
- ifElse
- progn
- quote
- fn
## def(変数宣言)
    (def var1 va2 ... varN)
`def`により変数宣言ができる。
使用する変数を複数指定することも可能。
宣言する変数が既に宣言されている場合はエラーと見做す。
返り値は`nil`である。
## <-(代入)
    (<- var1 val1
        var2 val2
        ...
        varN valN)
`<-`は変数に値を代入する。
引数の数は偶数でなければならない。
左から順に2n番目の変数に2n + 1番目の値を代入される。
評価結果はそれ以降の評価に干渉する。
フォームは最後に評価(代入)された値を返す。
## let(変数束縛)
    (let (var1 val1 var2 val2 ... varN valN)
      expr1
      expr2
      ...
      exprN)
`let`は新しく変数を束縛する。
束縛する変数が既に宣言されていても構わない。
第一引数が変数束縛のListを表す。
第二引数以降が、第一引数で束縛した変数の環境下にて暗黙のprognにより評価される。
## progn(逐次実行)
    (progn form1 form2 ...  formN)
prognは引数のフォームを左から順に評価していき、
最後のフォームの評価結果を返す。
## ifElse(条件分岐)
   (ifElse (< n 0) -1
           (= n 0) 0
           1)
`ifElse`は条件分岐を実現するスペシャルフォームである。
第一引数の評価結果が真の場合は第二引数を、
そうでなければ第三引数の評価結果が真の場合は…
のように評価される。
C言語系の条件分岐との比較イメージを示す。
    if (n < 0) return -1;
    else if (n = 0) return 0;
    else return 1;
## quote(評価見送り)
    (quote expr)
`quote`はS式`expr`の評価を見送り、`expr`そのものを返す。
その利用頻度から構文糖であるバッククォートリードマクロが定義されている。
## fn(無名関数)
    (fn (:Type arg1 arg2 ... argN)
         expr1
         expr2
         ...
         exprN)
`fn`は無名関数を定義する。
`:Type`は第一引数`arg1`の型を指定する。
`:Type`は省略でき、その場合は任意の型を意味する。
関数をシンボルに代入する際には次の処理が行われる。
シンボルに関数以外の値が入っている場合
関数をシンボルに代入する。
シンボルに関数が入っている場合
`:Type`と一致する関数が存在する場合は上書きする。
存在しなければ既に定義されている関数に総称関数として追加する。
また、関数は第一引数と強く結びつくため、
少なくとも一つの引数を指定しなければならない。

# 関数
Parenで関数を定義する場合は通常マクロ`defun`を使用する。
Parenは総称関数をサポートしてあり、
総称関数のシグネチャは次の2つで決まる。
1. メソッド名称
2. 第一引数の型
シグネチャが重複する関数は定義できない。
したがって、次のメソッド`put`が定義されている場合には、
    (defun put (:Stream stream str)
           ...)
次のような、シグネチャが重複するメソッドは定義できない。
    (defun put (:Stream stream char n)
       ...)
    => error.
シグネチャは引数の数や第二引数以降の引数の型には依存しないことに注意する必要がある。
次のようにシグネチャが異なる場合は総称関数を定義することができる。
    ;; 第一引数の型が異なる
    (defun put (:Map map obj)
       ...)
    ;; メソッド名称が異なる
    (defun putLn (:Stream stream str)
       ...)
関数呼び出しは呼び出す際の第一引数の型により動的に割り当てられる。
    ;; xの型により、メソッド`put`が定まり実行!!
    (put x y)
