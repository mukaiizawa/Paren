core.p:      (nil? delim) (apply bytes-concat l)
core.p:  (&& (>= (bytes-length s) (bytes-length prefix))
core.p:      (bytes-index s prefix 0 (bytes-length prefix))))
core.p:    (&& (>= (bytes-length s) (bytes-length suffix))
core.p:        (bytes-index s suffix (- (bytes-length s) (bytes-length suffix)))))
core.p:    (if (nil? end) (bytes-slice s (.tell ms))
core.p:          (bytes-slice s pos (.tell ms))))))
core.p:              join-chars (lambda () (if chars (apply bytes-concat (reverse! chars)) "")))
core.p:  (assert (eq? (bytes->symbol "foo") 'foo)))
core.p:(builtin-function bytes->symbol (x :opt i size)
core.p:  (assert (eq? (bytes->symbol "foo") 'foo)))
core.p:(builtin-function bytes->keyword (x)
core.p:  (assert (eq? (bytes->keyword "foo") :foo)))
core.p:(builtin-function bytes->string (x :opt i size)
core.p:  (assert (bytes= (bytes->string 'foo) "foo"))
core.p:  (assert (bytes= (bytes->string 'foo 1) "oo"))
core.p:  (assert (bytes= (bytes->string 'foo 1 1) "o")))
core.p:(builtin-function bytes->string! (x)
core.p:  ; Same as (bytes->string x), except that it destructively modifies the x.
core.p:  ; Generally faster than bytes->string.
core.p:            (bytes= (bytes->string! x) "\x01"))))
core.p:(function bytes->list (s :opt delim)
core.p:      (let (acc nil i 0 pos nil slen (bytes-length s) dlen (bytes-length delim))
core.p:        (while (&& (< i slen) (<- pos (bytes-index s delim i)))
core.p:          (push! acc (bytes-slice s i pos))
core.p:        (push! acc (bytes-slice s i slen))
core.p:(builtin-function bytes-length (x)
core.p:  (assert (= (bytes-length "") 0))
core.p:  (assert (= (bytes-length "012") 3)))
core.p:(builtin-function bytes-index (x b :opt start end)
core.p:  (assert (= (bytes-index "012" 0x31 1) 1))
core.p:  (assert (= (bytes-index "012" 0x31 0 3) 1))
core.p:  (assert (= (bytes-index "012" 0x31 0 3) 1))
core.p:  (assert (= (bytes-index "012" "12" 0 3) 1)))
core.p:(builtin-function bytes-copy (src src-i dst dst-i size)
core.p:            (bytes= (bytes-copy s 1 d 1 2) "boo"))))
core.p:(builtin-function bytes-slice (x start :opt end)
core.p:  (assert (bytes= (bytes-slice "012" 0) "012"))
core.p:  (assert (bytes= (bytes-slice "012" 1) "12"))
core.p:  (assert (bytes= (bytes-slice "012" 1 2) "1")))
core.p:(builtin-function bytes-concat (x :rest args)
core.p:  (assert (bytes= (bytes-concat "0" "1" "2") "012")))
core.p:    (let (key (bytes->keyword field)
core.p:              field (bytes->string field)
core.p:              getter (bytes-concat '& field)
core.p:              setter (bytes-concat '& field '<-))
core.p:                           (list (bytes->symbol (bytes-concat '& (car pair) '<-)) go (cadr pair)))
core.p:  (let (global-sym (bytes-concat cls-sym method-sym))
core.p:      (dolist (field (reverse! (map bytes->keyword (assoc cls :fields))))
core.p:  (let (class-name (bytes->string (&class self)) msg (&message self))
core.p:    (if msg (bytes-concat class-name " -- " msg)
core.p:            (<- path-name (bytes-concat
core.p:                                (bytes-concat (getenv "HOMEDRIVE") (getenv "HOMEPATH"))
core.p:      (Path.of (bytes-concat (.to-s self) Path.separator (.to-s path)))))
core.p:        (&& (= (bytes-length first-file) 2)
core.p:            (bytes-index first-file ":" 1 2))
core.p:            (bytes-concat (if (string= acc Path.separator) "" acc) Path.separator rest))
core.p:      (bytes->string! c))))
core.p:        (dotimes (i (bytes-length x))
core.p:  (let (req (+ (&wrpos self) size) buf-size (bytes-length (&buf self)))
core.p:        (bytes-copy (&buf self) 0 buf 0 (&wrpos self))
core.p:    (bytes-copy (&buf self) (&rdpos self) buf (&wrpos self) size)
core.p:  (.reserve self (|| size (<- size (bytes-length bytes))))
core.p:  (bytes-copy bytes (|| from 0) (&buf self) (&wrpos self) size)
core.p:        (bytes->string (&buf self) 0 size))))
core.p:  (fwrite x (|| from 0) (|| size (bytes-length x)) (&fp self)))
core.p:  (|| (bytes-index "!#$%&*./<=>?^[]_{|}" (.next self))
core.p:  (bytes-index "+-" (.next self)))
core.p:               (bytes->symbol (.token (.get-identifier-sign self)))))))
core.p:  (bytes->symbol (.token (.get-identifier self))))
core.p:  (bytes->keyword (.token (.get-identifier self))))
core.p:        (string= next "#") (begin (.skip self) (list :read-macro (bytes->symbol (.next self))))
core.p:        (let (p (Path.of (string (bytes->symbol key) ".p")))
json.p:      (string "\"" (bytes->string x) "\"")))
json.p:      (push! object (bytes->keyword (.parse-string (.skip-space self))))
json.p:      (push! object (bytes->keyword (.parse-string (.skip-space self))))
markdown.p:    (if (<= 1 level  6) (list (bytes->symbol (string 'h level)) (.skip-line (.skip-space self)))
md2html.p:    (while (<- i (bytes-index id "." (++ i)))
regex.p:  (let (r (.new Regex) s 0 e (bytes-length expr) anchored? nil)
regex.p:    (if anchored? (<- expr (bytes-slice expr s e)))
xml.p:      (push! attrs (bytes->keyword (.token self)))
xml.p:      (if (! (bytes-index "'\"" (<- q (.skip (.skip-space self))))) (continue))    ; single attribute
xml.p:  (bytes->symbol (.token self)))
xml.p:      (return (list stag? (bytes->symbol (.token self)))))    ; return etag symbol.
