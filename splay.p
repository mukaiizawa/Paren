; splay module.

(class SplayNode ()
  key val left right)

(method SplayNode .init (:key key val left right)
  (&key! self key)
  (&val! self val)
  (&left! self left)
  (&right! self right))

(method SplayNode .rotl ()
  (let (p (&left self))
    (&left! self (&right p))
    (&right! p self)
    p))

(method SplayNode .rotr ()
  (let (p (&right self))
    (&right! self (&left p))
    (&left! p self)
    p))

(method SplayNode .rotll ()
  (let (p (&left self) q (&left p))
    (&left! p (&right q))
    (&right! q self)
    q))

(method SplayNode .rotrr ()
  (let (p (&right self) q (&right p))
    (&right! p (&left q))
    (&left! q self)
    q))

(method SplayNode .rotlr ()
  (let (p (&left self) q (&right p))
    (&right! p (&left q))
    (&left! q p)
    (&left! self (&right q))
    (&right! q self)
    q))

(method SplayNode .rotrl ()
  (let (p (&right self) q (&left p))
    (&left! p (&right q))
    (&right! q p)
    (&right! self (&left q))
    (&left! q self)
    q))

(class Splay ()
  top sentinel cmp)

(method Splay .init (cmp)
  (let (node (.new SplayNode))
    (&top! self node)
    (&sentinel! self node)
    (&cmp! self cmp)))

(method Splay .balance (key)
  (let (top (&top self) sentinel (&sentinel self) cmp (&cmp self) p top q nil d nil)
    (&key! sentinel key)
    (&left! sentinel sentinel)
    (&right! sentinel sentinel)
    (while (/= (<- d (cmp (&key p) key)) 0)
      (if (< d 0)
          (begin (<- q (&left p))
                 (if (= (<- d (cmp (&key q) key)) 0)
                     (begin (<- p (.rotl p)) (break))
                     (<- p (if (< d 0) (.rotll p) (.rotlr p)))))
          (begin (<- q (&right p))
                 (if (= (<- d (cmp (&key q) key)) 0)
                     (begin (<- p (.rotr p)) (break))
                     (<- p (if (> d 0) (.rotrr p) (.rotrl p)))))))
    (&top! self p)
    p))

(method Splay .resume ()
  (let (top (&top self) left (&left top) right (&right top) sentinel (&sentinel self))
    (if (eq? left sentinel) (&top! self right)
        (eq? right sentinel) (&top! self left)
        (let (p left)
          (while (neq? (&right p) sentinel)
            (<- p (&right p)))
          (&right! p right)
          (&top! self left))))
  nil)

(method Splay .get (key)
  (let (top (.balance self key) sentinel (&sentinel self))
    (if (eq? top sentinel) (.resume self)
        (&val top))))

(method Splay .put (key val)
  (let (top (.balance self key) sentinel (&sentinel self))
    (if (eq? top sentinel)
        (&top! self (.init (.new SplayNode)
                            :key key
                            :val val
                            :left (&left sentinel)
                            :right (&right sentinel)))
        (&val<- top val))
    self))

(function! main (args)
  (let (splay (.init (.new Splay) symcmp))
    (.put (.put (.put splay :one 1) :two 2) :three 3)
    (assert (= (.get splay :one) 1))
    (assert (= (.get splay :one) 1))
    (assert (= (.get splay :two) 2))
    (assert (= (.get splay :one) 1))
    (assert (= (.get splay :two) 2))
    (assert (= (.get splay :three) 3))
    (assert (nil? (.get splay :four)))))
