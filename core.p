; Paren core library.

; fundamental macro

(macro function (name args :rest body)
  ; Create a lambda function which parameter list the specified args and lambda function body the specified body.
  ; Then, bind a created lambda function with the specified name.
  ; If the specified name is bound, throw IllegalArgumentsException.
  (if (bound? name) (throw (.message (.new IllegalArgumentsException)
                                     "symbol already bound"))
      (cons <- (cons name (cons (cons lambda (cons args body)) nil)))))

(macro with-gensyms ((:rest syms) :rest body)
  ; Create the new let context which the specified syms bind with symbols which generated by gensyms and under the let context evaluate the specified body.
  ; (with-gensyms (a b c)
  ;   ...)
  ; (let (a (gensym) b (gensym) c (gensym))
  ;   ...)
  (let (rec (lambda (syms :opt acc)
              (if (not syms) acc
                  (cons (car syms) (cons '(gensym) (rec (cdr syms) acc))))))
    (cons let (cons (rec syms) body))))

(macro begin0 (:rest body)
  ; Evaluate each of the specified body and return the first evaluated value.
  ; (begin0 expr1 expr2 ...)
  ; (let (x expr1)
  ;     (begin expr2
  ;             ...)
  ;     x)
  (with-gensyms (val)
    (list let (list val (car body))
          (cons begin (cdr body))
          val)))

(macro when (test :rest body)
  ; Evaluate the specified test and if it is not nil then evaluate each of the specified body.
  (list if test (cons begin body)))

(macro unless (test :rest body)
  ; Evaluate the specified test and if it is nil then evaluate each of the specified body.
  (list if (list nil? test) (cons begin body)))

(macro or (:rest args)
  ; Evaluate each of the specified args, one at a time, from left to right.
  ; The evaluation of all forms terminates when a args evaluates to true.
  ; Return last evaluated value.
  ; If args is nil then return nil.
  (if args (list if (car args) (car args) (cons or (cdr args)))))

(macro and (:rest args)
  ; Evaluate each of the specified args, one at a time, from left to right.
  ; As soon as any form evaluates to nil, and returns nil without evaluating the remaining forms.
  ; If all args but the last evaluate to true values, and returns the results produced by evaluating the last args.
  ; If no args are supplied, returns true.
  (if (nil? args) true
      (let (rec (lambda (l)
                  (if (cdr l) (list if (car l) (rec (cdr l)))
                      (car l))))
        (rec args))))

(macro break ()
  ; The break macro is expected evaluated in the iteration context like a for, while.
  ; Jump to :break label which causes the inner-most loop to be terminated immediately when executed.
  ; If you create new iteration macro, desirable to support it.
  '(goto :break))

(macro continue ()
  ; The continue macro is expected evaluated in the iteration context like a for, while.
  ; Jump to :continue label which will move at once to the next iteration without further progress through the loop body for the current iteration.
  ; If you create new iteration macro, desirable to support it.
  '(goto :continue))

(macro for (binding test update :rest body)
  ; The for macro creates a general-purpose iteration context and evaluates the specified body.
  ; Return nil.
  ; See expanded image for details.
  ; (for (i 0) (< i 10) (<- i (++ i))
  ;     expr1
  ;     expr2
  ;     ...)
  ; (let (i 0)
  ;    (labels :start
  ;            (if (not test) (goto :break))
  ;            expr1
  ;            expr2
  ;            ...
  ;            :continue
  ;            (<- i (++ i))
  ;            (goto :start)
  ;            :break))
  (list let binding
     (cons labels
           (cons :start
           (cons (list if (list not test) '(goto :break))
           (append body
           (cons :continue
           (cons update
           (list '(goto :start)
                 :break)))))))
     nil))

(macro while (test :rest body)
  ; The specified test is evaluated, and if the specified test is true, each of the specified body is evaluated.
  ; This repeats until the test becomes nil.
  ; Supports break, continue macro.
  (cons 'for (cons nil (cons test (cons nil body)))))

(macro dolist ((i l) :rest body)
  ; Iterates over the elements of the specified list l, with index the specified i.
  ; Evaluate each of the specified body once for each element in list l, with index i bound to the element.
  ; Supports break, continue macro.
  (ensure-arguments (symbol? i))
  (with-gensyms (gl)
    (cons for (cons (list gl l i (list car gl))
                    (cons gl
                          (cons (list <- gl (list cdr gl) i (list car gl))
                                body))))))

(macro dotimes ((i n) :rest body)
  ; Iterates over a series of integers, from 0 to the specified n.
  ; The specified body once for each integer from 0 up to but not including the value of n, with the specified i bound to each integer.
  ; Supports break, continue macro.
  (ensure-arguments (symbol? i))
  (with-gensyms (gn)
    (cons for (cons (list i 0 gn n)
                    (cons (list < i gn)
                          (cons (list inc! i)
                                body))))))

(macro measure (:rest body)
  ; 時間計測マクロ
  ; (measure expr1 expr2 ...)
  ; (let (s (clock))
  ;   (begin0 (begin expr1 expr2 ...)
  ;           (- (clock) s))))
  (with-gensyms (s)
    (list let (list s (list clock))
          (list begin0 (cons begin body)
                (list write-string
                      (list string+ "time="
                            (list number->string (list - (list clock) s))))
                (list write-line)))))

; fundamental function

(function list (:rest args)
  ; 引数をリストにして返す。
  args)

(function caar (x)
  ; (car (car x))に等価
  (car (car x)))

(function cadr (x)
  ; (car (cdr x))に等価
  (car (cdr x)))

(function cdar (x)
  ; (cdr (car x))に等価
  (cdr (car x)))

(function cddr (x)
  ; (cdr (cdr x))に等価
  (cdr (cdr x)))

(function caaar (x)
  ; (car (caar x))に等価
  (car (caar x)))

(function caadr (x)
  ; (car (cadr x))に等価
  (car (cadr x)))

(function cadar (x)
  ; (car (cdar x))に等価
  (car (cdar x)))

(function caddr (x)
  ; (car (cddr x))に等価
  (car (cddr x)))

(function cdaar (x)
  ; (cdr (caar x))に等価
  (cdr (caar x)))

(function cdadr (x)
  ; (cdr (cadr x))に等価
  (cdr (cadr x)))

(function cddar (x)
  ; (cdr (cdar x))に等価
  (cdr (cdar x)))

(function cdddr (x)
  ; (cdr (cddr x))に等価
  (cdr (cddr x)))

(function caaaar (x)
  ; (car (caaar x))に等価
  (car (caaar x)))

(function caaadr (x)
  ; (car (caadr x))に等価
  (car (caadr x)))

(function caadar (x)
  ; (car (cadar x))に等価
  (car (cadar x)))

(function caaddr (x)
  ; (car (caddr x))に等価
  (car (caddr x)))

(function cadaar (x)
  ; (car (cdaar x))に等価
  (car (cdaar x)))

(function cadadr (x)
  ; (car (cdadr x))に等価
  (car (cdadr x)))

(function caddar (x)
  ; (car (cddar x))に等価
  (car (cddar x)))

(function cadddr (x)
  ; (car (cdddr x))に等価
  (car (cdddr x)))

(function cdaaar (x)
  ; (cdr (caaar x))に等価
  (cdr (caaar x)))

(function cdaadr (x)
  ; (cdr (caadr x))に等価
  (cdr (caadr x)))

(function cdadar (x)
  ; (cdr (cadar x))に等価
  (cdr (cadar x)))

(function cdaddr (x)
  ; (cdr (caddr x))に等価
  (cdr (caddr x)))

(function cddaar (x)
  ; (cdr (cdaar x))に等価
  (cdr (cdaar x)))

(function cddadr (x)
  ; (cdr (cdadr x))に等価
  (cdr (cdadr x)))

(function cdddar (x)
  ; (cdr (cddar x))に等価
  (cdr (cddar x)))

(function cddddr (x)
  ; (cdr (cdddr x))に等価
  (cdr (cdddr x)))

(function identity (x)
  ; xを返す。恒等関数。
  x)

(function ensure-arguments (test)
  (if (not test) (basic-throw (.new IllegalArgumentsException))))

(function different? (x y)
  ; 式(not (same? x y))に等価。
  (not (same? x y)))

(function nil? (x)
  ; 式(not x)に等価。
  (not x))

(function atom? (x)
  ; xがアトムの場合はtrueを、そうでなければnilを返す。
  (not (cons? x)))

(function list? (x)
  ; xがコンスまたはnilの場合はtrueを、そうでなければnilを返す。
  (or (nil? x) (cons? x)))

(function byte? (x)
  ; xが0から255の整数の場合はtrueを、そうでなければnilを返す。
  (and (integer? x ) (<= 0 x 255)))

(function ->list (x)
  ; xがリストの場合にxを、そうでなければxをリストにして返す。
  (if (list? x) x (list x)))

(function nth (l n)
  ; リストlのn番目の要素を返す。
  ; ただし、nは零から数える。
  ; nがlの長さよりも大きい場合はnilを返す。
  (ensure-arguments (list? l))
  (car (nthcdr l n)))

(function nthcdr (l n)
  ; リストlを構成するn番目のコンスを取得する。
  ; nがlの長さよりも大きい場合はnilを返す。
  (ensure-arguments (and (list? l) (not (minus? n))))
  (if (nil? l) nil
      (= n 0) l
      :default (nthcdr (cdr l) (-- n))))

(function list= (x y :key (test same?))
  ; listの要素がすべて関数testでtrueを返す場合はtrueを、そうでなければnilを返す。
  (ensure-arguments (and (list? x) (list? y)))
  (let (rec (lambda (x y)
              (if (and (nil? x) (nil? y)) true
                  (or (nil? x) (nil? y)) nil
                  (and (test (car x) (car y))
                       (rec (cdr x) (cdr y))))))
    (rec x y)))

(function length (l)
  ; リストlの要素数を返す。
  (ensure-arguments (list? l))
  (let (rec (lambda (l)
              (if (nil? l) 0
                  (+ 1 (rec (cdr l))))))
    (rec l)))

(function sublist (l s :opt e)
  ; リストlのs番目からe - 1番目までを要素に持つ部分リストを返す。
  ; sが零未満、eがリストの長さ以上、sがeより大きい場合はエラーと見做す。
  ; 部分リストはlとは別に作成される。
  (let (len (length l)
        e (or e len)
        rec (lambda (l n)
              (if (= n 0) nil
                  (cons (car l) (rec (cdr l) (-- n))))))
    (ensure-arguments (and (>= s 0) (<= s e) (<= e len)))
    (rec (nthcdr l s) (- e s))))

(function copy-list (l)
  ; リストlの複製を作成して返す。
  ; ただし、要素は複製されない。
  (ensure-arguments (list? l))
  (if (nil? l) nil
      (sublist l 0 (length l))))

(function last-cons (l)
  ; リストlを構成する最後のコンスを返す。
  (ensure-arguments (list? l))
  (if (nil? l) nil
      (let (rec (lambda (l) (if (cdr l) (rec (cdr l)) l)))
        (rec l))))

(function last (l)
  ; リストlの最後の要素を返す。
  (ensure-arguments (list? l))
  (car (last-cons l)))

(function butlast (l)
  ; リストlの最後の要素を除いたリストを返す。
  (ensure-arguments (list? l))
  (let (rec (lambda (l)
              (if (nil? (cdr l)) nil
                  (cons (car l) (rec (cdr l))))))
    (rec l)))

(function .. (s e :opt (step 1))
  ; 整数sから整数eまでstep刻みの要素を持つリストを返す。
  (ensure-arguments (and (number? s) (number? e) (number? step) (/= step 0)
                         (or (and (< step 0) (>= s e))
                             (and (> step 0) (<= s e)))))
  (let (acc nil test (if (> step 0) <= >=))
    (while (test s e)
      (push! acc s)
      (<- s (+ s step)))
    (reverse acc)))

(function append-atom (l x)
  ; リストlの末尾にxを追加したような新たなリストを返す。
  (ensure-arguments (list? l))
  (let (rec (lambda (l)
              (if l (cons (car l) (rec (cdr l)))
                  (list x))))
    (rec l)))

(function append (l :rest args)
  ; リストlの要素としてargsの各要素を追加する。
  ; argsの任意の要素はリストでなければならない。
  (ensure-arguments (and (list? l) (all-satisfy? args list?)))
  (reduce args (lambda (acc rest)
                 (reduce rest append-atom :identity acc))
          :identity l))

(macro push! (sym x)
  ; シンボルsymを束縛しているリストの先頭に破壊的にxを追加する。
  ; 式としてxを返す。
  (ensure-arguments (symbol? sym))
  (list begin
        (list ensure-arguments (list list? sym))
        (list <- sym (list cons x sym))
        x))

(macro pop! (sym)
  ; シンボルsymを束縛しているリストの先頭を返し、symをリストのcdrで再束縛する。
  (ensure-arguments (symbol? sym))
  (list begin0
        (list car sym)
        (list <- sym (list cdr sym))))

(function flatten (l)
  ; リストlisを構成するすべてのコンスのcar部が要素であるような新しいリストを返す。
  ; 作成されるリストの要素の順は、元のリストのcar優先探索となる。
  (ensure-arguments (list? l))
  (let (acc nil
        rec (lambda (x)
               (if (nil? x) (reverse acc)
                   (atom? x) (begin (push! acc x) acc)
                   (nil? (car x)) (begin (push! acc nil) acc)
                   (begin (rec (car x))) (rec (cdr x)))))
    (rec l)))

(function map (args f)
  ; リストargsの各々の要素を関数fで写像した結果をリストにして返す。
  (ensure-arguments (list? args))
  (if args (cons (f (car args)) (map (cdr args) f))))

(function reverse (l)
  ; リストlの要素を逆の順で持つリストを新たに作成して返す。
  (ensure-arguments (list? l))
  (let (rec (lambda (l acc)
              (if (nil? l) acc
                  (rec (cdr l) (cons (car l) acc)))))
    (rec l nil)))

(function reduce (l f :key (identity nil identity?))
  ; リストlを二変数関数fで畳み込んだ結果を返す。
  ; キーワードパラメターidentityが指定された場合は単位元として使用する。
  (ensure-arguments (list? l))
  (let (rec (lambda (l)
              (if (nil? (cdr l)) (car l)
                  (rec (cons (f (car l) (cadr l)) (cddr l))))))
    (rec (if identity? (cons identity l) l))))

(function find-cons (l e :key (test same?) (key identity))
  ; リストlをなすコンスのうち、car部がeに等しいコンスを返す。
  ; 探索はリストの先頭から順に行われる。
  ; 該当するコンスが存在しない場合はnilを返す。
  ; 比較は=で行われ、testで指定された場合はそれを用いる。
  ; keyが指定された場合は要素をkey関数で評価した後に比較を行う。
  (ensure-arguments (list? l))
  (if (nil? l) nil
      (test (key (car l)) e) l
      (find-cons (cdr l) e :test test :key key)))

(function find-cons-if (l f :key (key identity))
  ; リストlをなすコンスのうち、car部が関数fの引数として評価されたときにnilとならないものを返す。
  ; 探索はリストの先頭から順に行われる。
  ; 該当するコンスが存在しない場合はnilを返す。
  ; keyが指定された場合はcar部をkey関数で評価した後に比較を行う。
  (ensure-arguments (list? l))
  (if (nil? l) nil
      (f (key (car l))) l
      (find-cons-if (cdr l) f :key key)))

(function find (l e :key (test same?) (key identity))
  ; リストlの先頭からeに等しい要素を返す。
  ; eが存在しない場合はnilを返す。
  ; 比較は=で行われ、testで指定された場合はそれを用いる。
  ; keyが指定された場合は要素をkey関数で評価した後に比較を行う。
  (ensure-arguments (list? l))
  (car (find-cons l e :test test :key key)))

(function find-if (l f :key (key identity))
  ; リストlの先頭から関数fがnilを返さない最初の要素を返す。
  ; 該当する要素が存在しない場合はnilを返す。
  ; keyが指定された場合は要素をkey関数で評価した後に比較を行う。
  (ensure-arguments (list? l))
  (car (find-cons-if l f :key key)))

(function all-satisfy? (l f)
  ; リストlのすべての要素が関数fの引数として評価したときに、nilでない値を返す場合にtrueを返す。
  ; そうでなければnilを返す。
  (ensure-arguments (and (list? l) (operator? f)))
  (if (nil? l) true
      (and (f (car l)) (all-satisfy? (cdr l) f))))

(function any-satisfy? (l f)
  ; リストlのいずれかの要素が関数fの引数として評価したときにnil以外の値を返す場合はtrueを返す。
  ; そうでなければnilを返す。
  ; なお、lが空の場合はnilを返す。
  (ensure-arguments (and (list? l) (operator? f)))
  (if l (or (f (car l)) (any-satisfy? (cdr l) f))))

(function adjacent-satisfy? (l f)
  ; リストの隣接するすべての二要素に対して二変数関数fの評価がnil以外の場合は
  (ensure-arguments (and (list? l) (operator? f)))
  (if (nil? (cdr l)) true
      (and (f (car l) (cadr l)) (adjacent-satisfy? (cdr l) f))))

; associated list
;; Parenでは、キーワードと任意のS式の対を保持するリストを連想リストという。
;; 探索は線形時間必要になるが、比較はアドレスで行われるため高速。
;; 任意のオブジェクトの対応を保持する場合はMapクラスを利用する。

(function . (al k :opt (v nil v?))
  ; 連想リストalのキー値kに対応する値を返す。
  ; 値がない場合は例外を発生させる。
  ; vが指定された場合はkに対応する値をvで上書きする。
  (ensure-arguments (list? al))
  (let (rec (lambda (rest)
              (if (nil? rest) (throw (.message (.new IllegalStateException)
                                               (string+ "property "
                                                        (symbol->string k)
                                                        " not found")))
                  (same? (car rest) k) rest
                  (rec (cddr rest))))
        pair (rec al))
    (if (nil? v?) (cadr pair)
        (car! (cdr pair) v))))

; char

(function char-space? (c)
  (ensure-arguments (byte? c))
  (find '(0x09 0x0A 0x0D 0x20) c :test =))

(function char-alpha? (c)
  (ensure-arguments (byte? c))
  (or (<= 0x41 c 0x5A) (<= 0x61 c 0x7A)))

(function char-digit? (c)
  (ensure-arguments (byte? c))
  (<= 0x30 c 0x39))

(function char-lower (c)
  (ensure-arguments (byte? c))
  (if (<= 0x41 c 0x5A) (+ c 0x20)
      c))

(function char-upper (c)
  (ensure-arguments (byte? c))
  (if (<= 0x61 c 0x7A) (- c 0x20)
      c))

(function char->digit (c :key (radix 10))
  (ensure-arguments (byte? c))
  (let (n (if (char-digit? c) (- c 0x30)
              (char-alpha? c) (+ (- (char-lower c) 0x61) 10)))
    (if (and n (< n radix)) n
        (throw (.message (.new IllegalStateException)
                         "illegal char")))))

; number

(function - (x :rest args)
  ; xからargsの合計を引いた値を返す。
  ; argsがnilの場合はxを負にした値を返す。
  (ensure-arguments (and (number? x) (all-satisfy? args number?)))
  (if (nil? args) (negated x)
      (+ x (negated (reduce args +)))))

(function negated (x)
  ; xの符号を反転させた値を返す。
  (* x -1))

(function // (x y)
  ; 切り捨て除算
  ; xをyで除算した結果の整数部を返す。
  (ensure-arguments (and (number? x) (number? y)))
  (truncate (/ x y)))

(function /= (x y)
  ; 数値x、yを比較した結果を返す。
  (not (= x y)))

(function > (:rest args)
  (adjacent-satisfy? args (lambda (x y) (< y x))))

(function <= (:rest args)
  (adjacent-satisfy? args (lambda (x y) (not (< y x)))))

(function >= (:rest args)
  (adjacent-satisfy? args (lambda (x y) (not (< x y)))))

(function ++ (x)
  ; Returns the value of x + 1.
  (ensure-arguments (number? x))
  (+ x 1))

(function -- (x)
  ; Returns the value of x - 1.
  (ensure-arguments (number? x))
  (- x 1))

(macro inc! (s :opt (v 1))
  ; sの値にvを加えた値をsに束縛する式に展開する。
  (ensure-arguments (symbol? s))
  (list <- s (list '+ s v)))

(macro dec! (s :opt (v 1))
  ; sの値からvを引いた値をsに束縛する式に展開する。
  (ensure-arguments (symbol? s))
  (list <- s (list '- s v)))

(function even? (x)
  ; xが偶数の場合にtrueを、そうでなければnilを返す。
  (= (mod x 2) 0))

(function odd? (x)
  ; xが奇数の場合にtrueを、そうでなければnilを返す。
  (not (even? x)))

(function plus? (x)
  ; xが正の数の場合にtrueを、そうでなければnilを返す。
  (ensure-arguments (number? x))
  (> x 0))

(function zero? (x)
  ; xが0の場合はtrueを、そうでなければnilを返す。
  (ensure-arguments (number? x))
  (= x 0))

(function minus? (x)
  ; xが負の数の場合はtrueを、そうでなければnilを返す。
  (ensure-arguments (number? x))
  (< x 0))

; splay tree

;; End node of splay.
(<- $splay-nil '(nil nil nil nil))

;; splay ::= (top comparator)

(function splay-new (comparator)
  (list $splay-nil comparator))

(function splay-top (splay)
  (car splay))

(function splay-top! (splay top)
  (car! splay top))

(function splay-comparator (splay)
  (cadr splay))

;; splay node ::= (k v left right)

(function splay-node-new (k v)
  (list k v nil nil))

(function splay-node-key (splay-node)
  (car splay-node))

(function splay-node-key! (splay-node key)
  (car! splay-node key))

(function splay-node-val (splay-node)
  (cadr splay-node))

(function splay-node-left (splay-node)
  (caddr splay-node))

(function splay-node-left! (splay-node val)
  (car! (cddr splay-node) val))

(function splay-node-right (splay-node)
  (cadddr splay-node))

(function splay-node-right! (splay-node val)
  (car! (cdddr splay-node) val))

(function splay-balance (splay k)
  (let (top (splay-top splay) cmp (splay-comparator splay) p nil q nil d 0)
    (splay-node-key! $splay-nil k)
    (splay-node-left! $splay-nil $splay-nil)
    (splay-node-right! $splay-nil $splay-nil)
    (while (/= (<- d (cmp k (splay-node-key top))) 0)
      (<- p top)
      (if (< d 0)
          (begin
            (<- q (splay-node-left p))
            (if (= (<- d (cmp k (splay-node-key q))) 0)
                (begin
                  (<- top q)
                  (splay-node-left! p (splay-node-right top))
                  (splay-node-right! top p)
                  (break))
                (< d 0)
                (begin
                  (<- top (splay-node-left q))
                  (splay-node-left! q (splay-node-right top))
                  (splay-node-right! top p))
                (begin
                  (<- top (splay-node-right q))
                  (splay-node-right! q (splay-node-left top))
                  (splay-node-left! top q)
                  (splay-node-left! p (splay-node-right top))
                  (splay-node-right! top p))))
          (begin
            (<- q (splay-node-right p))
            (if (= (<- d (cmp k (splay-node-key q))) 0)
                (begin
                  (<- top q)
                  (splay-node-right! p (splay-node-left top))
                  (splay-node-left! top p)
                  (break))
                (> d 0)
                (begin
                  (<- top (splay-node-right q))
                  (splay-node-right! q (splay-node-left top))
                  (splay-node-left! top p))
                (begin
                  (<- top (splay-node-left q))
                  (splay-node-left! q (splay-node-right top))
                  (splay-node-right! top q)
                  (splay-node-right! p (splay-node-left top))
                  (splay-node-left! top p))))))
    top))

(function splay-resume (top)
  (let (l (splay-node-left top) r (splay-node-right top) p nil)
    (if (same? l $splay-nil) (return r)
        (different? r $splay-nil)
        (begin (<- p l)
               (while (different? (splay-node-right p) $splay-nil)
                 (<- p (splay-node-right p)))
               (splay-node-right! p r)))
    l))

(function splay-add (splay k v)
  ; Associates the specified v with the specified k in the specified splay.
  ; Returns the v.
  (let (top (splay-balance splay k))
    (assert (same? top $splay-nil))
    (<- top (splay-node-new k v))
    (splay-node-left! top (splay-node-left $splay-nil))
    (splay-node-right! top (splay-node-right $splay-nil))
    (splay-top! splay top)
    v))

(function splay-find (splay k)
  ; Returns the value to which the specified k is associated in the specified splay.
  ; If not found, return nil.
  (let (top (splay-balance splay k))
    (if (same? top $splay-nil) (begin (splay-top! splay (splay-resume top))
                                      nil)
        (begin (splay-top! splay top)
               (splay-node-val top)))))

; Paren object system

(<- $class nil
    $class-cache (splay-new
                   (lambda (k1 k2)
                     (let (d (- (address k1) (address k2)))
                       (if (= d 0) 0 (> d 0) 1 -1))))
    $method-cache (splay-new
                    (lambda (k1 k2)
                      (let (d (- (+ (* (address (car k1)) 10)
                                    (address (cadr k1)))
                                 (+ (* (address (car k2)) 10)
                                    (address (cadr k2)))))
                        (if (= d 0) 0 (> d 0) 1 -1)))))

(function class-exists? (cls-sym)
  (find $class cls-sym))

(function find-class (cls-sym)
  (ensure-arguments (and (symbol? cls-sym) (class-exists? cls-sym)))
  (let (cls nil)
    (if (<- cls (splay-find $class-cache cls-sym)) cls
        (begin (<- cls (. $class cls-sym))
               (splay-add $class-cache cls-sym cls)))))

(function find-method (cls-sym method-sym)
  (ensure-arguments (and (symbol? cls-sym) (symbol? method-sym)))
  (let (key (list cls-sym method-sym)
        m nil
        find-class-method
            (lambda (cls)
              (cadr (find-cons (car (nthcdr cls 11)) method-sym)))    ; <=> (.cls :methods)
        find-feature-method
            (lambda (features)
              (and features
                   (or (find-class-method (find-class (car features)))
                       (find-feature-method (cdr features)))))
        rec
            (lambda (cls)
              (or (find-class-method cls)
                  (find-feature-method (car (nthcdr cls 7)))    ; <=> (. cls :features)
                  (let (super (car (nthcdr cls 5)))    ; <=> (. cls :super)
                    (and super (rec (find-class super)))))))
    (if (<- m (splay-find $method-cache key)) m
        (<- m (rec (find-class cls-sym))) (splay-add $method-cache key m)
        (throw (.message (.new IllegalStateException)
                         (string+ "method " (symbol->string method-sym)
                                  " not found"))))))

(macro make-accessor (cls-sym var)
  (with-gensyms (val val?)
    (list method cls-sym (string->symbol (string+ "&" (symbol->string var)))
          (list :opt (list val nil val?))
          (list if val?
                (list begin
                      (list '. 'self (symbol->keyword var) val)
                      'self)
                (list '. 'self (symbol->keyword var))))))

(macro make-method-dispatcher (method-sym)
  (with-gensyms (receiver args)
    (list function method-sym (list receiver :rest args)
          :method
          (list ensure-arguments (list object? receiver))
          (list 'apply
                (list 'find-method
                      (list '. receiver :class)
                      (list quote method-sym))
                (list 'cons receiver args)))))

(function method? (o)
  (and (lambda? o)
       (same? (car (lambda-body o)) :method)))

(macro class (cls-sym (:opt (super 'Object) :rest features) :rest fields)
  (let (Object? (same? cls-sym 'Object))
    (ensure-arguments (and (all-satisfy? fields symbol?)
                           (not (class-exists? cls-sym))))
    (append
      (list begin0
            (list quote cls-sym)
            (list <- cls-sym (list quote (list :class 'Class
                                               :symbol cls-sym
                                               :super (if (not Object?) super)
                                               :features features
                                               :fields fields
                                               :methods nil)))
            (list 'push! '$class cls-sym)
            (list 'push! '$class (list quote cls-sym)))
      (map fields (lambda (var) (list 'make-accessor cls-sym var))))))

(macro method (cls-sym method-sym args :rest body)
  (ensure-arguments (and (class-exists? cls-sym)
                         (not (and (bound? method-sym)
                                   (not (method? (eval method-sym)))))))
  (list begin
        (if (not (bound? method-sym))
            (list make-method-dispatcher method-sym))
        (list . cls-sym :methods
              (list cons (list quote method-sym)
                    (list cons (cons lambda (cons (cons 'self args) body))
                          (list '. cls-sym :methods))))))

(macro throw (o)
  (with-gensyms (e)
    (list let (list e o)
          (list ensure-arguments (list and
                                       (list object? e)
                                       (list is-a? e 'Throwable)))
          (list basic-throw o))))

(macro catch ((:rest handlers) :rest body)
  ; (catch ((Exception1 (e) ...)
  ;         (Exception2 (e) ...)
  ;         (Exception3 (e) ...))
  ;   ...)
  ; (basic-catch (lambda (gsym)
  ;                (ensure-arguments (and (object? gsym) (is-a? Throwable)))
  ;                (if (is-a gsym Exception1) (apply (lambda (e) ...) gsym)
  ;                    (is-a gsym Exception2) (apply (lambda (e) ...) gsym)
  ;                    (is-a gsym Exception3) (apply (lambda (e) ...) gsym)
  ;                    (throw gsym)))
  ;              ...)
  (with-gensyms (gargs)
    (let (if-clause nil)
      (push! if-clause if)
      (dolist (h handlers)
        (push! if-clause (list 'is-a? gargs (car h)))
        (push! if-clause (list apply (cons lambda (cons (cadr h) (cddr h)))
                               (list 'list gargs))))
      (push! if-clause (list throw gargs))
      (cons basic-catch
            (cons (list lambda (list gargs)
                        (list begin
                              (list ensure-arguments
                                    (list and
                                          (list object? gargs)
                                          (list is-a? gargs 'Throwable)))
                              (reverse if-clause)))
                  body)))))

(function object? (x)
  ; xがオブジェクトの場合trueを、そうでなければnilを返す。
  ; Paren object systemでは先頭要素がキーワード:classで始まるような連想リストをオブジェクトと見做す。
  (and (list? x) (same? (car x) :class)))

(function is-a? (o cls)
  ; oがclsクラスのインスタンスの場合trueを、そうでなければnilを返す。
  (ensure-arguments (and (object? o) (object? cls) (same? (cadr cls) 'Class)))
  (let (cls-sym (. cls :symbol)
                rec (lambda (o-cls-sym)
                      (and o-cls-sym
                           (or (same? o-cls-sym cls-sym)
                               (rec (. (find-class o-cls-sym) :super))))))
    (rec (. o :class))))

(class Object ()
  ; 唯一スーパークラスを持たない、クラス階層の最上位クラス。
  ; スーパークラスを指定しない場合は暗黙的にObjectクラスを継承する。
  class)

(method Object .init ()
  ; オブジェクトの初期化メソッド。
  ; 引数なしの場合は、オブジェクト生成時に自動で初期化される。
  ; クラスごとに必要に応じて固有の初期化処理を上書きする。
  self)

(method Object .class ()
  ; 自身のクラスを返す。
  (find-class (&class self)))

(method Object .equal? (o)
  ; レシーバとoが同一オブジェクトの場合にtrueを、そうでなければnilを返す。
  ; サブクラスで同等性を定義する場合はこのメソッドをオーバーロードする。
  (same? self o))

(method Object .toString ()
  ; レシーバの印字表現を返す。
  "<object>")

(class Class ()
  symbol super features fields methods)

(method Class .new ()
  (let (o nil cls self fields nil)
    (while cls
      (<- fields (reverse (map (. cls :fields) symbol->keyword)))
      (while fields
        (push! o (if (same? (car fields) :class) (. self :symbol)))
        (push! o (car fields))
        (<- fields (cdr fields)))
      (<- cls (and (. cls :super) (find-class (. cls :super)))))
    (if (list= (lambda-parameter (find-method (. o :class) '.init)) '(self))
        (.init o)
        o)))

(method Class .super ()
  ; スーパークラスを返す。
  (find-class (&super self)))

(method Class .features ()
  ; フィーチャーのリストを返す。
  (map (&features self) find-class))

(method Class .methods ()
  ; このクラスのメソッドのリストを返す。
  ; スーパークラスや、フィーチャーのメソッドは含まない。
  (&methods self))

;; error, exception

(class Throwable ()
  ; すべてのエラー、例外クラスの基底クラス。
  message)

(method Throwable .message (:opt (message nil message?))
  ; エラーオブジェクトにメッセージを設定する。
  (if message? (&message self message) (&message self)))

(method Throwable .toString ()
  (let (class-name (symbol->string (&class self)) msg (.message self))
    (if msg (string+ class-name " -- " msg)
        class-name)))

(class Error (Throwable)
  ; エラークラス。
  ; 継続が困難な状態や、到達すべきでない状態を表す。
  ; throwされた場合は、原則としてcatchオペレーターで補足すべきではない。
  )

(function Error.shouldBeImplemented ()
  (throw (.message (.new Error) "should be implemented")))

(class QuitSignal (Error)
  ; システム終了シグナル
  )

(function quit ()
  (throw (.new QuitSignal)))

(class Exception (Throwable)
  ; 例外クラス。
  ; すべての例外クラスはこのクラスを継承する。
  ; 補足すべきでない例外を表す場合はErrorクラスを継承すること。
  )

(method Exception .addMessage (msg)
  (ensure-arguments (string? msg))
  (.message self (+ (.message self) msg)))

(class IllegalArgumentsException (Exception)
  ; 引数が不正な場合にスローされる例外
  )

(class IllegalStateException (Exception)
  ; 状態が不正な場合にスローされる例外
  )

;; stream I/O

(class Stream ()
  ;ストリームクラス。入出力の基本的なメソッドを持つ。
  )

(method Stream .readByte (:rest args)
  ; ストリームの終端に達した場合は1を返す。
  (Error.shouldBeImplemented))

(method Stream .writeByte (:rest args)
  (Error.shouldBeImplemented))

(method Stream .readChar ()
  ; ストリームから1byte読み込む。
  ; ストリームの終端に達した場合は:EOFを返す。
  (if (same? (dynamic $encoding) :UTF-8)
          (let (utf8-exception
                   (lambda ()
                     (throw (.message (.new IllegalStateException)
                                      "illegal UTF-8")))
                trail? (lambda (b) (= (bit-and b 0xc0) 0x80))
                ms (.new MemoryStream)
                b1 (.readByte self) b2 nil b3 nil b4 nil)
            (if (< b1 0) (return :EOF)
                (< b1 0x80) (.writeByte ms b1)
                (< b1 0xc2) (utf8-exception)
                (not (trail? (<- b2 (.readByte self)))) (utf8-exception)
                (< b1 0xe0) (begin (if (= (bit-and b1 0x3e) 0) (utf8-exception))
                                   (.writeByte (.writeByte ms b1) b2))
                (< b1 0xf0) (begin (<- b3 (.readByte self))
                                   (if (or (and (= b1 0xe0)
                                                (= (bit-and b2 0x20) 0))
                                           (not (trail? b3)))
                                       (utf8-exception))
                                   (.writeByte
                                     (.writeByte
                                       (.writeByte ms b1) b2) b3))
                (< b1 0xf8) (begin (<- b3 (.readByte self) b4 (.readByte self))
                                   (if (or (not (trail? b3))
                                           (not (trail? b4))
                                           (and (= b1 0xf0)
                                                (= (bit-and b2 0x30) 0)))
                                       (utf8-exception))
                                   (.writeByte
                                     (.writeByte
                                       (.writeByte
                                         (.writeByte ms b1) b2) b3) b4))
                (utf8-exception))
            (.toString ms))
          (throw (.message (.new IllegalStateException) "unsupport encoding"))))

(method Stream .readLine (:rest args)
  (Error.shouldBeImplemented))

(method Stream .writeString (s)
  (ensure-arguments (string? s))
  (let (ba (string->byte-array s))
    (dotimes (i (byte-array-length ba))
      (.writeByte self ([] ba i))))
  self)

(method Stream .seek (:rest args)
  (Error.shouldBeImplemented))

(method Stream .tell (:rest args)
  (Error.shouldBeImplemented))

(class MemoryStream (Stream)
  ; メモリ上に内容を保持するストリームクラス。
  buf buf-size rdpos wrpos)

(method MemoryStream .init ()
  (let (buf-size 256)
    (&buf-size self buf-size)
    (&buf self (byte-array buf-size))
    (&rdpos self 0)
    (&wrpos self 0))
  self)

(method MemoryStream _extend (size)
  (ensure-arguments (integer? size))
  (let (req (+ (&wrpos self) size) new-buf nil)
    (while (< (&buf-size self) req)
      (&buf-size self (* (&buf-size self) 2)))
    (<- new-buf (byte-array (&buf-size self)))
    (array-copy (&buf self) 0 new-buf 0  (&wrpos self))
    (&buf self new-buf))
  self)

(method MemoryStream .writeByte (byte)
  (ensure-arguments (byte? byte))
  (let (pos (&wrpos self))
    (if (< pos (&buf-size self))
        (begin ([] (&buf self) pos byte)
               (&wrpos self (++ pos)))
        (.writeByte (_extend self 1) byte)))
  self)

(method MemoryStream .readByte ()
  (let (pos (&rdpos self))
    (if (>= pos (&wrpos self)) -1
        (begin0 ([] (&buf self) pos)
                (&rdpos self (++ pos))))))

(method MemoryStream .seek (offset)
  (ensure-arguments (<= 0 offset (&wrpos self)))
  (&rdpos self offset))

(method MemoryStream .tell (offset)
  (&rdpos self))

(method MemoryStream .toString ()
  (let (pos (&wrpos self) str (byte-array pos))
    (if (= pos 0) ""
        (byte-array->string (array-copy (&buf self) 0 str 0 pos)))))

(method MemoryStream .reset ()
  (&rdpos self 0)
  (&wrpos self 0))

(class FileStream (Stream)
  ; ファイルストリームクラス
  fp)

(method FileStream .init (:key fp)
  (ensure-arguments fp)
  (&fp self fp))

(method FileStream .readByte ()
  (fgetc (&fp self)))

(method FileStream .readLine ()
  (fgets (&fp self)))

(method FileStream .writeByte (byte)
  (ensure-arguments (byte? byte))
  (fputc byte (&fp self)))

(method FileStream .seek (offset)
  (fseek (&fp self) offset))

(method FileStream .tell ()
  (ftell (&fp self)))

(method FileStream .close ()
  (fclose (&fp self)))

(class Path ()
  ; イミュータブルなファイルパスクラス。
  files mode)

(method Path .init (:rest files)
  ; このパスを構成するファイルのリストを渡して初期化を行う。
  (&files self files)
  self)

(method Path _reset ()
  (&mode self nil)
  self)

(method Path .parent ()
  ; このパスの親のパス
  (&files (.init (.new Path)) (butlast (&files self))))

(method Path .child (:rest body)
  (ensure-arguments (all-satisfy? body string?))
  ; このパスの下にパスを結合する。
  (&files (.new Path) (append (&files self) body)))

(method Path .toString ()
  (reduce (&files self) (lambda (acc rest) (string+ acc "/" rest))))

(method Path .open (mode)
  ; このパスの表すファイルを指定したモードでオープンし、FileStreamクラスのインスタンスを返す。
  (.init (.new FileStream) :fp (fopen (.toString self) mode)))

(method Path .openRead ()
  (.open self 0))

(method Path .openWrite ()
  (.open self 1))

(method Path .openAppend ()
  (.open self 2))

(method Path .openUpdate ()
  (.open self 3))

(class ByteAheadReader ()
  ; 先読みリーダー。
  ; 文字列やストリームから1byte先読みを行う機能を提供するクラス。
  stream next buf)

(method ByteAheadReader .init (:key string (stream (dynamic $stdin)))
  ; 文字列または、ストリームのいずれかを用いてレシーバを初期化する。
  (ensure-arguments (and (or (nil? string) (string? string))
                         (object? stream) (is-a? stream Stream)))
  (when string
    (<- stream (.new MemoryStream))
    (.writeString stream string))
  (&stream self stream)
  (&next self (.readByte stream))
  (&buf self (.new MemoryStream))
  self)

(method ByteAheadReader .next ()
  (&next self))

(method ByteAheadReader .eof? ()
  ; ストリームが終端に達している場合にtrueを、そうでなければnilを返す。
  (= (&next self) -1))

(method ByteAheadReader _ensureNotEOFReached ()
  ; ストリームが終端に達していた場合は例外をスローする。
  (if (.eof? self) (throw (.message (.new IllegalStateException)
                                    "EOF reached"))))

(method ByteAheadReader .skip ()
  ; 次の1byte読み飛ばし、返す。
  (_ensureNotEOFReached self)
  (begin0 (&next self)
          (&next self (.readByte (&stream self)))))

(method ByteAheadReader .get ()
  ; 次の1byteをトークンの末尾に追加し、返す。
  (let (c (.skip self))
    (.put self c)
    c))

(method ByteAheadReader .put (b)
  ; ストリームとは無関係にトークンの末尾に1byte追加する。
  (ensure-arguments (byte? b))
  (.writeByte (&buf self) b))

(method ByteAheadReader .token ()
  ; 現在切り出しているbyte列を文字列にして返す。
  (.toString (&buf self)))

(method ByteAheadReader .reset ()
  ; 現在切り出しているトークン文字列を返す。
  (.reset (&buf self))
  self)

(method ByteAheadReader .skipSpace ()
  ; スペース、改行文字を読み飛ばし、レシーバを返す。
  (while (and (not (.eof? self)) (char-space? (&next self)))
    (.skip self))
  self)

(class AheadReader (ByteAheadReader)
  ; 先読みリーダー。
  ; 文字列やストリームから1文字先読みを行う機能を提供するクラス。
  )

(method AheadReader .init (:key string stream)
  ; 文字列または、ストリームのいずれかを用いてレシーバを初期化する。
  (ensure-arguments (or (and string (string? string))
                        (and (object? stream) (is-a? stream Stream))))
  (when string
    (<- stream (.new MemoryStream))
    (.writeString stream string))
  (&stream self stream)
  (&next self (.readChar stream))
  (&buf self (.new MemoryStream))
  self)

(method AheadReader .eof? ()
  ; ストリームが終端に達している場合にtrueを、そうでなければnilを返す。
  (same? (&next self) :EOF))

(method AheadReader .skip ()
  ; 次の1文字を読み飛ばし、返す。
  (_ensureNotEOFReached self)
  (begin0 (&next self)
          (&next self (.readChar (&stream self)))))

(method AheadReader .put (s)
  ; ストリームとは無関係にトークンの末尾に文字列sを追加する。
  (ensure-arguments (string? s))
  (.writeString (&buf self) s))

(method AheadReader .skipSpace ()
  ; スペース、改行文字を読み飛ばし、レシーバを返す。
  (while (and (not (.eof? self))
              (find '(" " "\r" "\n") (&next self) :test string=))
    (.skip self))
  self)

; Paren reader

(class ParenLexer (ByteAheadReader)
  ; Paren字句解析機
  )

(method ParenLexer _raise (message)
  (throw (.message (.new IllegalStateException) message)))

(method ParenLexer _identifierLead? ()
  (let (c (.next self))
    (or (find '(0x21 0x24 0x25 0x26 0x2A 0x2B 0x2D 0x2F 0x3C 0x3D 0x3E 0x3F
                0x5F 0x2E 0x5B 0x5D)
              c :test =)
        (char-alpha? c))))

(method ParenLexer _identifierTrail? ()
  (or (_identifierLead? self) (char-digit? (.next self))))

(method ParenLexer _getString ()
  (.skip self)
  (while (/= 0x22 (.next self))
    (if (.eof? self) (_raise self "string not closed")
        (/= (.next self) 0x5C) (.get self)
        (begin (.skip self)
               (throw todo))))
  (.skip self)
  (.token self))

(method ParenLexer _getNumber (sign)
  (let (radix 10 factor 0 val 0)
    (while (char-digit? (.next self))
      (<- val (+ (* val 10) (char->digit (.skip self)))))
    (if (= (.next self) 0x78)
        (begin (.skip self)
               (<- radix (if (= val 0) 16 val)
                   val 0)
               (while (or (char-alpha? (.next self)) (char-digit? (.next self)))
                 (<- val (+ (* val radix)
                            (char->digit (.skip self) :radix radix)))))
        (= (.next self) 0x2E)
        (begin (.skip self)
               (<- factor 0.1)
               (while (char-digit? (.next self))
                 (<- val (+ val (* factor (char->digit (.skip self))))
                     factor (/ factor 10)))))
    (if (and (byte? sign) (= sign 0x2D)) (- val) val)))

(method ParenLexer _getKeyword ()
  (.skip self)
  (while (_identifierTrail? self) (.get self))
  (string->keyword (.token self)))

(method ParenLexer _getSymbol ()
  (while (_identifierTrail? self) (.get self))
  (string->symbol (.token self)))

(method ParenLexer .getToken ()
  ; return -- (token-type [token])
  (.reset self)
  (let (sign nil next (.next self) space? (lambda (x)
                                            (and (byte? x)
                                                 (char-space? x))))
    (if (space? next) (begin (while (space? (.next self)) (.skip self))
                             (.getToken self))
        (.eof? self) '(:EOF)
        (= next 0x22) (list :string (_getString self))
        (= next 0x27) (begin (.skip self) '(:quote))
        (= next 0x28) (begin (.skip self) '(:open-paren))
        (= next 0x29) (begin (.skip self) '(:close-paren))
        (= next 0x3A) (list :keyword (_getKeyword self))
        (= next 0x3B) (begin (while (/= (.next self) 0x0A) (.skip self))
                             (.getToken self))
        (begin (if (find '(0x2B 0x2D) next :test =)
                   (<- sign (.skip self)))
               nil) :unreachable
        (char-digit? (.next self)) (list :number (_getNumber self sign))
        (or sign (_identifierLead? self)) (begin
                                            (if sign (.put self sign))
                                            (list :symbol (_getSymbol self)))
        (_raise self (string+ (number->string (.next self)) " illegal char")))))

(class ParenParser ()
  ; Paren構文解析機
  lexer token-type token)

(method ParenParser .init (:key string (stream (dynamic $stdin)))
  (&lexer self (.init (.new ParenLexer) :string string :stream stream))
  self)

(method ParenParser _raise ()
  (throw (.message (.new IllegalStateException) "illegal token")))

(method ParenParser _scan ()
  (let (next (.getToken (&lexer self)))
    (&token-type self (car next))
    (&token self (cadr next))))

(method ParenParser _parseList (:opt expect-close?)
  (_scan self)
  (if (same? (&token-type self) :close-paren) nil
      (cons (_parseS self) (_parseList self))))

(method ParenParser _parseS ()
  (let (type (&token-type self))
    (if (same? type :EOF) :EOF
        (same? type :quote) (list quote (.parse self))
        (same? type :open-paren) (_parseList self)
        (or (same? type :symbol)
            (same? type :keyword)
            (same? type :string)
            (same? type :number)) (&token self)
        (_raise self))))

(method ParenParser .parse ()
  (_scan self)
  (_parseS self))

;; I/O
(<- $stdin (.init (.new FileStream) :fp (fp 0))
    $stdout (.init (.new FileStream) :fp (fp 1))
    $in $stdin
    $out $stdout
    $encoding (if (same? $os :Windows) :CP932 :UTF-8)
    $support-encodings '(:UTF-8 :CP932))

(function read-byte (:opt (stream (dynamic $stdin)))
  ; ストリームから1byte読み込む。
  ; ストリームの終端に達した場合は-1を返す。
  (ensure-arguments (is-a? stream Stream))
  (.readByte stream))

(function read-char (:opt (stream (dynamic $stdin)))
  ; streamから1byte読み込み返す。
  ; ストリームの終端に達した場合は:EOFを返す。
  (ensure-arguments (is-a? stream Stream))
  (.readChar stream))

(function read-line (:opt (stream (dynamic $stdin)))
  ; streamから一行読み込み返す。
  (ensure-arguments (is-a? stream Stream))
  (.readLine stream))

(function write-byte (byte :opt (stream (dynamic $stdout)))
  ; streamに1byte書き込みbyteを返す。
  (ensure-arguments (and (byte? byte) (is-a? stream Stream)))
  (.writeByte stream byte)
  byte)

(function write-line (:opt args (stream $stdout))
  ; streamに改行を書き込む。
  (ensure-arguments (or (nil? args) (string? args)))
  (if args (write-string args stream))
  (write-byte 0x0A stream))

(function write-string (s :opt (stream $stdout))
  ; streamに文字列を書き込みsを返す。
  (ensure-arguments (and (string? s) (is-a? stream Stream)))
  (.writeString stream s)
  s)

(macro with-memory-stream ((s) :rest body)
  (list let (list s (list '.new 'MemoryStream))
        (cons begin body)
        (list '.toString s)))

(function with-open-mode (sym gsym path mode body)
  ; 各種マクロのためのhelper function
  (let (path (list if (list string? path) (list '.init '(.new Path) path)
                   (list and (list 'object? path)
                         (list 'is-a? path 'Path)) path
                   (list ensure-arguments nil)))
    (list let (list gsym nil)
          (list unwind-protect
                (cons let (cons (list sym (list mode path))
                                (cons (list <- gsym sym)
                                      body)))
                (list if gsym (list '.close gsym))))))

(macro with-open-read ((in path) :rest body)
  (with-gensyms (stream)
    (with-open-mode in stream path '.openRead body)))

(macro with-open-write ((out path) :rest body)
  (with-gensyms (stream)
    (with-open-mode out stream path '.openWrite body)))

(macro with-open-append ((out path) :rest body)
  (with-gensyms (stream)
    (with-open-mode out stream path '.openAppend body)))

(macro with-open-update ((out path) :rest body)
  (with-gensyms (stream)
    (with-open-mode out stream path '.openUpdate body)))

(function read (:opt (stream (dynamic $stdin)))
  ; streamからS式を読み込み返す。
  ; 終端に達した場合は:EOFを返す。
  (.parse (.init (.new ParenParser) :stream stream)))

(function xprint (x :opt (stream (dynamic $stdin)))
  (let (print-s-expr (lambda (x)
                       (if (cons? x) (print-cons x)
                           (print-atom x)))
        print-cons (lambda (x)
                     (write-string "(")
                     (print-s-expr (car x))
                     (map (cdr x) (lambda (x) 
                                    (write-string " ")
                                    (print-s-expr x)))
                     (write-string ")"))
        print-operator (lambda (x)
                         (write-string "(")
                         (if (lambda? x) (write-string "lambda")
                             (write-string "macro"))
                         (write-string " ")
                         (print-cons (lambda-parameter x))
                         (map (lambda-body x) (lambda (x)
                                                (write-string " ")
                                                (print-s-expr x)))
                         (write-string ")"))
        print-atom (lambda (x)
                     (if (macro? x) (print-operator x)
                         (lambda? x) (print-operator x)
                         (string? x) (begin (write-string "\"")
                                            (write-string x)
                                            (write-string "\""))
                         (symbol? x) (write-string (symbol->string x))
                         (keyword? x) (write-string (keyword->string x))
                         (number? x) (write-string (number->string x))
                         (throw (.new IllegalStateException)))))
    (print-s-expr x)
    (write-line)
    x))

(function repl ()
  (let (s nil)
    (while true
      (catch ((QuitSignal (e) (break))
              (Exception (e) (write-string (.toString e)))
              (Error (e) (write-string (.toString e))))
        (write-string ") ")
        (if (same? (<- s (read)) :EOF) (break))
        (xprint (eval s))))))

(function load (path)
  (with-open-read (in path)
    (let (expr nil)
      (while true
        (if (same? (<- expr (read in)) :EOF) (break)
            (eval expr))))))

; (let ($encoding :UTF-8)
;   (<- ar (.init (.new AheadReader) :string "あいう"))
;   (print (.get ar))
;   (print (.get ar))
;   (print (.get ar))
;   (print (.token ar)))

; (function fib (x)
;   (if (> x 1) (+ (fib (-- x)) (fib (- x 2)))
;       1))
; (print (map (.. 0 5) fib))

; (<- p (.init (.new Path) "." "test.wk"))
; (with-open-write (out p)
;   (write-line ":hello" out)
;   (write-line ":hello" out)
;   (write-line ":hello" out)
;   (write-line ":hello" out)
;   (write-line ":hello" out)
;   )
; (load "test.wk")

(function boot (args)
  (if (nil? args) (repl)
      (dolist (arg args)
        (load arg))))

(boot $args)
