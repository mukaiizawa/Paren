Parenチュートリアル

# 概要
このチュートリアルはParenの機能を早巡りすることを目的とする。
ParenはS式によって記述される、最古のプログラミング言語Lispの方言である。
ただし、実装されている関数やマクロや、
それらの命名などは相当作者好みのものとなっている。
Parenのコンセプトを示す。
- programmable programming language
- ability to rapidly develop
- runnable on all major platforms 
- easy and simple to learn
- never programming without enjoying

# 目次
- 書式
- 序章
- コメント
- 変数
- 環境
- キーワード
- 数値
- 文字列
- リスト
- 関数
- 条件分岐
- 反復
- 配列
- マップ
- スペシャルオペレーター
- マクロ
- リードマクロ
- 例外処理
- クラス
- 付録

# 書式
チュートリアルを記載するにあたり、書式を次に示すBNFで記載する。
    記号 定義
    ----------------------------------------
    [ ]  []内は省略可能
    { }  {}内から一つ選択
    |    []、{}内の代替候補の区切り文字
    ...  直前の構文を零回以上繰り返す
    ::=  左辺を右辺で定義
    --   左辺の説明

# 序章
この章ではいくつかのプログラムを掲載し、
Parenの雰囲気を知ってもらうことを目的とする。
そのため詳細な説明は割愛してある。
## hello world
プログラミング言語を習得する唯一の方法は、それでプログラムを書くことである。
そしてそれは、慣習により次のプログラムを書くことから始まる。
次の文字列を印字せよ。
    hello world
引数を与えることなしにParenを起動すると、 
repl(read-eval-print-loop)と呼ばれる対話モードで起動される。
    $paren
    ) 
`)`はプロンプトといい、プログラムを入力すると評価されその結果が出力される。
プロンプトに式を入力すると、replは評価結果を印字する。
    ) 1
    1
    ) (+ 1 2 3 4)
    10
    ) (* (+ 1 2) 3 4)
    36
例のように、Parenでは演算子を前置し、後置した被演算子と共に括弧で括る。
このように演算子を前置する記法をポーランド記法乃至、前置記法という。
このプログラムを書くには、次の二つの項目に分割して考えることができる。
1. hello worldという文字列を生成する。
2. 生成した文字列を印字する。
文字列を生成する一番簡単な方法は文字列リテラルを使用することである。
Parenでは、ダブルクォーテーションで括られた文字の列は文字列リテラルと見做される。
    ) "hello world"
    "hello world"
例のように、文字列は評価されると自身が返される。
このままでも課題をこなしたと見做せるが、
印字された`hello world`はreplが出力したものである。
標準出力に文字列を出力するにはprint関数を使用する。
    ) (print "hello world")
    hello world
    "hello world"
print呼び出しによる二つの行はそれぞれ
1. printが標準出力へ出力した結果
2. replが印字した式の評価結果
を意味する。
print関数は引数を標準出力に印字すると同時に、評価結果として引数を返す。
すべての式は値を返すという事実はParenの特徴の一つとなる。
## 複写関数
もうひとつの例として標準入力から標準出力に複写する関数copyを作成する。
    ; copy 第一版
    (function copy ()
      (<- c nil)
      (while ((!= c :EOF))
        (<- c (getc))
        (putc c)))
functionはcopyという引数がない関数を定義している。
関数の本体では、cという変数にgetcで標準入力から取得した文字を代入している。
そのあとに、cに代入した値をputcで標準出力に書き出している。
このプログラムは、
    Parenのすべて式は評価されると値を返す。
という性質を用いてより簡潔に書ける。
代入オペレータ―は代入した値を返すように設計されている。
    ) (<- c "hello world")
    "hello world"
    ) c
    "hello world"
代入オペレーターの返り値を利用すると次のように書ける。
    ; copy 第二版
    (function copy ()
      (while ((!= (<- c (getc)) :EOF)) (putc c)))
この書き方の方がよりParenらしいといえるが、
返り値を濫用するプログラムは時に可読性を下げてしまうので注意が必要である。

# コメント
Parenには一行コメントどドキュメンテーションコメントの二種類のコメントがあり、
用途によりそれぞれ使い分ける。
## 一行コメント
Parenでは`;`から行末までがコメントとして扱われ、無視される。
これを一行コメントと呼ぶ。
    ; コメント
    ;; これもコメント
## ドキュメンテーションコメント
また、`"""`と`"""`で囲んだ領域もコメントとして扱われ、無視される。
これをドキュメンテーションコメントと呼ぶ。
    """
    ドキュメンテーションコメント
    複数行に跨がれる。
    """
ドキュメンテーションコメントには改行を含めることもできる。
自作するモジュールや、モジュール内のグローバル変数、関数、マクロ等には、
ドキュメンテーションコメントを記載することが望ましい。
Parenにはソースコード中のドキュメンテーションコメントを、
html形式のドキュメントに変換する機能があり、自動で文書化される。
具体的な使用方法や、仕様については別紙を参照されたい。

# 変数
Parenには変数に値を代入、参照する仕組みがある。
この章では簡単な使用例をいくつか挙げるだけにとどまり、
読者の理解のために厳密には誤った表現も用いる。
## 変数名
Parenの変数名は数字以外の英文字と一部の記号から始まり、
その後、英数字と一部の記号が続く。
次のいずれもParenの変数名として有効である。
    var
    x1
Parenでは様々な記号も変数名に使用することができる。
次にあげる変数名は(決して推奨しないが)すべて有効である。
変数名称で使用できる文字の厳密な定義は言語仕様書の字句解析の章を参考されたい。
    !$*+-0-9abc?
    m<__.__>m
一般に、複数の単語で構成されている変数名は、
単語の区切れをアンダースコアで区切る。
    user_name
    neighbor_node
## 代入
Parenには特殊な式の評価方法が組み込みで用意されており、
それらを総称して、スペシャルオペレーターと呼ぶ。
変数に値を代入するにはスペシャルオペレーター`<-`を使用する。
以降は代入オペレーターと呼ぶ。
    (<- variable_value ...)
    variable_value ::= var value
    var -- 変数名
    value -- 変数に代入する値
代入オペレーターは代入する変数varとその値valを組にして受け取る。
Parenでは代入する前に変数を宣言する必要はない。
代入オペレーターは最後に代入した値を返す。
    ) (<- a 0 b 1)
    1
代入オペレーターで複数の代入を行う場合は、
すべて左から順に評価されることが保証されている。
     ) (<- x (print 3)
           y (print (* x 2)))
     3
     6
     6
Parenが組み込みで使用している変数に値を代入することもできるが、
ほとんどの場合、ユーザの予期せぬ動作となってしまうだろう。
## 参照
変数は評価されると代入されている値を返す。
    ) (<- a 3 b 4)
    4
    ) a
    3
    ) b
    4
ただし、変数に値が代入されていない場合はエラーとなる。
## 定数
Parenには言語機能として定数は存在しない。
そのため、定数として扱う変数は、
慣習として他の変数と見分けがつくように大文字の変数名を使用する。
    ) (<- PI 3.141592
          MAX_BUF_SIZE 256)
    256
定数の値を書き換えないように、プログラマは注意する必要がある。
    ) (<- PI 3)
    3
## 擬似変数
Parenには代入することができないことを除き、
変数のように振舞うオブジェクトが存在する。
そのようなオブジェクトを擬似変数と呼ぶ。
システムには次の擬似変数が定義されており、ユーザは新たに追加することはできない。
    擬似変数 役割
    ----------------------------------------
    true     真の代表値
    false    偽の代表値
    nil      空の代表値

# 環境
Parenが変数とそれに対応づけられた値との関係を、
環境と呼ばれるモデルを採用して管理している。
Parenの変数について理解するために、環境の理解は必須となる。
## 環境モデル
環境とは、変数と値の一対一の対応の集合と、
零または一つの自身以外の環境への参照の対のことをいう。
ある環境が持つ、環境への参照先のことを親の環境という。
また、その逆の関係を子の環境という。
定義により、ある環境は零または一つの親を持つが、
一つの環境は零以上の子の環境を持つ。
親の環境が存在しないような環境はParenには一つしかない。
その環境のことを特に、トップレベルという。
ある式が評価される場合、必ずどこかの環境の下で評価される。
Parenを起動した直後の環境はトップレベルとなる。
## 変数の束縛
ある環境の変数と値の対の集合に、
新しく要素を追加する行為をその環境に変数を束縛するという。
## 環境の作成
現在の環境への参照をもつ新しい環境を作るには、
スペシャルオペレーターletを使用する。
    (let binding_form body_form ...)
    binding_form ::= ((var [val]) ...)
    var -- 束縛する変数
    val -- 束縛する値
    body_form -- 新しく作る環境内で評価する式
ただし、valを省略した場合はvarはnilで束縛される。
letの返り値は最後の式の評価結果となる。
## 代入
環境モデルを考慮すると代入は次のように定義できる。
    代入とは、変数を環境に束縛する行為である。
代入オペレータ―は次の規則で変数を束縛する。
    もし、束縛しようとしている変数が既に現在の環境に束縛されている場合はその束縛されている値を更新する。
    束縛されていない場合は、親の環境に対して再帰的に束縛を試みる。
    トップレベルにも束縛されていない場合は、トップレベルに束縛する。
Parenの起動直後の環境はトップレベルであるから、
今までの代入の例は、トップレベルに変数を束縛してきたことにほかならない。
## 変数の評価
変数は評価されると次の手順で値が探索される。
    もし、現在の環境に変数が束縛されているならその値を返す。
    束縛されていない場合は、親の環境に対して再帰的に探索を行う。
    ただし、トップレベルに束縛されていない場合はエラーとなる。
次に、その動作例を一つ上げる。
最初にトップレベルにa、b、cをそれぞれ0、1、2で束縛している。
次にそれらの積を評価し、結果が0なのが確認できる。
    ) (<- a 0 b 1 c 2)
    2
    ) (* a b c)
    0
ここで、letでトップレベルの下に新しく環境を構築し、
その環境にa、b、cをそれぞれ1、2、3で束縛し再度積を評価する。
    ) (let ((a 1) (b 2) (c 3))
          (* a b c))
    6
積がトップレベルでの評価と異なっていることが確認できる。
また、最後にletの外(つまりトップレベル)で再度積を評価すると、
結果は再び0になる。
    ) (* a b c)
    0
このように、ある変数の評価結果は評価される環境によって異なる。
## スコープ
ある変数を参照可能な範囲のことを変数のスコープ乃至、可視範囲という。
変数のスコープは環境モデルを用いると次のように定義できる。
    ある変数のスコープはその変数が束縛されている環境から辿れるすべての子の環境である。
    ただし、辿りうる子の環境の中に同名の変数が束縛されている場合は、
    変数のスコープはその環境よりも親の環境までとなる。
親の環境で束縛されている変数を、子の環境で束縛することを、
変数の再束縛する。乃至、変数をシャドーイングするという。
## エクステント
あるオブジェクトがメモリ上に確保されてから破棄されるまでの期間のことを、
エクステント乃至、生存期間という。
Parenのオブジェクトには時間的な制約がなく、
他のあらゆるオブジェクトから参照の可能性がある限り破棄されることはない。
このようなエクステントを無限エクステントという。
Parenは無限エクステントであるから、
ある変数の参照先が既に破棄されていたというようなことはおこらない。
ただし、無限エクステントではあるが、
一旦メモリに確保されたオブジェクトが永遠に破棄されないというわけではない。
ガーベージコレクションにより、
プログラムから参照するすべがなくなったオブジェクトは定期的に破棄される。
## グローバル変数
一般に、プログラムのどこからでも参照できる変数をグローバル変数という。
Parenではトップレベルで束縛された変数のことをグローバル変数という。
ただし、変数の再束縛があるため
慣習として、ほかの変数と区別がつきやすいようにグローバル変数名は`$`から始める。
    $global_var

# キーワード
キーワードは同名であるならば同一であるという性質をもつオブジェクトである。
性質により、キーワードの比較はオブジェクトの存在するメモリ番地の比較で済むため、
列挙として使用されることがある。
キーワードを作成するには次のいずれかの方法を用いる。
- キーワードリテラルを使用する
- to_key関数を使用する
ただし、その性質上すでにシステムにその名前のキーワードが存在する場合、
新しくオブジェクトが生成されることはなく、その参照が返される。
## キーワードリテラル
キーワードリテラルは`:`から始まる識別子である。
    : identifier
    identifier -- 識別子
識別子には変数で使える文字ならすべて使用可能であり、先頭が数字でも構わない。
厳密な仕様については言語仕様書の字句定義の章を参照のこと。
    ) :key
    :key
## to_key関数
to_key関数は文字列を受け取り、それに対応するキーワードを返す。
    (to_key string)
    string -- 文字列
to_key関数を使用することにより、
キーワードリテラルで作成できないキーワードも作成可能。
    ) (to_key "a b c")
    :a b c
キーワードリテラルでこのような記述をサポートしないのは、
Parenが必要最低限の機能を提供するというコンセプトによる。
また、そのようなリテラルが本当に必要な場合はParenの機能で定義できる。

# 数値
今までの章で説明なく使用してきた数値や、算術関数にについて述べる。
## 評価
数値は評価されると自身を返す。
    ) 3
    3
    ) 3.333
    3.333
Parenではすべての実数は数値型のオブジェクトとして扱われる。
## 算術関数
代表的な算術関数を次に示す。
    関数  処理
    -------------------
    +     加算
    -     減算
    *     乗算
    /     除算
    **    冪乗
    //    切り捨て除算
    mod   余り
これらの関数についてはその簡潔さから評価例のみ示す。
    ) (+ 3 4 5)
    12
    ) (- 10 4 5)
    1 ; <=> (- (- 10 4) 5)
    ) (* 3 4 5)
    60
    ) (/ 3 4 5)
    0.15
    ) (/ 3)
    0.33333
    ) (** 2 3)
    8
    ) (// 5 4)
    1
    ) (mod 6 4)
    2
非Lisp系言語では二項演算子として定義してあるものも、
Parenでは可変長引数の関数に過ぎない。
## 代入マクロ
Parenには算術にまつわる次の代入マクロが定義されている。
    手続き 処理
    --------------------------------------------
    ++     変数に1足した結果を代入
    --     変数に1引いた結果を代入
    +=     変数に+を評価した結果を代入
    -=     変数に-を評価した結果を代入
    /=     変数に/を評価した結果を代入
    *=     変数に*を評価した結果を代入
これらと等価な式を示す。
    (++ var) <=> (<- var (+ var 1))
    (-- var) <=> (<- var (- var 1))
    (+= var val) <=> (<- var (+ var val))
    (-= var val) <=> (<- var (- var val))
    (*= var val) <=> (<- var (* var val))
    (/= var val) <=> (<- var (/ var val))
    var -- 変数
    val -- 増減値

# 文字列
文字列は文字列リテラルや組み込みのto_str関数等で生成できる。
文字列リテラルはダブルクォートで囲まれた文字の列である。
    ) "hello paren"
    "hello paren"
## 文字列の評価
文字列は評価されると自身を返す。
to_str関数はParenのオブジェクトの印字表現を返す。
    ) (to_str 123)
    "123"
## 文字列の結合
文字列の結合は数値の加算と同じ組み込み関数+を用いる。
    ) (+ "hello" "_" "paren")
    "hello_paren"
## 文字列の長さの取得
文字列の長さを取得するには組み込み関数のlengthを使用する。
    ) (length "hello paren")
    11
## 部分文字列の取得
部分文字列を取得するにはsub_strを使用する。
    ) (sub_str "hello paren" 6)
    "paren"
    ) (sub_str "hello paren" 0 5)
    "hello"
第一引数のみ指定されている場合はその値以降の部分文字列を取得する。
第二引数まで指定してある場合は、
第一引数から第二引数の値の前までの部分文字列を取得する。
ただし、どちらの場合も零から数える。
## 文字列の比較
文字列の比較は比較関数`=`で行う。
    ) (= "hello paren" "hello paren")
    true
    ) (= "Hello Paren" "hello paren")
    false
## 部分文字列が含まれるか判定
部分文字列が含まれているかどうか判定するにはinclude?を使用する。
    ) (include? "Hello Paren" "Hello")
    true
    ) (include? "Hello Paren" "hello")
    false
## 文字列の先頭がある部分文字列と一致するか判定
startWith?は文字列が特定の文字列で始まっているかを判定する。
    ) (startWith? "Hello Paren" "Hello")
    true
    ) (startWith? "Hello Paren" "hello")
    false
## 文字列の末尾がある部分文字列と一致するか判定
endWith?は文字列が特定の文字列で終了しているか判定する。
    ) (endWith? "Hello Paren" "Paren")
    true
    ) (endWith? "Hello Paren" "Hello")
    false
## 正規表現
Parenで正規表現を使用したい場合は:Regexモジュールをインクルードする。
詳細は:Regexモジュールのドキュメントを参照のこと。

# リスト
リストはParenにおいて最も重要なオブジェクトであり、
同時にParenを記述するプログラムでもある。
## コンスの作成
リストを理解するためにはコンスを理解する必要がある。
コンスとは次に定義されるParenのオブジェクトである。
    Parenのオブジェクトへのポインタの組car、cdrをコンスという。
    ただし、carは任意のParenのオブジェクトを指せるが、
    cdrはコンスまたはnil以外指すことができない。
コンスは組み込み関数consにより作ることができる。
consの第一引数、第二引数が、それぞれ作成されるコンスのcarとcdrに対応する。
    ) (cons 1 nil)
    (1)
    ) (cons 1 (cons 2 nil))
    (1 2)
    ) (cons (cons 1 nil) (cons 2 nil))
    ((1) 2)
コンスの定義から外れるような引数をconsに与えるとエラーとなる。
Parenはコンスを次の手順で印字する。
1. 左括弧を印字
2. carが指す値を印字する
   cdrが指す値がnilなら3を行う
   そうでなければ、再びcdrが指すコンスに対して2を行う
3. 右括弧を印字
図示すると次のようになる。
    ) (cons 1 (cons 2 (cons 3 nil)))
    (1 2 3)
    +-----+-----+
    | car | cdr |
    +-----+-----+
       |     |    +-----+-----+
       |     +--->| car | cdr |
       |          +-----+-----+
       |             |     |    +-----+-----+
       |             |     +--->| car | cdr |
       |             |          +-----+-----+
       |             |             |     |
       |             |             |     +---> nil
       1             2             3
あるコンスのcarがコンスを指している場合でもそのルールは再帰的に適用される。
    ) (cons (cons 1 nil) (cons 2 (cons 3 nil)))
    ((1) 2 3)
    +-----+-----+
    | car | cdr |
    +-----+-----+
       |     |    +-----+-----+
       |     +--->| car | cdr |
       |          +-----+-----+
       |             |     |    +-----+-----+
       |             |     +--->| car | cdr |
       |             2          +-----+-----+
       |                           |     |
       |    +-----+-----+          |     +---> nil
       +--->| car | cdr |          3
            +-----+-----+
               |     |
               |     +---> nil
               1
このように、あるコンスのcdrで辿れるコンス全体が括弧で囲われて印字される。
コンスのcdrで辿れるコンス全体のことをリストという。
これは、辿れるコンス全体が単方向リストと見做せるからである。
下に、その対応関係を示す。
    値   対応
    ---------------------------------------------
    cons 単方向リストのセル
    car  単方向リストが格納するオブジェクトへのポインタ
    cdr  次の単方向リストのセルへのポインタ
    nil  単方向リストの終端
あるコンスのcdrを辿っていった終端がnilを指している場合、
そのコンス全体は純リストであるという。
コンスの定義により、Parenの任意のリストはすべて純リストである。
純リスト以外のリストが作れないという制約は
ほかのLisp系の言語と比べると奇妙かもしれない。
最後に、Parenにはあるオブジェクトがリストか判定する関数と
コンスか判定する関数がそれぞれ存在する。
    ) (list? 1)
    false
    ) (cons? 1)
    false
    ) (list? (cons 1 nil))
    true
    ) (cons? (cons 1 nil))
    true
    ) (list? nil)
    true
    ) (cons? nil)
    false
この二つの関数は空を表す擬似変数nilを与えた場合を除き同じ結果を返す。
空を表す擬似変数nilに対してlist?がtrueを返すのは自然な実装であると考えられる。
以後、nilが要素がないリストのこと指している場合は空のリストと呼ぶ。
## リストの作成
リストは関数consにより作られるが、
複数の要素を持つようなリストを作ろうとすると、すぐに困ったことになる。
    ) (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 nil)))))
    (1 2 3 4 5)
そのため、Parenには引数を要素に持つようなリストを作成するための関数、
listが存在する。
    ) (list 1 2 3 4 5)
    (1 2 3 4 5)
リストの定義により、要素がリストであるようなリストも作成することもできる。
    ) (list (list 1 (list 2 3) 4 5))
    ((1 (2 3)) 4 5)
ここで、Parenのリストを作成する記述そのものが、
Parenのリストになっていることに注意されたい。
## carとcdrの参照
コンスが指す二つのポインタcar、cdrの指す場所を得る関数があり、
それぞれcarとcdrという。
    ) (<- lis (list 1 2))
    (1 2)
    ) (car lis)
    1
    ) (cdr lis)
    (2)
    ) (car (cdr lis))
    2
carとcdrは引数が空のリストである場合はnilを返す。
    ) (car nil)
    nil
    ) (cdr nil)
    nil
    ) (car (cdr (cdr lis)))
    nil
リストの要素を参照するときにcarとcdrを組み合わせることは頻繁にあるため、
計四回までリストを辿るすべての組み合わせが定義されている。
    caar cadr cdar cddr
    caaar caadr cadar caddr cdaar cdadr cddar cdddr caaaar
    caaadr caadar caaddr cadaar cadadr caddar cadddr cdaaar cdaadr cdadar
    cdaddr cddaar cddadr cdddar cddddr
これらの関数についてはその等価な式を例示することにとどめる。
    (caar lis) <=> (car (car lis))
    (caddr lis) <=> (car (cdr (cdr lis)))
## carとcdrへ代入
コンスのcarとcdrが指す場所を変更するには、
それぞれcar、cdr関数の第二引数に値を指定する。
    ) (<- a (list 1 2 3))
    (1 2 3)
    ) (car a)
    1
    ) (car a 0)
    (0 2 3)
これはすべての操作関数について成り立つ。
    ) (cadr a 1)
    (0 1 3)
cdrが指す値を書き換える際、純リストでなくなるような代入はできない。
## リストの評価
既に説明したリスト以外のオブジェクトのことを総称してアトムという。
ParenはS式によって記述されると述べたが、
S式とはアトム又はリストのことをいう。
つまり、Parenはアトム又はリストによって記述されることに他ならない。
変数を除くアトムは既に述べたように、評価されると自身を返す。
変数の場合は評価されると束縛されている値を返す。
    ) 1
    1
    ) "string"
    "string"
    ) :keyword
    :keyword
    ) (<- var 0)
    0
    ) var
    0
リストの評価方法については明示的に述べることはなかったが、
すべてこの形式であったはずである。
    (operator [arg] ...)
    operator -- オペレーター
    arg -- オペレーターに渡る引数
リストが評価されるとき、まず最初にオペレーターが評価される。
オペレーターはリストであっても構わず、その場合は再帰的に処理が行われる。
次に、評価したオペレーターの種類にしたがってリストを評価する。
Parenのオペレーターには次の三種類が存在する。
- 関数
- スペシャルオペレーター
- マクロ
オペレーターの評価結果が上記のいづれでもない場合はエラーとなる。
### 関数の評価
関数は、すべての引数が評価されてから評価される。
次の算術演算は例として相応しいであろう。
    ) (<- x 1 y 2 z 3)
    3
    ) (+ (* x x) (* y y) (* z z))
    14
関数`+`、`*`の引数はそれぞれ評価されてから渡される。
### スペシャルオペレーターの評価
スペシャルオペレーターはParenに組み込まれている特殊なオペレーターで、
その種類ごとに引数の評価のされ方が異なる。
例えば、前述した代入オペレーターは奇数番目の引数は評価しないが、
偶数番目の引数は評価する。
    ) (<- a (list 1))
    (1)
上の例で、もし代入オペレーターが関数ならば、
すべての引数を評価した結果をその関数の引数とするため、
未束縛の変数aが評価されてエラーとなるはずである。
### マクロの評価
マクロはすべての引数を評価せずに評価される。
ただし、その定義のされ方によっては引数が評価されているようにも見える。
詳しくはマクロの章で論ずる。
## プログラムとデータ
評価結果が評価可能なリストであるようなリストを考えることができる。
このことは、任意のParenのプログラムはParenのデータであるということと相まって、
ParenのデータはParenのプログラムになりうるということを意味する。
データとプログラムを相互に変換可能であることは、
プログラムを書くプログラムを書きやすくする。
実際マクロはこの事実に着眼した機能であり、Parenを強力な言語にしている。

# 関数
関数はParenの根幹をなすオブジェクトである。
ただし、この文書内における関数という単語は、
計算幾何学における手続き(サブルーチン)程度の意味しかない。
## 関数の定義
関数を定義するにはマクロfunctionを用いる。
    (function function_name ([var ...
                             [:opt var_value ...]
                             [:rest var]
                             [:key var_value ...]])
        body_form ...)
    var_value ::= {var | (var value)}
    function_name -- 定義する関数名
    var -- 仮引数名
    value -- 仮引数の初期値
functionの第一引数、第二引数、第三引数以降のことを、
それぞれ、定義する関数の関数名、仮引数、本体という。
functionは与えられた名前の関数を定義し、その関数を返す。
    ) (function double (x) (* 2 x))
    double
    ) (double 4)
    8
functionで定義する関数は、組み込みのそれと何ら変わらない。
## 関数の評価
関数は評価されると自身を返す。
    ) double
    (fn (x) (* 2 x))
ただし、どのように印字されるかは処理系依存となる。
## 関数呼び出し
関数を呼び出すには、関数名とその引数をリストにして評価すればよい。
    ) (double 3)
    6
    ) (double 4)
    8
関数の仮引数と一致しない場合はエラーとなる。
関数の実引数の評価は必ず左から順に評価される。
## 仮引数
仮引数には次の種類がある。
1. 必須パラメーター
2. オプショナルパラメーター
3. レストパラメーター
4. キーワードパラメーター
任意のパラメーターを同時に組み合わせて指定することができるが、
同時に指定する際は、上の順番で指定しなければならない。
### 必須パラメーター
必須パラメーターは関数呼び出し時に必ず与えなければならない仮引数を定義する。
関数呼び出し時に必須パラメーターが足りない場合はエラーとなる。
    ) (function avg2 (x y)
        (/ (+ x y) 2))
    ) (avg 2 4)
    3
### オプショナルパラメーター
オプショナルパラメーターは関数呼び出し時に省略可能な仮引数を定義する。
オプショナルパラメーターは`:opt`句に指定する。
オプショナルパラメーターには初期値を与えることができ、
呼び出し時にオプショナルパラメーターが省略された場合は初期値が使用される。
    ) (function x_add_y (x :opt (y 1))
        (+ x y))
    x_add_y
    ) (x_add_y 3)
    4
    ) (x_add_y 3 2)
    5
オプショナルパラメーターの初期値を指定しない場合は、
実引数で指定されなかった場合にnilが初期値となる。
そのため次の二つの関数の仮引数は等価である。
    (function f1 (:opt x) ...)
    (function f2 (:opt (x nil)) ...)
オプショナルパラメータは次に示すように複数指定することもできる。
    ) (function concat (s1 :opt (s2 "") (s3 ""))
        (+ s1 s2 s3))
    ) (concat "hello")
    "hello"
    ) (concat "hello" " world")
    "hello world"
    ) (concat "hello" " world" "!!")
    "hello world!!"
ただし、i番目のオプショナルパラメーターを指定して関数を呼びたい場合は、
i - 1番目までのオプショナルパラメータをすべて指定する必要がある。
### レストパラメーター
レストパラメーターは可変長な実引数を渡せる仮引数を定義する。
レストパラメーターは`:rest`句に指定する。
レストパラメーターを指定した関数は、
仮引数よりも多い実引数がすべてリストとなりレストパラ―メーターに束縛される。
    ) (function first_rest (first :rest rest)
        (list first rest))
    ) (first_rest 1 2 3)
    (1 (2 3))
レストパラメーターに束縛される実引数がない場合はnilが束縛される。
    ) (first_rest 1)
    (1 nil)
### キーワードパラメーター
キーワードパラメーターは、順序を問わない名前付きの仮引数を定義する。
キーワードパラメーターは`:key`句に指定する。
キーワードパラメーターには初期値を与えることができ、
呼び出し時にキーワードパラメーターが省略された場合は初期値が使用される。
    ) (function test_key (:key (k1 1) (k2 2) k3)
        (list k1 k2 k3))
    test_key
    ) (test_key)
    (1 2 nil)
    ) (test_key :k1 -1)
    (-1 2 nil)
キーワードパラメーターの仮引数の順序と実引数の順序は一致しなくてもよい。
    ) (test_key :k3 3 :k1 -1)
    (-1 2 3)
## 無名関数
プログラムを書いていると、定義してまで使う程での処理でもないが、
関数を作成したい場面があるかもしれない。
このような場合にはスペシャルオペレーターfnを使用できる。
    (fn ([var ...  [:opt var_value ...] [:rest var] [:key var_value ...]])
        body_form ...)
    var_value ::= {var | (var value)}
    var -- 仮引数名
    value -- 仮引数の初期値
fnが作る関数のことをその名前がないことにちなみ、無名関数という。
fnに与える引数は、名前を指定しないという点を除いてfunctionと全く同じである。
無名関数は後述する汎関数を使うときにしばしば用いられる。
次の例は引数を足す関数を返す関数addNである。
    ) (function make-adder (n)
        (fn (x) (+ x n)))
    make_adder
    ) (<- add10 (make_adder 10))
    (fn (x) (+ x 10))
    ) (add10 2)
    12
    ) (<- add3 (make_adder 3))
    (fn (x) (+ x 3))
    ) (add3 2)
    5
本質的に、functionマクロは、
fnで作られた関数を第一引数で指定された名前の変数に代入しているだけなのである。
このことについては、後述するマクロの章で述べる。
## 汎関数
前述したように関数はParenの一つのデータ型にすぎない。
そのため、他のデータ型である数値や文字列と同様に、
変数に代入したり、関数に引数として渡したり、
関数の返り値として返したりすることができる。
ここで、関数全体の集合のうち、
引数に関数をとる、或いは、返り値が関数であるように定義された関数を、
汎関数乃至、、高階関数という。
汎関数を用いることにより、高度な抽象化を用いることができる。
## 再帰関数
関数全体の集合のうち、関数の本体で自分自身を呼ぶような関数を再帰関数と呼ぶ。
再帰関数を用いると直感的にプログラムできることがある。
再帰関数の例として整数nの階乗を求める関数factorialを示す。
    (function factrial (n)
        (if (= n 1) 1
            (* n (factorial (- n 1)))))
これはfor文を用いるより、直感的である。
    (function factrial (n)
        (<- result n)
        (while ((!= n 1) result)
            (*= reult (-- n))))
また、再帰関数全体の集合のうち、
自身の呼び出しごとにスタックが積まれないような関数を末尾再帰関数という。
上記のfactorialは呼び出しごとにスタックが積まれていくため末尾再帰関数ではない。
factorialは次のような末尾再起関数に変換できる。
    (function factorial (n :opt (acc 1))
        (if (= n 1) acc
            (factorial (- n 1) (* acc n))))
## 純粋関数
関数全体の集合のうち、次の性質を持つものを特に純粋関数という。
- 任意の引数に対して、返り値が時間に依存せずに一意に定まる
- 他に何も影響を与えない
このような性質を参照透過性という。
また、二つ目の性質
    他に何も影響を与えない
のことを副作用という。
次のような処理は副作用がある。
- 代入
- 入出力
定義から、次のような関数は純粋関数ではない。
- あるグローバル変数の値の3倍の数を返す関数
- 引数を標準出力に印字する関数
- 引数の値を3倍に変更する関数
- 現在時刻をシードとした0か1の乱数を返す関数を返す関数
逆に、次の処理を行うだけの関数は純粋関数である。
- 引数を返す関数
- 引数の文字列表現を返す関数
- 引数の値の3倍の値を返す関数
- 引数をシードとした0か1の乱数を返す関数を返す関数
可能な限りプログラムは純粋関数で構成することが望ましい。
これは、純粋関数はそうでない関数に比べてとりうる状態が少なく、
一般的に汎用的な処理になりバグも発生しにくいことによる。

# 条件分岐
Parenには条件分岐のオペレータifが存在する。
上記のオペレーターが気にいらなかったり、
新たにオペレーターが必要になった場合は後述するマクロでいつでも拡張できる。
## 真偽値
Parenは次にあげる値を除き、すべて真と見做される。
- false
- nil
- 0
- ""
## if
ifは汎用的な条件分岐処理を行うためのスペシャルオペレーターである。
    (if clause ...)
    clause ::= (test body_form ...)
    test -- 処理を行うか否かを表す真偽値
    body_form -- testが真のときに評価される式
ifは評価する条件と評価する式のリストのリストとなっている。
ifは最初の引数から、そのリストの先頭の要素を評価する。
評価結果が真の場合はそのリストの残りの要素を順に評価し、
そうでなければ次の引数に対して同じことを行う。
    ) (function to_roman (x)
        (if ((= x 1) :one)
            ((= x 2) :tow)
            ((= x 3) :three)
            (true :more)))
    ) (roman 1)
    :one
    ) (roman 4)
    :more
if全体は条件式が真を返す引数があれば、その引数の最後の要素の評価結果を返す。
そうでなければfalseを返す。
最後の引数がデフォルトを表す節の場合は慣習としてtrueを用いる。
## 三項演算子
Parenには三項演算子相当の`?`マクロが用意されている。
    (? test then_form else_form)
    test -- 真偽値
    then_form -- testが真の場合に評価される式
    else_form -- testが偽の場合に評価される式
三項演算子は条件分岐が二通りで、分岐後に評価する式が簡潔な場合に有効である。
## 比較関数
Parenには、あるオブジェクトが等しいか判定する関数が二種類存在する。
    関数 処理
    --------------
    =    同等判定
    eq?  同一判定
ここで、あるオブジェクトA、Bの存在を仮定する。
AとBが同等であるとは、AとBの型が等しく概念的にも等しいと見做せることをいう。
AとBが同一であるとは、AとBがメモリ上の同一アドレスに存在することをいう。
これらの定義から次のことが言える。
- 同等である条件はオブジェクトの型により異なる。
- 同一であることは同等であることの必要条件であるが十分条件ではない。
`=`は二つ以上のオブジェクトがすべて同等であれば真を返す。
    ) (= 3 3 3)
    true
    ) (= 3 2)
    false
    ) (<- a 3 b 3)
    3
    ) (= a b)
    true
次のように型が異なる場合は、概念的に等しくても偽を返す。
    ) (= "3" 3)
    false
`eq?`は、比較する二つ以上のオブジェクトがすべて同一である場合に真を返す。
    ) (eq? 3 3)
    false
    ) (<- a 3 b 3)
    3
    ) (eq? a b)
    false
    ) (<- b `a)
    a
    ) (eq? a b)
    true
`eq?`はメモリ番地の比較をするだけなので高速である。
また、Parenでは同一変数はすべて同一なオブジェクトであることが保証されている。
    ) (eq? :a :a)
    true
    ) (<- a 3)
    3
    ) (eq? a a)
    true
## 述語の結合
ある式の評価結果が真か偽を表すことを強調する場合その式を述語という。
Parenには述語を結合するオペレーターがある。
    名称 処理
    ------------------------------------------------------------------------
    and  すべての引数の評価結果が真の場合に最後の評価結果を返す。
         ただし、評価途中に偽を返す式があったら以降の評価を中断しfalseを返す。
    or   どれか一つの引数の評価結果が真の場合にその値を返す。
         ただし、評価途中に真を返す式があったら以降の引数は評価しない。
         また、すべての引数の評価結果が偽の場合はfalseを返す。
    not  述語が真の場合は偽を、偽の場合は真を返す。
Parenには`=`の否定を返す関数`!=`が存在するが、
notの定義により次の二つの式は等価となる。
    (!= expr1 expr2) <=> (not (= expr1 expr2))

# 反復
Parenには反復処理を行うためのオペレーターがいくつか存在する。
- for
- while
- each
また、このほかに必要に応じてユーザが反復処理を行うマクロを定義することができる。
## for
forは汎用的な反復処理を実現する。
    (for (init-form end-test-form step-form [result-form])
        form ...)
forが評価されるとき、最初にinit-formが評価される。
そのあとに次の順で反復処理が行われる。
1. end-test-formを評価した結果が真の場合2へ、偽なら反復終了
2. すべてのformを逐次評価
3. step-formを評価して1へ戻る
反復終了後に、result-formが指定してある場合は評価してfor全体の返り値とする。
指定していない場合はfalseを返す。
単純なforの使用例として1から10までの和を返すプログラムを示す。
    ) (for ((<- i 1 sum 0) (<= i 10) (+! i 1) sum)
          (+! sum i))
    55
## while
whileは次の書式をとる。
    (while (end-test-form [result-form])
        body_form ...)
次の手順で反復処理が行われる。
1. end-test-formを評価した結果が真なら2へ偽なら反復終了
2. formを逐次評価し、1へ戻る
while全体として、result-formが指定されている場合はその評価結果を返す。
指定されていない場合はnilを返す。
## each
eachは引数が反復可能なオブジェクトの場合に使用できる。
反復できるオブジェクトとには次の種類が存在する。
- 配列
- リスト
eachは第一引数のリストの第一要素に反復時に使用する変数名を、
第二要素に反復する対象を指定する。
eachの第二引数移行が、反復処理の対象となる。
    (each (iterator object [result-form])
        form...)
簡単な評価例を示す。
    ) (each (i (range 1 5))
          (print i))
    12345
    ) (each (i "12345")
          (print i))
    12345
また、第一引数のリストに第三要素が指定されている場合、
反復終了後のeach全体としてその式を評価した結果を返す。

# 配列
配列は連続したメモリ上にオブジェクトを確保するデータ構造である。
配列で表現することのできる任意のデータ構造はリストでも再現可能であるが、
処理速度等の理由により配列を採用する場合がある。
なお、Parenの配列はParenのオブジェクトなら何でも代入することができる。
## 配列の生成
配列は組み込みのarray関数で作成する。
arrayの書式を示す。
    (array size [initial_function])
sizeは必須パラメーターで作成する配列の大きさを指定する。
なお、配列は一度作成するとその大きさは変更できない。
    ) (array 3)
    [false false false]
初期化関数`initial_function`は省略可能で、
指定しない場合は、初期値falseで初期化される。
初期化関数は引数を一つとる関数で次のように、
各要素番号を使用した初期化が可能。
    ) (array 3 (fn (i) (* i 2)))
    [0 2 4]
## リードマクロによる生成
初期値があらかじめ決まっているような配列はリードマクロを使うと便利である。
    ) #[1 2 3]
    [1 2 3]
## 要素の参照
配列の要素を参照するには組み込み関数の`[]`を使用する。
次に書式を示す。
    ([] array index)
添え字は零から数える。
    ) (<- arr #[1 2 3])
    [1 2 3]
    ) ([] arr 1)
    2
配列が確保している範囲外にアクセスするとエラーとなる。
## 配列の要素の更新
配列の要素を更新するには参照と同じ関数`[]`を使用する。
次に書式を示す。
    ([] array index value)
簡単な使用例を示す。
    ) (<- arr #[1 2 3])
    [1 2 3]
    ) ([] arr 1 10]
    [1 10 3]
また、式の返り値は配列となる。
## 多次元配列
配列の要素には任意のParenのオブジェクトを保持できるため、
配列の各要素が配列であるような配列が定義できる。
このような配列を2次元配列という。
この概念を拡張して、一般に多次元配列という。
Parenでは多次元配列をコアライブラリに含めることはせず、
モジュールとして提供する。

# マップ
マップは配列の添え字に任意のParenのオブジェクトを設定できる配列である。
実装はハッシュテーブルにより実装されているため、
理論上はO(1)でデータの探索が可能。
詳細な仕様については別ドキュメントを参照されたい。
## マップの作成
マップを作成するには組み込みのmap関数を使用する。
    ) (map)
    nil
要素を指定して初期化する場合はリードマクロを使用できる。
下の例のようにキーと値をペアで指定する。
    ) #{key1 val1
        key2 val2
        key3 val3}
    {key1 val1 key2 val2 key3 val3}
## 要素の参照
マップmapのキーkeyに対応する値を参照するには`{}`関数を使用する。
    ({} map key)
簡単な評価例を示す。
    ) (<- map #{:key1 :val1 :key2 :val2})
    {:key1 :val1 :key2 :val2}
    ) ({} map :key2)
    :val2
ただし、keyに対応する値がない場合はfalseを返す。
そのため、keyが設定されているのか、否かは関数hasKey?を使用する必要がある。
## 要素の設定
マップmapのキーkeyに値valueを設定するには`{}`関数を使用する。
    ({} map key value)
簡単な評価例を示す。
    ) (<- map #{:key1 :val1 :key2 :val2})
    {:key1 :val1 :key2 :val2}
    ) ({} map 3 :three)
    {:key1 :val1 :key2 :val2 3 :three}
返り値はマップとなる。
また、既にキーに対する値がマップに存在する場合は上書きする。
    ) ({} map :key2 :two)
    {:key1 :val1 :key2 :two 3 :three}

# スペシャルオペレーター
スペシャルオペレーターはParenのS式の評価ルールに従わない、
オペレーターごとに異なる特別なルールで評価される。
スペシャルオペレーターには次の種類が存在する。
- <-
- let
- if
- do
- quote
- fn
これらのうち、いくつかはすでに説明してきた。
ここでは、まだ説明していないスペシャルオペレーターについて述べる。
## quote(評価見送り)
変数を評価させたくない場合があるかもしれない。
そのような場合はスペシャルオペレーター`quote`が使える。
quoteは引数を評価せずに、そのまま返す。
    ) (<- a 3)
    3
    ) a
    3
    ) (quote a)
    a
このように、評価を見送ることをクォートするという。
Parenでは、クォートすることが頻繁にあるため、
そのための構文糖が用意されてある。
構文糖を使用するには次の例のように、
クォートしたい対象に`'`(クォート)を前置すればよい。
    ) 'a ; <=> (quote a)
    a
## let(変数束縛)
    let = '(let' '(' let_form+ ')'
              s_expr* ')'
    let_form = '(' variable s_expr ')' | variable |false
`let`は新しく変数を束縛する。
束縛する変数が既に宣言されていても構わない。
第一引数が変数束縛式のリストを表す。
変数束縛式がシンボルの場合は
第二引数以降が、第一引数で束縛した変数の環境下にて暗黙のdoにより評価される。
## do(逐次評価)
    '(do' s_expr+ ')'
doは引数を左から順に評価していき、
最後の式の評価結果を返す。
## try(例外処理コンテキスト作成)
    '(try' s_expr+ ')'
tryは例外発生時に内部のcach
## quote(クォート)
    (quote expr)
`quote`はS式`expr`の評価を見送り、`expr`そのものを返す。
その利用頻度から構文糖であるリードマクロ`\``が定義されている。

# マクロ
マクロはParenが読み込まれ、リードマクロが展開された後に評価される。
この評価をマクロ展開という。
マクロはリードマクロ、マクロ、スペシャルオペレーター、 関数等、
すべてのParenの機能を使用してユーザが定義することができる。
マクロは使用される前に定義がされている必要がある。
マクロ展開は、展開結果にマクロが含まれなくなるまで再帰的に行われる。
## マクロ定義
TODO

# リードマクロ
いままで見てきたように、Parenの構文は他の言語に比べて簡潔である。
この章では、リードマクロにより構文を作成し、
実際にはParenには構文があってないようなものであるということを垣間見る。
## リードマクロの定義
TODO

# goto文
TODO

# 例外処理機構
TODO

# クラス
Parenは関数型言語として設計されているが、
マクロの力により手続き型言語として使用することも十分可能であることを見てきた。
ここではマクロを用いてParenの上に構築されたオブジェクト指向言語について述べる。
以後、このドメイン特化言語をPOS(Paren Object System)と呼ぶ。
POSはCommon LispのCLOSから強い影響を受けているが、
強力すぎる機能をそぎ落とし、使用頻度が高い必要最低限の機能に抑えてある。
また、実装は簡潔に心がけ必要に応じてハックできる余地も残してある。
この章は、読者にオブジェクト指向の知識があることを前提として述べる。
## クラスの作成
クラスはマクロclassにより作成する。
    (class class_name (super_class ...)
        field ...)
    class_name -- 作成するクラスの名前
    super_class -- 作成するクラスのスーパークラス
    field -- 作成するクラスのインスタンス変数
書式から分かるように、POSでは次の特徴がある。
- 型の多重継承
- メソッドがクラスに属さない
classマクロは概ね、次のようなS式に展開される。
展開結果から分かるように、内部的にはただのマップである。
    (<- Class #{:type :class_name
                :super (list super_class ...)
                :fields #{:field false ...}})
例として二次元ベクトル空間の元を表すクラスPointを示す。
    (class Point () x y)
例のように、Parenではクラス名は慣習としてパスカルケースを用いる。
## インスタンスの生成
インスタンスの生成にはnewマクロを使用する。
    (new class [var val] ...)
    class -- 生成するインスタンスのクラス
    var -- インスタンス変数名称
    val -- varの初期値
前述したPointクラスのオブジェクトは次のように生成する。
    (<- p (new Point))
必要に応じてインスタンス変数を初期化することもできる。
初期化されていない変数の値はfalseとなる。
    (<- q (new Point :x 3 :y 4))
## インスタンスの型
インスタンスの型を調べるにはtypeマクロを使用する。
    (type class)
    class -- クラス名
クラスの型はクラス定義の際に、クラス名に対応するキーワードが自動的に設定される。
    ) (type p)
    :Point
また、型を判定する述語としてtype?マクロがある。
これはただ単に、同一判定をするS式に展開するマクロである。
    (type? p :Point) <=> (eq? (type p) :Point)
## インスタンス変数の参照と代入
POSではクラス定義と同時にインスタンス変数へのアクセサが自動生成される。
自動生成されるアクセサはインスタンス変数名の前に`.`を付けたものとなる。
そのため、メソッド以外の識別子を`.`から始めることは推奨しない。
    ) (<- p (new Point :x 0 :y 0))
    p
    ) (.x p)
    :3
    ) (.x p 3)
    p
    ) (.x p)
    3
## メソッドの定義
メソッドの定義はmethodマクロを使用する。
    (method (required_params [:opt option_param ...]
                             [:key key_param ...]
                             [:rest rest_param])
        body ...)
    required_params ::= (class required_param) ...
    option_param ::= (option_param [initial_value]) ...
    key_param ::= (key_param [initial_value]) ...
    class -- メソッドを決定するクラス
    required_param -- 必須パラメーター
    option_param -- オプショナルパラメーター
    rest_param -- レストパラメーター
    body -- メソッド本体
methodは型と変数名のリストを必須パラメーターに指定するようなfunctionだと思えばよい。
二次元ベクトル空間上の元の和を返すメソッドを例として示す。
    (method .add ((Point p1) (Point p2))
        (new Point :x (+ (.x p1) (.x p2))
                   :y (+ (.y p1) (.y p2))))
なお、このメソッドを可変長引数に拡張することは、
methodで指定できるパラメーターが柔軟なため容易である。
作成したメソッドはクラスとは別のグローバル変数$methodに登録される。
このマクロはグローバル変数$methodにメソッド登録するS式に展開される。
先ほどの.addは概ね次のようなS式に展開される。

if .addが環境に存在するか .add関数の作成
else if .addがメソッドか .add関数にメソッド登録
else 衝突エラー

.add関数の実装イメージ
(function .add (&rest params)

    (add_method ({} $method .add)
                '(Point Point)
                '(new Point :x (+ (.x p1) (.x p2))
                            :y (+ (.y p1) (.y p2))))

$methodはキーにメソッド名称、値にその型ごとの実装のハッシュマップを持つ、
ハッシュマップである。
生成したオブジェクトの初期化は、慣習としてinitメソッドを定義してそこで行う。
    (init (new Point) :x 4 :y 5)
このようなinitは次のように定義されているであろう。
    (method init ((Point p) :key (x 0) (y 0))
        (.x p x)
        (.y p y))
例に示すように、実はインスタンス定義したインスタンス変数は、
自動でアクセサが生成される。
    (class Point () x y)
    (method .x ((Point p) :opt x)
      (if (false? x) ({} ({} :fields p) :x))
          (:else ({} ({} :fields p) :x x))))
    (method .y ((Point p) :opt y)
      (if ((nil? y) ({} ({} :fields p) :y))
          (:else ({} ({} :fields p) :y y))))
Parenでは宣言したインスタンス変数はすべて外部に公開する仕様である。
このことは、作成するクラスにドキュメントを書くことと、
使用するクラスのドキュメントを読むことを後押しする。
また、クラスをハックする手段を意図的に残している。


# 付録
## 左辺一覧
Parenで左辺となりうる対称の一覧を示す。
    対象   参照            代入
    -------------------------------------------
    変数   var             (<- var val)
    コンス (car var)       (car var val)
           (cdr var)       (cdr var val)
    配列   ([] var index)  ([] var index val)
    マップ ({} var index)  ({} var index val)
    構造体 (get var index) (set var index val)
その使用頻度から組み込みの代入手続きは
> 副作用をもつオペレーターの末尾には`!`を付ける。
という命名規約を破っている。

## 命名規約
Parenでの命名規約をまとめる。
これは言語機能により強制されるわけではなく、
あくまで推奨されるものである。
### 命名方法の定義
    命名方法       定義
    -----------------------------------------------------------------------
    パスカルケース 単語の区切りの最初の一文字を大文字にする命名法
    キャメルケース 最初の一文字目を小文字にする点を除きパスカルケースと同じ
    スネークケース 単語の句切れをアンダースコアでつなぐ命名法
    チェインケース 単語の句切れをハイフンでつなぐ命名法
### 命名規約速見表
下に示す命名規約は推奨すべき命名方法であり、
場合によってはこの限りではない。
    対象            命名方法
    --------------------------------------------------------
    ファイル                  スネークケース
    定数                      すべて大文字のスネークケース
    ローカル変数              キャメルケース
    グローバル変数            `$` + キャメルケース
    クラス                    パスカルケース
    キーワード                `:`から始まるキャメルケース
                              (ただし、型を表す場合はパスカルケースとする。)
    述語                      末尾に`?`を付ける
    破壊的処理                末尾に`!`を付ける
    束縛系のマクロ            withから始める
    アナフォリック系のマクロ  最後に`*`を付ける
    構造体                    パスカルケース
