Parenチュートリアル

# 概要
このチュートリアルはParenの機能を早巡りすることを目的とする。
ParenはS式によって記述される、最古のプログラミング言語Lispの方言である。
ただし、実装されている関数やマクロや、
それらの命名などは相当作者好みのものとなっている。
Parenのコンセプトを示す。
- programmable programming language
- ability to rapidly develop
- runnable on all major platforms 
- easy and simple to learn
- never programming without enjoying

# 目次
- 書式
- 序章
- コメント
- 変数
- 環境
- キーワード
- 数値
- 文字列
- リスト
- 関数
- 条件分岐
- 反復
- 配列
- マップ
- スペシャルオペレーター
- マクロ
- リードマクロ
- 例外処理
- クラス
- 付録

# 書式
チュートリアルを記載するにあたり、書式を次に示すBNFで記載する。
    記号 定義
    ----------------------------------------
    [ ]  []内は省略可能
    { }  {}内から一つ選択
    |    []、{}内の代替候補の区切り文字
    ...  直前の構文を零回以上繰り返す
    ::=  左辺を右辺で定義
    --   左辺の説明

# 序章
この章ではいくつかのプログラムを掲載し、
Parenの雰囲気を知ってもらうことを目的とする。
そのため詳細な説明は割愛してある。
## hello world
プログラミング言語を習得する唯一の方法は、それでプログラムを書くことである。
そしてそれは、慣習により次のプログラムを書くことから始まる。
次の文字列を印字せよ。
    hello world
引数を与えることなしにParenを起動すると、 
repl(read-eval-print-loop)と呼ばれる対話モードで起動される。
    $paren
    ) 
`)`はプロンプトといい、プログラムを入力すると評価されその結果が出力される。
プロンプトに式を入力すると、replは評価結果を印字する。
    ) 1
    1
    ) (+ 1 2 3 4)
    10
    ) (* (+ 1 2) 3 4)
    36
例のように、Parenでは演算子を前置し、後置した被演算子と共に括弧で括る。
このように演算子を前置する記法をポーランド記法乃至、前置記法という。
このプログラムを書くには、次の二つの項目に分割して考えることができる。
1. hello worldという文字列を生成する。
2. 生成した文字列を印字する。
文字列を生成する一番簡単な方法は文字列リテラルを使用することである。
Parenでは、ダブルクォーテーションで括られた文字の列は文字列リテラルと見做される。
    ) "hello world"
    "hello world"
例のように、文字列は評価されると自身が返される。
このままでも課題をこなしたと見做せるが、
印字された`hello world`はreplが出力したものである。
標準出力に文字列を出力するにはprint関数を使用する。
    ) (print "hello world")
    hello world
    "hello world"
print呼び出しによる二つの行はそれぞれ
1. printが標準出力へ出力した結果
2. replが印字した式の評価結果
を意味する。
print関数は引数を標準出力に印字すると同時に、評価結果として引数を返す。
すべての式は値を返すという事実はParenの特徴の一つとなる。
## 複写関数
もうひとつの例として標準入力から標準出力に複写する関数copyを作成する。
    ; copy 第一版
    (function copy ()
      (<- c nil)
      (while (!= c :EOF)
        (<- c (getc))
        (putc c)))
functionはcopyという引数がない関数を定義している。
関数の本体では、cという変数にgetcで標準入力から取得した文字を代入している。
そのあとに、cに代入した値をputcで標準出力に書き出している。
このプログラムは、
    Parenのすべて式は評価されると値を返す。
という性質を用いてより簡潔に書ける。
代入オペレータ―は代入した値を返すように設計されている。
    ) (<- c "hello world")
    "hello world"
    ) c
    "hello world"
代入オペレーターの返り値を利用すると次のように書ける。
    ; copy 第二版
    (function copy ()
      (while (!= (<- c (getc)) :EOF) (putc c)))
この書き方の方がよりParenらしいといえるが、
返り値を濫用するプログラムは時に可読性を下げてしまうので注意が必要である。

# コメント
Parenには一行コメントどドキュメンテーションコメントの二種類のコメントがあり、
用途によりそれぞれ使い分ける。
## 一行コメント
Parenでは`;`から行末までがコメントとして扱われ、無視される。
これを一行コメントと呼ぶ。
    ; コメント
    ;; これもコメント
## ドキュメンテーションコメント
また、`"""`と`"""`で囲んだ領域もコメントとして扱われ、無視される。
これをドキュメンテーションコメントと呼ぶ。
    """
    ドキュメンテーションコメント
    複数行に跨がれる。
    """
ドキュメンテーションコメントには改行を含めることもできる。
自作するモジュールや、モジュール内のグローバル変数、関数、マクロ等には、
ドキュメンテーションコメントを記載することが望ましい。
Parenにはソースコード中のドキュメンテーションコメントを、
html形式のドキュメントに変換する機能があり、自動で文書化される。
具体的な使用方法や、仕様については別紙を参照されたい。

# 変数
Parenには変数に値を代入、参照する仕組みがある。
この章では簡単な使用例をいくつか挙げるだけにとどまり、
読者の理解のために厳密には誤った表現も用いる。
## 変数名
Parenの変数名は数字以外の英文字と一部の記号から始まり、
その後、英数字と一部の記号が続く。
次のいずれもParenの変数名として有効である。
    var
    x1
Parenでは様々な記号も変数名に使用することができる。
次にあげる変数名は(決して推奨しないが)すべて有効である。
変数名称で使用できる文字の厳密な定義は言語仕様書の字句解析の章を参考されたい。
    !$*+-0-9abc?
    m<__.__>m
一般に、複数の単語で構成されている変数名は、
単語の区切れをアンダースコアで区切る。
    neighbor_count
    prim_table
## 代入
Parenには特殊な式の評価方法が組み込みで用意されており、
それらを総称して、スペシャルオペレーターと呼ぶ。
変数に値を代入するにはスペシャルオペレーター`<-`を使用する。
以降は代入オペレーターと呼ぶ。
代入オペレーターには代入する変数varとその値valを組にして指定する。
    (<- variable_value ...)
    variable_value ::= var value
    var -- 変数名
    value -- 変数に代入する値
変数にはParenのオブジェクトなら何でも代入できる。
また、変数を宣言する必要もない。
代入オペレーターは最後に代入した値を返す。
    ) (<- a 0 b 1)
    1
代入オペレーターで複数の代入を行う場合は、
すべて左から順に評価されることが保証されている。
     ) (<- x (print 3)
           y (print (* x 2)))
     3
     6
     6
Parenが組み込みで使用している変数に値を代入することもできるが、
ほとんどの場合、ユーザの予期せぬ動作となってしまうだろう。
## 参照
変数は評価されると代入されている値を返す。
    ) (<- a 3 b 4)
    4
    ) a
    3
    ) b
    4
ただし、変数に値が代入されていない場合はエラーとなる。
## 定数
Parenには言語機能として定数は存在しない。
そのため、定数として扱いたい変数を定義する場合、
他の変数と見分けがつくように大文字の変数名を使用する。
    (<- PI 3.141592
        MAX_BUF_SIZE 256)
    => 256
定数の値を書き換えないように、プログラマは注意する必要がある。
    (<- PI 3)
    => 3
## 定数
Parenには言語機能として定数は存在しない。
そのため、定数として扱いたい変数を定義する場合、
他の変数と見分けがつくように大文字の変数名を使用する。
    (<- PI 3.141592
        MAX_BUF_SIZE 256)
    => 256
定数の値を書き換えないように、プログラマは注意する必要がある。
    (<- PI 3)
    => 3
## 擬似変数
Parenには代入することができないことを除き、
変数のように振舞うオブジェクトが存在する。
そのようなオブジェクトを擬似変数と呼ぶ。
システムには次の擬似変数が定義されており、ユーザは新たに追加することはできない。
    擬似変数 役割
    ----------------------------------------
    true     真の代表元
    false    偽の代表元
    nil      空の代表元

# 環境
Parenが変数とそれに対応づけられた値との関係を、
環境と呼ばれるモデルを採用して管理している。
Parenの変数について理解するために、環境の理解は必須となる。
## 環境モデル
環境とは、零または一つの自身以外の環境への参照および、
変数とその値の一対一の対応の集合の組のことをいう。
ある環境が持つ、環境への参照の実体のことを親の環境という。
逆に、親の環境に対して、自身のことを子の環境という。
定義により、ある環境は一つの親を持つが、一つの環境は複数の子の環境を持ちうる。
環境への参照がない(親の環境が存在しない)ような環境はParenには一つしかない。
その環境のことを特に、トップレベルという。
ある式が評価される場合、必ずどこかの環境の下で評価される。
Parenを起動した直後の環境はトップレベルとなる。
## 変数の束縛
ある環境の変数とそれに対応付けられた値との集合に、
変数とその値の組を追加する行為をその環境にvarをvalで束縛するという。
前述した代入を、環境モデルを考慮して次のように再定義するとこうなる。
ある環境下で変数varに値valを代入するとは、
現在の環境に変数varを値valで束縛することである。
この定義により今までの代入の例は、
すべてトップレベルに変数を束縛してきたことにほかならない。
## 環境の作成
現在の環境への参照をもつ新しい環境を作るには、
スペシャルオペレーターletを使用する。
    (let binding_form body_form ...)
    binding_form ::= ((var [val]) ...)
letは値valに束縛する変数varの組と、
新しく作成する環境下で評価する式で記述される。
valは省略可能で、その場合varは:nilが指定されたものと見做される。
また、letは最後に評価された結果を返す。
## 変数の評価
ある環境下で変数varがどのように評価されるか述べる。
最初にトップレベルにa、b、cをそれぞれ0、1、2で束縛している。
次にそれらの積を評価し、結果が0なのが確認できる。
    (<- a 0 b 1 c 2)
    => 2
    (* a b c)
    => 0
この動作はすでに前述した例の通りである。
ここで、letでトップレベルの下に新しく環境を構築し、
その環境にa、b、cをそれぞれ1、2、3で束縛している。
この新しい環境内でそれらの積を評価すると、
結果がトップレベルでの評価と異なっていることが確認できる。
    (let ((a 1) (b 2) (c 3))
        (* a b c))
    => 6
また、最後にletの外(つまりトップレベル)で再度積を評価すると、
結果は再び0になる。
    (* a b c)
    => 0
この結果はParenが次の手順で変数の値を取得するためである。
もし、現在の環境に変数が束縛されているならその値を返す。
そうでなく、トップレベルでないならば親の環境に対して再帰的に探索を行う。
それでもなく、トップレベルならばエラーとなる。
定義により、環境のことを考えることなしに、
変数が束縛されている値を考えることに意味はない。
たとえば、次の例では評価される環境によって
現在の環境から直近の環境に束縛されている値が返る。
    ) (let ((a 0))
        (print a)
        (let ((a 1))
          (print a)
          (let ((a 2))
            (print a)
            (let ((a 3))
              (print a)))))
    0
    1
    2
    3
    3
## スコープ
ある変数を参照可能な範囲のことを変数のスコープ乃至、可視範囲という。
変数のスコープは環境モデルを用いると次のように定義できる。
    ある変数のスコープはその変数が束縛されている環境から辿れるすべての子の環境である。
    ただし、辿りうるある子の環境の中に同名の変数が束縛されている場合は、
    変数のスコープはその環境よりも親の環境までとなる。
親の環境で束縛されている変数を、子の環境で束縛することを、
変数の再束縛する。乃至、変数をシャドーイングするという。
## エクステント
あるオブジェクトがメモリ上に確保されてから破棄されるまでの期間のことを、
エクステント乃至、生存期間という。
Parenのオブジェクトには時間的な制約がなく、
他のあらゆるオブジェクトから参照の可能性がある限り破棄されることはない。
このようなエクステントを無限エクステントという。
ただし、一旦メモリに確保されたオブジェクトが永遠に破棄されないというわけではなく。
プログラムから参照するすべがなくなったらガーベージコレクションにより破棄される。
## グローバル変数
一般に、プログラムのどこからでも参照できる変数をグローバル変数という。
Parenではトップレベルで束縛された変数のことをグローバル変数という。
ただし、スコープで説明したように、
トップレベルで束縛した変数が再束縛されている場合は、
その環境以下ではグローバル変数が束縛されている値を直接は参照できない。
グルーバル変数はほかの変数と区別を付けやすいように、
名称は`$`から始めることが推奨される。
    $global_var

# キーワード
キーワードは同名であるならば同一であるという性質をもつオブジェクトである。
性質により、キーワードの比較はオブジェクトのメモリ番地の比較で済むため、
列挙として使用されることがある。
キーワードを作成するには次のいずれかの方法を用いる。
- キーワードリテラルを使用する
- to_key関数を使用する
ただし、その性質上すでにシステムにその名前のキーワードが存在する場合、
新しくオブジェクトが生成されることはなく、その参照が返される。
## キーワードリテラル
キーワードリテラルは`:`から始まる識別子である。
    : identifier
    identifier -- 識別子
識別子には変数で使える文字ならすべて使用可能であり、先頭が数字でも構わない。
厳密な仕様については言語仕様書の字句定義の章を参照のこと。
    ) :key
    :key
## to_key関数
to_key関数は文字列を受け取り、それに対応するキーワードを返す。
    (to_key string)
    string -- 文字列
to_key関数を使用することにより、
キーワードリテラルで作成できないキーワードも作成可能。
    ) (to_key "a b c")
    :a b c
キーワードリテラルでこのような記述をサポートしないのは、
Parenが必要最低限の機能を提供するというコンセプトによる。
また、そのようなリテラルが本当に必要な場合はParenの機能で定義できる。

# 数値
今までの章ではさりげなく算術関数を使用してきたが、
この章でそれらについて詳しく述べる。
## 評価
数値は評価されると自身を返す。
    ) 3
    3
    ) 3.333
    3.333
Parenではすべての数値は実数型のオブジェクトとして扱われる。
## 算術関数
代表的な算術関数を次に示す。
    関数  処理
    -------------------
    +     加算
    -     減算
    *     乗算
    /     除算
    **    冪乗
    //    切り捨て除算
    mod   余り
これらの関数についてはその簡潔さから実行例のみ示す。
    ) (+ 3 4 5)
    12
    ) (- 10 4 5)
    1 ; <=> (- (- 10 4) 5)
    ) (* 3 4 5)
    60
    ) (/ 3 4 5)
    0.15
    ) (/ 3)
    0.33333
    ) (** 2 3)
    8
    ) (// 5 4)
    1
    ) (mod 6 4)
    2
非Lisp系言語では二項演算子として定義してあるものも、
Parenでは可変長引数の関数に過ぎない。
## 代入マクロ
Parenには算術にまつわる次の代入マクロが定義されている。
    手続き 処理
    --------------------------------------------
    ++     変数に1足した結果を代入
    --     変数に1引いた結果を代入
    +=     変数に+を実行した結果を代入
    -=     変数に-を実行した結果を代入
    /=     変数に/を実行した結果を代入
    *=     変数に*を実行した結果を代入
これらと等価な式を示す。
    (+= var val) <=> (<- var (+ var val))
    (-= var val) <=> (<- var (- var val))
    (*= var val) <=> (<- var (* var val))
    (/= var val) <=> (<- var (/ var val))
    var -- 変数
    val -- 増減値

# 文字列
文字列は文字列リテラルや組み込みのto_str関数等で生成できる。
文字列リテラルはダブルクォートで囲まれた文字の列である。
    ) "hello paren"
    "hello paren"
文字列は評価されると自身を返す。
to_str関数はParenのオブジェクトの印字表現を返す。
    ) (to_str 123)
    "123"
## 文字列の結合
文字列の結合は数値の加算と同じ組み込み関数+を用いる。
    ) (+ "hello" "_" "paren")
    "hello_paren"
## 文字列の長さの取得
文字列の長さを取得するには組み込み関数のlengthを使用する。
    ) (length "hello paren")
    11
## 部分文字列の取得
部分文字列を取得するにはsub_strを使用する。
    ) (sub_str "hello paren" 6)
    "paren"
    ) (sub_str "hello paren" 0 5)
    "hello"
第一引数のみ指定されている場合はその値以降の部分文字列を取得する。
第二引数まで指定してある場合は、
第一引数から第二引数の値の前までの部分文字列を取得する。
ただし、どちらの場合も零から数える。
## 文字列の比較
文字列の比較は比較関数`=`で行う。
    ) (= "hello paren" "hello paren")
    true
    ) (= "Hello Paren" "hello paren")
    false
## 部分文字列が含まれるか判定
部分文字列が含まれているかどうか判定するにはinclude?を使用する。
    ) (include? "Hello Paren" "Hello")
    true
    (include? "Hello Paren" "hello")
    => false
## 文字列の先頭がある部分文字列と一致するか判定
startWith?は文字列が特定の文字列で始まっているかを判定する。
    (startWith? "Hello Paren" "Hello")
    =>true
    (startWith? "Hello Paren" "hello")
    => false
## 文字列の末尾がある部分文字列と一致するか判定
endWith?は文字列が特定の文字列で終了しているか判定する。
    (endWith? "Hello Paren" "Paren")
    => true
    (endWith? "Hello Paren" "Hello")
    => false
## 正規表現
Parenで正規表現を使用したい場合は:Regexモジュールをインクルードする。
詳細は:Regexモジュールのドキュメントを参照のこと。

# リスト
リストはParenにおいて最も重要なオブジェクトであり、
同時にParenを記述するプログラムでもある。
## コンスの作成
リストを理解するためにはコンスを理解する必要がある。
コンスとは次に定義されるParenのオブジェクトである。
    Parenのオブジェクトへのポインタの組car、cdrをコンスという。
    ただし、carは任意のParenのオブジェクトを指せるが、
    cdrはコンスまたはnil以外指すことができない。
コンスは組み込み関数consにより作ることができる。
consの第一引数、第二引数が、それぞれ作成されるコンスのcarとcdrに対応する。
    ) (cons 1 nil)
    (1)
    ) (cons 1 (cons 2 nil))
    (1 2)
    ) (cons (cons 1 nil) (cons 2 nil))
    ((1) 2)
コンスの定義から外れるような引数をconsに与えるとエラーとなる。
Parenはコンスを次の手順で印字する。
1. 左括弧を印字
2. carが指す値を印字する
   cdrが指す値がnilなら3を行う
   そうでなければ、再びcdrが指すコンスに対して2を行う
3. 右括弧を印字
図示すると次のようになる。
    ) (cons 1 (cons 2 (cons 3 nil)))
    (1 2 3)
    +-----+-----+
    | car | cdr |
    +-----+-----+
       |     |    +-----+-----+
       |     +--->| car | cdr |
       |          +-----+-----+
       |             |     |    +-----+-----+
       |             |     +--->| car | cdr |
       |             |          +-----+-----+
       |             |             |     |
       |             |             |     +---> nil
       1             2             3
あるコンスのcarがコンスを指している場合でもそのルールは再帰的に適用される。
    ) (cons (cons 1 nil) (cons 2 (cons 3 nil)))
    ((1) 2 3)
    +-----+-----+
    | car | cdr |
    +-----+-----+
       |     |    +-----+-----+
       |     +--->| car | cdr |
       |          +-----+-----+
       |             |     |    +-----+-----+
       |             |     +--->| car | cdr |
       |             2          +-----+-----+
       |                           |     |
       |    +-----+-----+          |     +---> nil
       +--->| car | cdr |          3
            +-----+-----+
               |     |
               |     +---> nil
               1
このように、あるコンスのcdrで辿れるコンス全体が括弧で囲われて印字される。
コンスのcdrで辿れるコンス全体のことをリストという。
これは、辿れるコンス全体が単方向リストと見做せるからである。
下に、その対応関係を示す。
    値   対応
    ---------------------------------------------
    cons 単方向リストのセル
    car  単方向リストが格納するオブジェクトへのポインタ
    cdr  次の単方向リストのセルへのポインタ
    nil  単方向リストの終端
あるコンスのcdrを辿っていった終端がnilを指している場合、
そのコンス全体は純リストであるという。
コンスの定義により、Parenの任意のリストはすべて純リストである。
純リスト以外のリストが作れないという制約は
ほかのLisp系の言語と比べると奇妙かもしれない。
最後に、Parenにはあるオブジェクトがリストか判定する関数と
コンスか判定する関数がそれぞれ存在する。
    ) (list? 1)
    false
    ) (cons? 1)
    false
    ) (list? (cons 1 false))
    true
    ) (cons? (cons 1 false))
    true
    ) (list? nil)
    true
    ) (cons? nil)
    false
この二つの関数は空を表す擬似変数nilを与えた場合を除き同じ結果を返す。
空を表す擬似変数nilに対してlist?がtrueを返すのは自然な実装であると考えられる。
以後、nilが要素がないリストのこと指している場合は空のリストと呼ぶ。
## carとcdrの参照
コンスが指す二つのポインタcar、cdrの指す場所を得る関数があり、
それぞれcarとcdrという。
    ) (<- lis (cons 1 (cons 2 false)))
    (1 2)
    ) (car lis)
    1
    ) (cdr lis)
    (2)
    ) (car (cdr lis))
    2
carとcdrは引数が空のリストである場合はnilを返す。
    ) (car nil)
    nil
    ) (cdr nil)
    nil
    ) (car (cdr (cdr lis)))
    nil
リストの要素を参照するときにcarとcdrを組み合わせることは頻繁にあるため、
計四回までリストを辿るすべての組み合わせが定義されている。
    caar cadr cdar cddr
    caaar caadr cadar caddr cdaar cdadr cddar cdddr caaaar
    caaadr caadar caaddr cadaar cadadr caddar cadddr cdaaar cdaadr cdadar
    cdaddr cddaar cddadr cdddar cddddr
これらの関数についてはその等価な式を例示することにとどめる。
    (caar lis) <=> (car (car lis))
    (caddr lis) <=> (car (cdr (cdr lis)))
## carとcdrへ代入
コンスのcarとcdrが指す場所を変更するには参照と同じcarとcdrを使用する。
これらは第二引数を与えると、参照先を第二引数に変更する。
    ) (<- a (cons 1 (cons 2 (cons 3 false))
    (1 2 3)
    ) (car a)
    1
    ) (car a 0)
    (0 2 3)
これはすべての操作関数について成り立つ。
    ) (cadr a 1)
    (0 1 3)
cdrが指す値を書き換える際、純リストでなくなるような代入はできない。
## リストの作成
リストは関数consにより作られるが、
複数の要素を持つようなリストを作ろうとすると、すぐに困ったことになる。
    ) (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 false)))))
    (1 2 3 4 5)
そのため、Parenには引数を要素に持つようなリストを作成するための関数、
listが存在する。
    ) (list 1 2 3 4 5)
    (1 2 3 4 5)
リストの定義により、要素がリストであるようなリストも作成することもできる。
    ) (list (list 1 (list 2 3) 4 5))
    ((1 (2 3)) 4 5)
ここで、Parenのリストを作成する記述そのものが、
Parenのリストになっていることに注意されたい。
## リストの評価
既に説明したリスト以外のオブジェクトのことを総称してアトムという。
ParenはS式によって記述されると述べたが、
S式とはアトム又はリストのことをいう。
つまり、Parenはアトム又はリストによって記述されることに他ならない。
変数を除くアトムは既に述べたように、評価されると自身を返す。
変数の場合は評価されると束縛されている値を返す。
    ) 1
    1
    ) "string"
    "string"
    ) :keyword
    :keyword
    ) (<- var 0)
    0
    ) var
    0
リストの評価方法については明示的に述べることはなかったが、
すべてこの形式であったはずである。
    (operator [arg] ...)
    operator -- オペレーター
    arg -- オペレーターに渡る引数
リストが評価されるとき、まず最初にオペレーターが評価される。
オペレーターはリストであっても構わず、その場合は再帰的に処理が行われる。
次に、評価したオペレーターの種類にしたがってリストを評価する。
Parenのオペレーターには次の三種類が存在する。
- 関数
- スペシャルオペレーター
- マクロ
オペレーターの評価結果が上記のいづれでもない場合はエラーとなる。
### 関数の評価
関数は、すべての引数が評価されてから評価される。
次の算術演算は例として相応しいであろう。
    ) (<- x 1 y 2 z 3)
    3
    ) (+ (* x x) (* y y) (* z z))
    14
### スペシャルオペレーターの評価
スペシャルオペレーターはParenに組み込まれている特殊なオペレーターで、
その種類ごとに引数の評価のされ方が異なる。
例えば、前述した代入オペレーターは奇数番目の引数は評価しないが、
偶数番目の引数は評価する。
    ) (<- a (list 1))
    (1)
上の例で、もし代入オペレーターが関数ならば、
すべての引数を評価した結果をその関数の引数とするため、
未束縛の変数aが評価されてエラーとなるはずである。
### マクロの評価
マクロはすべての引数を評価せずに評価される。
ただし、その定義のされ方によっては引数が評価されているようにも見える。
## プログラムとデータ
評価結果が評価可能なリストであるようなリストを考えることができる。
このことは、任意のParenのプログラムはParenのデータであるということと相まって、
ParenのデータはParenのプログラムになりうるということを意味する。
データとプログラムを相互に変換可能であることは、
プログラムを書くプログラムを書きやすくする。
実際マクロはこの事実に着眼した機能であり、Parenを強力な言語にしている。

# 関数
関数はParenの根幹をなすオブジェクトである。
ただし、この文書内における関数という単語は、
計算幾何学における手続き(サブルーチン)程度の意味しかない。
## 関数の定義
関数を定義するにはマクロdefを用いる。
次に、与えられた引数を二倍した値を返す関数を定義する例を示す。
    (def double (x)
      (* 2 x))
defの第一引数は定義する関数の名前であり、ここではdoubleとした。
第二引数は定義する関数の仮引数のリストとなる。
ここでは必須の引数を一つ受け取るのでその仮引数名をxとした。
仮引数のリストには後述するいくつかの指定方法がある。
第三引数以降は関数の本体のリストである。
関数の本体は左から順に逐次実行される。
## 関数呼び出し
定義した関数を呼び出すには、呼び出したい関数が第一要素、
その関数に渡したいi番目の引数がi + 1番目の要素であるようなリストを評価する。
先に定義したdoubleを呼び出す例を示す。
    (double 3)
    => 6
    (double 4)
    => 8
第一要素が関数であるようなリストの評価は次の順で行われる。
1. リストの第一要素を評価する。(今考えているのはこの評価結果が関数である)
2. リストの第二要素以降を番号を若い順に評価する。
3. 関数の実引数として、第二要素以降の評価結果を渡す。
4. 関数の本体が実行される。
## 仮引数の定義
関数を定義するときに指定する仮引数にはいくつか種類がある。
1. 必須パラメーター
2. オプショナルパラメーター
3. レストパラメーター
4. キーワードパラメーター
任意のパラメーターを同時に組み合わせて指定することができるが、
同時に指定する際は、上の順番で指定しなければならない。
### 必須パラメーター
必須パラメーターは変数により指定される。
指定したパラメーターは必須となり、
関数呼び出し時に実引数が足りない場合はエラーとなる。
    (double 2)
    => 4
    (double)
    => Error
    (def avg2 (x y)
      (/ (+ x y) 2))
    (avg 2 4)
    => 3
    (avg 2)
    => Error
### オプショナルパラメーター
オプショナルパラメーターは引数に初期値を与える仕組みである。
呼び出し時に省略された場合はその初期値が使用される。
仮引数に`:opt`が出現した以降の値がオプショナルパラメーターとして扱われる。
オプショナルパラメーターは変数名とその初期値をリストで指定する。
    (def incN (x :opt (x 1))
      (+ x adding))
    (incN 3)
    => 4
    (incN 3 2)
    => 5
初期値がfalseであるようなオプショナルパラメーターは、
オプショナルパラメーター名だけ指定することができる構文糖がある。
そのため、次の二つの関数は等価である。
    (def opt1 (:opt (x false)) x)
    (def opt2 (:opt x) x)
また、別のパラメーターが出現するまで複数指定することができる。
    (def concat (s1 :opt s2 s3)
      (+ s1 (if false? s2) ""
                (if false? s3) s2
                    (+ s2 s3)))))
    (concat "Hello")
    => "hello"
    (concat "Hello" "World")
    => "HelloWorld"
    (concat "Hello" "World" "!!")
    => "HelloWorld!!"
ただし、オプショナルパラメーターを複数指定する場合に、
i番目のオプショナルパラメーターを指定して関数を呼びたい場合は、
i - 1番目までのオプショナルパラメータをすべて指定する必要がある。
### レストパラメーター
レストパラメーターは関数を可変長引数にするための仕組みである。
仮引数に`:rest`が指定された直後の変数をレストパラメーターに束縛する。
レストパラメーターは二つ以上指定することはできない。
下に示すように仮引数よりも余分な実引数が、
リストとして実行時にレストパラメーターに束縛される。
    (def restTest (first :rest params)
      (list first params))
    (restTest 1 2 3)
    => (1 (2 3))
    (restTest 1)
    => (1 false)
### キーワードパラメーター
キーワードパラメーターとは、
仮引数の宣言順に依存しないで実引数を指定できるようにする仕組みである。
仮引数に`:key`が指定された以降の値がキーワードパラメーターとして扱われる。
宣言方法はオプショナルパラメーターと同じである。
    (def manyKey (:key (k1 0) (k2 0) (k3 0))
      (list k1 k2 k3))
    (manyKey)
    => (0 0 0)
    (manyKey :k1 1)
    => (1 0 0)
    (manyKey :k1 1 :k3 1)
    => (1 0 1)
初期値がfalseである場合の構文糖も使えることに注意せよ。
## 無名関数
プログラムを書いていると、定義してまで使う程での処理でもないが、
関数を作成したい場面があるかもしれない。
このような場合にはスペシャルオペレーターfnを使用できる。
    (fn 仮引数のリスト 関数の本体)
fnに与える引数は、名前を指定しないという点を除いてdefと全く同じである。
次の例は引数を足す関数を返す関数addNである。
    (def addN (n)
      (fn (x)
          (+ x n)))
    (<- add10 (addN 10))
    (add10 2)
    => 12
    ((addN 1) 2)
    => 3
実は、defが行っている処理はfnで作られた関数を、
第一引数で指定された名前の変数に代入しているだけなのである。
このことについては、後述するマクロの章で述べる。
## 汎関数
前述したように関数はParenの一つのデータ型にすぎない。
そのため、他のデータ型である数値や文字列と同様に、
変数に代入したり、関数に引数として渡したり、
関数の返り値として返したりすることができる。
ここで、関数全体の集合のうち、
引数に関数をとる、或いは、返り値が関数であるように定義された関数を、
汎関数または、高階関数という。
汎関数を用いることにより、高度な抽象化を用いることができる。
この例は既に前述の汎関数addNで見た。
## 再帰関数
関数全体の集合のうち、関数の本体で自分自身を呼ぶような関数を再帰関数と呼ぶ。
再帰関数を用いると直感的にプログラムできることがある。
再帰関数の例として整数nの階乗を求める関数factorialを示す。
    (def factrial (n)
        (if (= n 1) 1
            (* n (factorial (- n 1)))))
数学的には
    factorial(n) {
        1, (n = 1),
        n * factorial(n - 1), (n > 1).
と書けるが、
再帰関数を用いることにより、階乗の定義をそのまま書き下せていることが分かる。
また、再帰関数全体の集合のうち、
自身の呼び出しごとにスタックが積まれないような関数を末尾再帰関数という。
上記のfactorialは呼び出しごとにスタックが積まれていくため末尾再帰関数ではない。
factorialは次のような末尾再起関数に変換できる。
    (def factorial (n ? acc 1)
        (if (= n 1) acc
            (factorial (- n 1) (* acc n))))
## 純粋関数
関数全体の集合のうち、次の性質を持つものを特に純粋関数という。
- 任意の引数に対して、返り値が時間に依存せずに一意に定まる
- 他に何も影響を与えない
このような性質を参照透過性という。
また、二つ目の性質
> 他に何も影響を与えない
のことを副作用という。
次のような処理は副作用である。
- 代入
- 入出力
定義から、次のような関数は純粋関数ではない。
- あるグローバル変数の値の3倍の数を返す関数
- 引数を標準出力に印字する関数
- 引数の値を3倍に変更する関数
- 現在時刻をシードとした0か1の乱数を返す関数を返す関数
逆に、次のような関数は純粋関数である。
ただし、一連の処理には副作用はないこととする。
- 引数を返す関数
- 引数の文字列表現を返す関数
- 引数の値の3倍の値を返す関数
- 引数をシードとした0か1の乱数を返す関数を返す関数
可能な限りプログラムは純粋関数で構成することが望ましい。
これは、純粋関数は関数に比べてとりうる状態が少なく、
一般的に汎用的な処理になりバグも発生しにくいことによる。

# 条件分岐
Parenには条件分岐のオペレータifが存在する。
上記のオペレーターが気にいらなかったり、
新たにオペレーターが必要になった場合は後述するマクロでいつでも拡張できる。
## if
ifは一般的かつ、汎用的な条件分岐を実現する。
    (if (test-form1 form1-1 ...)
        (test-form2 form2-1 ...)
        ...
        (test-formN formN-1 ...))
ifの引数はリストのリストである。
ifは最初の引数から、そのリストの先頭の要素を評価する。
評価結果が真の場合はそのリストの残りの要素を順に評価し、
そうでなければ次の引数に対して同じことを行う。
    (def roman (x)
      (if ((= x 1) :one)
          ((= x 2) :tow)
          ((= x 3) :three)
          (:else :more)))
    (roman 1)
    => :one
    (roman 4)
    => :more
if全体は条件式が真を返す引数があれば、その引数の最後の要素の評価結果を返す。
そうでなければfalseを返す。
最後の引数がデフォルト節である場合は、
:defaultや:elseやtrueなど分かりやすいものを使用するとよい。
ちなみにifは他のLisp系言語におけるcondと同じ処理となる。
## 比較関数
Parenには、あるオブジェクトが等しいか判定する関数が二種類存在する。
    関数 処理
    --------------
    =    同等判定
    eq?  同一判定
ここで、あるオブジェクトA、Bの存在を仮定する。
AとBが同等であるとは、AとBの型が等しく概念的にも等しいと見做せることをいう。
AとBが同一であるとは、AとBがメモリ上の同一アドレスに存在することをいう。
これらの定義から次のことが言える。
- 同等である条件はオブジェクトの型により異なる。
- 同一であることは同等であることの必要条件であるが十分条件ではない。
`=`は二つ以上のオブジェクトがすべて同等であれば真を返す。
    (= 3 3 3)
    => true
    (= 3 2)
    => false
    (<- a 3 b 3)
    => 3
    (= a b)
    => true
次のように型が異なる場合は、概念的に等しくても偽を返す。
    (= "3" 3)
    => false
`eq?`は、比較する二つ以上のオブジェクトがすべて同一である場合に真を返す。
    (eq? 3 3)
    => false
    (<- a 3 b 3)
    => 3
    (eq? a b)
    => false
    (<- b `a)
    => a
    (eq? a b)
    => true
`eq?`はメモリの番地の比較をするだけなので高速である。
また、Parenでは同一変数はすべて同一なオブジェクトであることが保証されている。
    (eq? :a :a)
    => true
    (<- a 3)
    => 3
    (eq? a a)
    => true
## 述語の結合
ある式の評価結果が真か偽を表すことを強調する場合その式を述語という。
Parenには述語を結合するオペレーターがある。
    名称 処理
    ------------------------------------------------------------------------
    and  すべての引数の評価結果が真の場合に最後の評価結果を返す。
         ただし、評価途中に偽を返す式があったら以降の評価を中断しfalseを返す。
    or   どれか一つの引数の評価結果が真の場合にその値を返す。
         ただし、評価途中に真を返す式があったら以降の引数は評価しない。
         また、すべての引数の評価結果が偽の場合はfalseを返す。
    not  述語が真の場合は偽を、偽の場合は真を返す。
Parenには`=`の否定を返す関数`!=`が存在するが、
notの定義により次の二つの式は等価となる。
    (!= expr1 expr2)
    <=> (not (= expr1 expr2))

# 反復
Parenには反復を実現するオペレーターがいくつかある。
- for
- while
- each
また、このほかの反復処理はマクロを用いてユーザが自由に拡張可能である。
## for
forは次の書式をとる。
    (for (init-form end-test-form step-form [result-form])
        form ...)
forが評価されるとき、最初にinit-formが実行される。
そのあとに次の順で反復処理が行われる。
1. end-test-formを評価した結果が真の場合2へ、偽なら反復終了
2. すべてのformを逐次実行
3. step-formを評価して1へ戻る
反復終了後に、result-formが指定してある場合は評価してfor全体の返り値とする。
指定していない場合はfalseを返す。
単純なforの使用例として1から10までの和を返すプログラムを示す。
    (for ((<- i 1 sum 0) (<= i 10) (+! i 1) sum)
        (+! sum i))
    => 55
## while
whileは次の書式をとる。
    (while (end-test-form [result-form])
        form...)
次の手順で反復処理が行われる。
1. end-test-formを評価した結果が真なら2へ偽なら反復終了
2. formを逐次実行し、1へ戻る
while全体として、result-formが指定されている場合はその評価結果を返す。
指定されていない場合はfalseを返す。
## each
eachは引数が反復可能なオブジェクトの場合に使用できる。
反復できるオブジェクトとには次の種類が存在する。
- 配列
- リスト
eachは第一引数のリストの第一要素に反復時に使用する変数名を、
第二要素に反復する対象を指定する。
eachの第二引数移行が、反復処理の対象となる。
    (each (iterator object [result-form])
        form...)
簡単な実行例を示す。
    (each (i (range 1 5))
        (print i))
    => 12345
    (each (i "12345")
        (print i))
    => 12345
また、第一引数のリストに第三要素が指定されている場合、
反復終了後のeach全体としてその式を評価した結果を返す。

# 配列
配列は連続したメモリ上にオブジェクトを確保するデータ構造である。
配列で表現することのできる任意のデータ構造はリストでも再現可能であるが、
処理速度等の理由により配列を採用する場合がある。
なお、Parenの配列はParenのオブジェクトなら何でも代入することができる。
## 配列の生成
配列は組み込みのarray関数で作成する。
arrayの書式を示す。
    (array size [initial_function])
sizeは必須パラメーターで作成する配列の大きさを指定する。
なお、配列は一度作成するとその大きさは変更できない。
    (array 3)
    => [false false false]
初期化関数`initial_function`は省略可能で、
指定しない場合は、初期値falseで初期化される。
初期化関数は引数を一つとる関数で次のように、
各要素番号を使用した初期化が可能。
    (array 3 (fn (i) (* i 2)))
    => [0 2 4]
## リードマクロによる生成
初期値があらかじめ決まっているような配列はリードマクロを使うと便利である。
    #[1 2 3]
    => [1 2 3]
## 要素の参照
配列の要素を参照するには組み込み関数の`[]`を使用する。
次に書式を示す。
    ([] array index)
添え字は零から数える。
    (<- arr #[1 2 3])
    => [1 2 3]
    ([] arr 1)
    => 2
配列が確保している範囲外にアクセスするとエラーとなる。
    ([] arr 3)
    => Error
## 配列の要素の更新
配列の要素を更新するには参照と同じ関数`[]`を使用する。
次に書式を示す。
    ([] array index value)
簡単な使用例を示す。
    (<- arr #[1 2 3])
    => [1 2 3]
    ([] arr 1 10]
    => [1 10 3]
また、式の返り値は配列となる。
## 多次元配列
配列の要素には任意のParenのオブジェクトを保持できるため、
配列の各要素が配列であるような配列が定義できる。
このような配列を2次元配列という。
この概念を拡張して、一般に多次元配列という。
Parenでは多次元配列をコアライブラリに含めることはせず、
モジュールとして提供する。

# マップ
マップは配列の添え字に任意のParenのオブジェクトを設定できる配列である。
実装はハッシュテーブルにより実装されているため、
理論上はO(1)でデータの探索が可能。
詳細な仕様については別ドキュメントを参照されたい。
## マップの作成
マップを作成するには組み込みのmap関数を使用する。
    (map)
    => {}
要素を指定して初期化する場合はリードマクロを使用できる。
下の例のようにキーと値をペアで指定する。
    #{key1 val1
      key2 val2
      key3 val3}
    => {key1 val1 key2 val2 key3 val3}
## 要素の参照
マップmapのキーkeyに対応する値を参照するには`{}`関数を使用する。
    ({} map key)
簡単な実行例を示す。
    (<- map #{:key1 :val1 :key2 :val2})
    => {:key1 :val1 :key2 :val2}
    ({} map :key2)
    => :val2
ただし、keyに対応する値がない場合はfalseを返す。
そのため、keyが設定されているのか、否かは関数hasKey?を使用する必要がある。
## 要素の設定
マップmapのキーkeyに値valueを設定するには`{}`関数を使用する。
    ({} map key value)
簡単な実行例を示す。
    (<- map #{:key1 :val1 :key2 :val2})
    => {:key1 :val1 :key2 :val2}
    ({} map 3 :three)
    => {:key1 :val1 :key2 :val2 3 :three}
返り値はマップとなる。
また、既にキーに対する値がマップに存在する場合は上書きする。
    ({} map :key2 :two)
    => {:key1 :val1 :key2 :two 3 :three}

# スペシャルオペレーター
スペシャルオペレーターはParenのS式の評価ルールに従わない、
オペレーターごとに異なる特別なルールで評価される。
スペシャルオペレーターには次の種類が存在する。
- <-
- let
- if
- do
- quote
- fn
これらのうち、いくつかはすでに説明してきた。
ここでは、まだ説明していないスペシャルオペレーターについて述べる。
## quote(評価見送り)
変数を評価させたくない場合があるかもしれない。
そのような場合はスペシャルオペレーター`quote`が使える。
quoteは引数を評価せずに、そのまま返す。
    (<- a 3)
    => 3
    a
    => 3
    (quote a)
    => a
このように、評価を見送ることをクォートするという。
Parenでは、クォートすることが頻繁にあるため、
そのための構文糖が用意されてある。
構文糖を使用するには次の例のように、
クォートしたい対象に`'`(クォート)を前置すればよい。
    'a ; <=> (quote a)
    => a
## let(変数束縛)
    let = '(let' '(' let_form+ ')'
              s_expr* ')'
    let_form = '(' variable s_expr ')' | variable |false
`let`は新しく変数を束縛する。
束縛する変数が既に宣言されていても構わない。
第一引数が変数束縛式のリストを表す。
変数束縛式がシンボルの場合は
第二引数以降が、第一引数で束縛した変数の環境下にて暗黙のdoにより評価される。
## do(逐次実行)
    '(do' s_expr+ ')'
doは引数を左から順に評価していき、
最後の式の評価結果を返す。
## try(例外処理コンテキスト作成)
    '(try' s_expr+ ')'
tryは例外発生時に内部のcach
## quote(クォート)
    (quote expr)
`quote`はS式`expr`の評価を見送り、`expr`そのものを返す。
その利用頻度から構文糖であるリードマクロ`\``が定義されている。

# マクロ
マクロはParenが読み込まれ、リードマクロが展開された後に実行される。
この実行をマクロ展開という。
マクロはリードマクロ、マクロ、スペシャルオペレーター、 関数等、
すべてのParenの機能を使用してユーザが定義することができる。
マクロは使用される前に定義がされている必要がある。
マクロ展開は、展開結果にマクロが含まれなくなるまで再帰的に行われる。
## マクロ定義
TODO

# リードマクロ
いままで見てきたように、Parenの構文は他の言語に比べて簡潔である。
この章では、リードマクロにより構文を作成し、
実際にはParenには構文があってないようなものであるということを垣間見る。
## リードマクロの定義
TODO

# goto文
TODO

# 例外処理機構
TODO

# クラス
Parenは関数型言語として設計されているが、
マクロの力により手続き型言語として使用することも十分可能であることを見てきた。
ここではマクロを用いてParenの上に構築されたオブジェクト指向言語について述べる。
以後、このドメイン特化言語をPOS(Paren Object System)と呼ぶ。
POSはCommon LispのCLOSから強い影響を受けているが、
強力すぎる機能をそぎ落とし、使用頻度が高い必要最低限の機能に抑えてある。
また、実装は簡潔に心がけ必要に応じてハックできる余地も残してある。
この章は、読者にオブジェクト指向の知識があることを前提として述べる。
## クラスの作成
クラスはマクロclassにより作成する。
    (class class_name (super_class ...)
        field ...)
    class_name -- 作成するクラスの名前
    super_class -- 作成するクラスのスーパークラス
    field -- 作成するクラスのインスタンス変数
書式から分かるように、POSでは次の特徴がある。
- 型の多重継承
- メソッドがクラスに属さない
classマクロは概ね、次のようなS式に展開される。
展開結果から分かるように、内部的にはただのマップである。
    (<- Class #{:type :class_name
                :super (list super_class ...)
                :fields #{:field false ...}})
例として二次元ベクトル空間の元を表すクラスPointを示す。
    (class Point () x y)
例のように、Parenではクラス名は慣習としてパスカルケースを用いる。
## インスタンスの生成
インスタンスの生成にはnewマクロを使用する。
    (new class [var val] ...)
    class -- 生成するインスタンスのクラス
    var -- インスタンス変数名称
    val -- varの初期値
前述したPointクラスのオブジェクトは次のように生成する。
    (<- p (new Point))
必要に応じてインスタンス変数を初期化することもできる。
初期化されていない変数の値はfalseとなる。
    (<- q (new Point :x 3 :y 4))
## インスタンスの型
インスタンスの型を調べるにはtypeマクロを使用する。
    (type class)
    class -- クラス名
クラスの型はクラス定義の際に、クラス名に対応するキーワードが自動的に設定される。
    (type p)
    => :Point
また、型を判定する述語としてtype?マクロがある。
これはただ単に、同一判定をするS式に展開するマクロである。
    (type? p :Point) <=> (eq? (type p) :Point)
    => true
## インスタンス変数の参照と代入
POSではクラス定義と同時にインスタンス変数へのアクセサが自動生成される。
自動生成されるアクセサはインスタンス変数名の前に`.`を付けたものとなる。
そのため、メソッド以外の識別子を`.`から始めることは推奨しない。
    (<- p (new Point :x 0 :y 0))
    => p
    (.x p)
    => :3
    (.x p 3)
    => p
    (.x p)
    => 3
## メソッドの定義
メソッドの定義はmethodマクロを使用する。
    (method (required_params [:opt option_param ...]
                             [:key key_param ...]
                             [:rest rest_param])
        body ...)
    required_params ::= (class required_param) ...
    option_param ::= (option_param [initial_value]) ...
    key_param ::= (key_param [initial_value]) ...
    class -- メソッドを決定するクラス
    required_param -- 必須パラメーター
    option_param -- オプショナルパラメーター
    rest_param -- レストパラメーター
    body -- メソッド本体
methodは型と変数名のリストを必須パラメーターに指定するようなdefだと思えばよい。
二次元ベクトル空間上の元の和を返すメソッドを例として示す。
    (method .add ((Point p1) (Point p2))
        (new Point :x (+ (.x p1) (.x p2))
                   :y (+ (.y p1) (.y p2))))
なお、このメソッドを可変長引数に拡張することは、
methodで指定できるパラメーターが柔軟なため容易である。
作成したメソッドはクラスとは別のグローバル変数$methodに登録される。
このマクロはグローバル変数$methodにメソッド登録するS式に展開される。
先ほどの.addは概ね次のようなS式に展開される。

if .addが環境に存在するか .add関数の作成
else if .addがメソッドか .add関数にメソッド登録
else 衝突エラー

.add関数の実装イメージ
(def .add (&rest params)

    (add_method ({} $method .add)
                '(Point Point)
                '(new Point :x (+ (.x p1) (.x p2))
                            :y (+ (.y p1) (.y p2))))

$methodはキーにメソッド名称、値にその型ごとの実装のハッシュマップを持つ、
ハッシュマップである。
生成したオブジェクトの初期化は、慣習としてinitメソッドを定義してそこで行う。
    (init (new Point) :x 4 :y 5)
このようなinitは次のように定義されているであろう。
    (method init ((Point p) :key (x 0) (y 0))
        (.x p x)
        (.y p y))
例に示すように、実はインスタンス定義したインスタンス変数は、
自動でアクセサが生成される。
    (class Point () x y)
    (method .x ((Point p) :opt x)
      (if (false? x) ({} ({} :fields p) :x))
          (:else ({} ({} :fields p) :x x))))
    (method .y ((Point p) :opt y)
      (if ((nil? y) ({} ({} :fields p) :y))
          (:else ({} ({} :fields p) :y y))))
Parenでは宣言したインスタンス変数はすべて外部に公開する仕様である。
このことは、作成するクラスにドキュメントを書くことと、
使用するクラスのドキュメントを読むことを後押しする。
また、クラスをハックする手段を意図的に残している。


# 付録
## 左辺一覧
Parenで左辺となりうる対称の一覧を示す。
    対象   参照            代入
    -------------------------------------------
    変数   var             (<- var val)
    コンス (car var)       (car var val)
           (cdr var)       (cdr var val)
    配列   ([] var index)  ([] var index val)
    マップ ({} var index)  ({} var index val)
    構造体 (get var index) (set var index val)
その使用頻度から組み込みの代入手続きは
> 副作用をもつオペレーターの末尾には`!`を付ける。
という命名規約を破っている。

## 命名規約
Parenでの命名規約をまとめる。
これは言語機能により強制されるわけではなく、
あくまで推奨されるものである。
### 命名方法の定義
    命名方法       定義
    -----------------------------------------------------------------------
    パスカルケース 単語の区切りの最初の一文字を大文字にする命名法
    キャメルケース 最初の一文字目を小文字にする点を除きパスカルケースと同じ
    スネークケース 単語の句切れをアンダースコアでつなぐ命名法
    チェインケース 単語の句切れをハイフンでつなぐ命名法
### 命名規約速見表
下に示す命名規約は推奨すべき命名方法であり、
場合によってはこの限りではない。
    対象            命名方法
    --------------------------------------------------------
    ファイル                  スネークケース
    定数                      すべて大文字のスネークケース
    ローカル変数              キャメルケース
    グローバル変数            `$` + キャメルケース
    クラス                    パスカルケース
    キーワード                `:`から始まるキャメルケース
                              (ただし、型を表す場合はパスカルケースとする。)
    述語                      末尾に`?`を付ける
    破壊的処理                末尾に`!`を付ける
    束縛系のマクロ            withから始める
    アナフォリック系のマクロ  最後に`*`を付ける
    構造体                    パスカルケース
