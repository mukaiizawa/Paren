Parenチュートリアル

# 概要
このチュートリアルはParenの機能を早巡りすることを目的とする。
ただし、内容は浅すぎないように心がけ、
読者はチュートリアルの後に、APIを見ればプログラムが書けるようにはなっている。
また、必要に応じて応用編のテキストもあるので、
ある程度慣れてきたら一読することをお勧めする。
ParenはS式によって記述される、最も古い言語の部類に入るLisp系の言語である。
ただし、実装されている関数やマクロや、
それらの命名などは相当作者の好みが反映されている。
Parenには次のような特徴がある。
- programmable programming language
- ability to rapidly develop
- runnable on all major platforms 
- easy and simple to learn
- never programming without enjoying
勿論、これは半分冗談である。

# 目次
- コメント
- 変数
- 真偽値
- 数値
- 文字列
- リスト
- 関数
- 条件分岐
- 反復
- 配列
- 連想配列
- 構造体
- スペシャルフォーム
- マクロ
- リードマクロ
- 例外処理
- その他

# コメント
## 一行コメント
Parenでは`;`から行末までがコメントとして扱われ、無視される。
これを一行コメントと呼ぶ。
    ; コメント
    ;; これもコメント
## ドキュメンテーションコメント
また、`"""`と`"""`で囲んだ領域もコメントとして扱われ、改行も含めることができる。
これをドキュメンテーションコメントと呼ぶ。
    """
    ドキュメンテーションコメント
    複数行に跨がれます。
    """
自作するモジュールや、モジュール内の変数、関数、マクロ等には、
ドキュメンテーションコメントを記載することが望ましい。
Parenにはソースコード中のドキュメンテーションコメントを、
html形式のドキュメントに変換する機能があり、自動で文書化される。
具体的な使用方法や、仕様については別紙を参照のこと。

# 変数
## 変数名
Parenの変数名は数字以外の英文字と一部の記号から始まり、
その後英数字と一部の記号が続く。
次のいずれもParenの変数名として有効である。
    var
    x1
次にあげる変数名も(推奨されるような名称かはさておき)すべて有効である。
    !$!$!$!$!$!$!
    m<_._>m
ただし、真偽値を表す変数は最後は`?`で終わることが望ましい。
    exists?
    readable?
変数名称で使用できる文字の厳密な定義はParen言語仕様書の字句解析の項を参考のこと。
Parenが組み込みで使用している変数名称を使用することもできるが、
ほとんどの場合、ユーザの予期せぬ動作となってしまうだろう。
## 代入
変数に値を代入するには代入フォーム`<-`を使用する。
    (<- `a 3)
    => 3
    (* a 4)
    => 12
代入フォームは次の処理を行う。
    1. 第一引数を評価する。
    2. 第二引数を評価する。
    3. 第一引数の評価された結果が指す場所に、
       第二引数が評価された結果の値を書き込む。
例のように、代入フォームは最後の変数に代入する値を返す。
代入フォームには三つ以上の引数を渡すことができる。
その場合は、左から順に上記の処理が行われる。
     (<- `x 3 `y (* x 2))
     => 6
     (* x y)
     => 18
     (<- x 2)
     => 2
     x
     => 2
## 変数の評価
変数は評価されると、現在の環境における代入されている値を返す。
    (<- `a 3 `b 4)
    => 4
    a
    => 3
    b
    => 4
ただし、環境にその変数が束縛されていない場合はエラーとなる。
    unknownVariable
    => Error
## 恒等変数
代入できず、評価されると常に自身が返ってくる特殊な変数がある。
Parenではこのような変数を恒等変数という。
    :key
    => :key
    (<- :key 3)
    => Eroor
最初の一文字が`:`から始まっている場合は恒等変数と見做される。
この性質から、多言語のenumの用途で使用することがある。
## グローバル変数
最上位の環境で定義された変数をグローバル変数という。
グローバル変数はどの環境からでも参照ができる。
グルーバル変数名称は`$`から始めることが推奨される。
    $globalVariable
## 定数
Parenには言語機能として定数は存在しない。
そのため、定数として扱いたい変数を定義する場合、
Parenではすべて大文字の変数を使用することが推奨される。
この場合、字句の区切りにはアンダースコアを入れる。
    (<- PI 3.141592
        MAX_BUF_SIZE 256)
    => 256
定数を保護する機構はないので注意が必要である。
    (<- PI 3)
    => 3

## 真偽値
Parenの真偽値は先に述べた恒等変数を用いて表現される。
    恒等変数 真偽値
    ---------------
    :t       真
    :nil     偽
ただし、:tは真を表す代表の値で、
実際には、:nil以外の値はすべて真と見做される。

# 数値
## 評価
数値は評価されると、自身を返す。
    3
    => 3
    3.333
    => 3.333
Parenではすべての実数が数値型として扱われる。
## 代数演算子
Parenには次の代数演算子がある。
    演算子  処理
    -----------
    +      加算
    -      減算
    *      乗算
    /      除算
    **     冪乗
    //     切り捨て除算
    mod    余り
使用例を示す。
    (+ 3 4 5)
    => 12
    (- 10 4 5)
    => 1 ; <=> (- (- 10 4) 5)
    (* 3 4 5)
    => 60
    (/ 3 4 5)
    => 0.15
    (/ 3)
    => 0.33333
    (** 2 3)
    => 8
    (// 5 4)
    => 1
    (mod 6 4)
    => 2
前置記法の恩恵により、
Parenの四則演算は一つのオペレータで複数の値を処理できる。
## 代入演算子
Parenには次の代入演算子が定義されている。
    演算子 処理
    --------------------------------------------
    +!     第一引数に+を実行した結果を代入する。
    -!     第一引数に-を実行した結果を代入する。
    /!     第一引数に/を実行した結果を代入する。
    *!     第一引数に*を実行した結果を代入する。
    (+! a 3)
    <=> (<- a (+ a 3))
    (-! a 3)
    <=> (<- a (- a 3))
    (*! a 3)
    <=> (<- a (* a 3))
    (/! a 3)
    <=> (<- a (/ a 3))

# 文字列
Parenでは、ダブルクォートで囲まれた文字の列が文字列と見做される。
文字列は評価されると自身を返す。
    "Hello Paren"
    => "Hello Paren"
## 文字列の結合
文字列の結合は数値の加算と同じ組み込み関数+を用いる。
    (+ "Hello" "Paren")
    => "Hello Paren"
## 文字列の長さの取得
文字列の長さを取得するには組み込み関数のlengthを使用する。
    (length "Hello Paren")
    => 11
## 部分文字列の取得
部分文字列を取得するにはsubStringを使用する。
    (subString "Hello Paren" 6)
    => "Paren"
    (subString "Hello Paren" 0 5)
    => "Hello"
第一引数のみ指定されている場合はその値以降の部分文字列を取得する。
第二引数まで指定してある場合は、
第一引数から第二引数の値の前までの部分文字列を取得する。
ただし、どちらの場合も零から数える。
## 文字列の比較
文字列の比較は比較演算子`=`で行う。
    (= "Hello Paren" "Hello Paren")
    => :t
    (= "Hello Paren" "hello paren")
    => :nil
## 部分文字列が含まれるか判定
部分文字列が含まれているかどうか判定するにはinclude?を使用する。
    (include? "Hello Paren" "Hello")
    => :t
    (include? "Hello Paren" "hello")
    => :nil
## 文字列の先頭がある部分文字列と一致するか判定
startWith?は文字列が特定の文字列で始まっているかを判定する。
    (startWith? "Hello Paren" "Hello")
    => :t
    (startWith? "Hello Paren" "hello")
    => :nil
## 文字列の末尾がある部分文字列と一致するか判定
endWith?は文字列が特定の文字列で終了しているか判定する。
    (endWith? "Hello Paren" "Paren")
    => :t
    (endWith? "Hello Paren" "Hello")
    => :nil
## 正規表現
Parenで正規表現を使用したい場合は:Regexモジュールをインクルードすること。
説明はそちらのドキュメントに譲る。

# リスト
リストはParenにおいて最も重要なデータ構造であり、
同時にParenを記述するプログラムでもある。
## コンスの作成
リストを理解するためにはコンスを知る必要がある。
コンスとはParenのデータへのポインタを二つ持ったデータ構造である。
二つのポインタが指す領域のうち、
片方をcar、もう一方をcdrと呼ぶ。
コンスは組み込み関数consにより作ることができる。
consの第一引数、第二引数が、それぞれ作成されるコンスのcarとcdrにあたる。
    (cons 1 :nil)
    => (1)
    (cons 1 (cons 2 :nil))
    => (1 2)
    (cons (cons 1 :nil) (cons 2 :nil))
    => ((1) 2)
コンスの印字表現に違和感を覚えるかもしれない。
Parenはコンスを次のように印字する。
1. 左括弧を印字
2. そのコンスのcarが指す値を印字
3. そのコンスのcdrが指す値がコンスならcdrを辿り2へ、そうでなければ3を行う
4. 右括弧を印字
このことは図を描くと分かりやすいかもしれない。
    (cons 1 (cons 2 :nil))
    => (1 2)
    |car cdr|
      |   |
      1   |
          |
        |car cdr|
          |   |
          2   |
              |
             :nil
ここで、コンスの厳密な定義を与える。
1. コンスはParenのデータへの二つのポインタcar、cdrをもつ
2. carは任意のParenのデータを指せる
3. cdrはコンスまたは:nilを指せる
定義より、cdrがコンスまたは:nil以外を指すようなコンスは作れない。
    (cons 1 2)
    => Error
コンスのcdrで辿れるコンス全体のことをリストという。
これは、辿れるコンス全体が単方向リストのデータ構造と見做せるからである。
下に、その対応関係を示す。
    値   意味
    ---------------------------------------------
    cons 単方向リストのセル
    car  単方向リストが格納するデータへのポインタ
    cdr  次の単方向リストのセルへのポインタ
    :nil 単方向リストの終端
単方向リストとの類似もあり、:nilのことを特に空のリストという。
実際に、Parenのリスト操作関数は:nilが空のリストであるように振舞う。
Parenには引数がリストか判定する関数list?があるが、:nilもリストと見做される。
    (list? (cons 1 :nil))
    => :t
    (list? 3)
    => :nil
    (list? :nil)
    => :t
あるコンスのcdrを辿っていった終端が:nilを指している場合、
そのコンス全体は純リストであるという。
制約により、Parenの任意のリストはすべて純リストである。
純リスト以外のリストが作れないという制約は
ほかのLisp系の言語と比べると奇妙かもしれない。
これは、あるリスト操作関数は純リストにしか対応していない、
などというようなことが起こらないようにするための仕様である。
最後に、Parenには引数がコンスか判断する関数cons?がある。
    (cons? 1)
    => :nil
    (cons? (cons 1 :nil))
    => :t
    (cons? :nil)
    => :nil
## コンスの指す先へ
コンスが指す二つのポインタcar、cdrの指す場所を得る関数があり、
それぞれcarとcdrという。
    (<- lis (cons 1 (cons 2 :nil)))
    => (1 2)
    (car lis)
    => 1
    (cdr lis)
    => (2)
    (car (cdr lis))
    => 2
carとcdrは引数が空のリストの場合は:nilを返す。
    (car :nil)
    => :nil
    (cdr :nil)
    => :nil
    (car (cdr (cdr lis)))
    => :nil
carとcdrを組み合わせることは頻繁にあるため、
計五回までリストを辿るすべての組み合わせが定義されている。
    (cadr lis)
    => 2
    (cddr lis)
    => :nil
    (caddr lis)
    => :nil
## リストの作成
リストは関数consにより作られるが、
複数の要素を持つようなリストを作ろうとすると、すぐに困ったことになる。
    (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 :nil)))))
    => (1 2 3 4 5)
そのため、Parenにはそのための関数listが存在する。
    (list 1 2 3 4 5)
    => (1 2 3 4 5)
コンスの定義より、ネストしたリストも作成することもできる。
    (list (list 1 (list 2 3) 4 5))
    => ((1 (2 3)) 4 5)
## リストの評価
既に説明した文字列、数値、変数等はリストではない。
これらをリストに対して、アトムと呼ぶ。
ParenはS式によって記述されると述べたが、
S式とはアトム又はリストのことをいう。
つまり、Parenはアトム又はリストによって記述されることに他ならない。
プログラムである以上、S式は評価されなければならない。
アトムの評価方法については都度その項目で述べてきた。
リストの評価方法については明示的に述べることはなかったが、
すべてこの形式であったはずである。
    (オペレータ 第一引数 第二引数 ...)
リストはまず最初に、その第一要素が評価される。
第一要素がリストであっても構わない。
その場合は再帰的に処理が行われる。
次に、その評価結果である、オペレータの種類により処理が分かれる。
第一要素の評価結果がオペレータ出なかった場合はエラーとなる。
    (1 2 3)
    => Error
オペレータには大きく次の種類がある。
- スペシャルフォーム
- 関数
- マクロ
後の項で各オペレータについての評価方法を述べる。

# 関数
関数はParenの根幹をなすデータ型である。
ただし、この文書内における関数という単語は、
計算幾何学における手続き(サブルーチン)程度の意味しかない。
## 関数の定義
関数を定義するにはマクロdefを用いる。
次に、与えられた引数を二倍した値を返す関数を定義する例を示す。
    (def double (x)
      (* 2 x))
defの第一引数は定義する関数の名前であり、ここではdoubleとした。
第二引数は定義する関数の仮引数のリストとなる。
ここでは必須の引数を一つ受け取るのでその仮引数名をxとした。
仮引数のリストには後述するいくつかの指定方法がある。
第三引数以降は関数の本体のリストである。
関数の本体は左から順に逐次実行される。
## 関数呼び出し
定義した関数を呼び出すには、呼び出したい関数が第一要素、
その関数に渡したいi番目の引数がi + 1番目の要素であるようなリストを評価する。
先に定義したdoubleを呼び出す例を示す。
    (double 3)
    => 6
    (double 4)
    => 8
第一要素が関数であるようなリストの評価は次の順で行われる。
1. リストの第一要素を評価する。(今考えているのはこの評価結果が関数である)
2. リストの第二要素以降を番号を若い順に評価する。
3. 関数の実引数として、第二要素以降の評価結果を渡す。
4. 関数の本体が実行される。
## 仮引数の定義
関数を定義するときに指定する仮引数にはいくつか種類がある。
1. 必須パラメーター
2. オプショナルパラメーター
3. レストパラメーター
4. キーワードパラメーター
任意のパラメーターを同時に組み合わせて指定することができるが、
同時に指定する際は、上の順番で指定しなければならない。
### 必須パラメーター
必須パラメーターは変数により指定される。
指定したパラメーターは必須となり、
関数呼び出し時に実引数が足りない場合はエラーとなる。
    (double 2)
    => 4
    (double)
    => Error
    (def avg2 (x y)
      (/ (+ x y) 2))
    (avg 2 4)
    => 3
    (avg 2)
    => Error
### オプショナルパラメーター
オプショナルパラメーターは引数に初期値を与える仕組みである。
呼び出し時に省略された場合はその初期値が使用される。
仮引数に`:opt`が出現した以降の値がオプショナルパラメーターとして扱われる。
オプショナルパラメーターは変数名とその初期値をリストで指定する。
    (def incN (x :opt (x 1))
      (+ x adding))
    (incN 3)
    => 4
    (incN 3 2)
    => 5
初期値が:nilであるようなオプショナルパラメーターは、
オプショナルパラメーター名だけ指定することができる構文糖がある。
そのため、次の二つの関数は等価である。
    (def opt1 (:opt (x :nil)) x)
    (def opt2 (:opt x) x)
また、別のパラメーターが出現するまで複数指定することができる。
    (def concat (s1 :opt s2 s3)
      (+ s1 (if (nil? s2) ""
                (if (nil? s3) s2
                    (+ s2 s3)))))
    (concat "Hello")
    => "hello"
    (concat "Hello" "World")
    => "HelloWorld"
    (concat "Hello" "World" "!!")
    => "HelloWorld!!"
ただし、オプショナルパラメーターを複数指定する場合に、
i番目のオプショナルパラメーターを指定して関数を呼びたい場合は、
i - 1番目までのオプショナルパラメータをすべて指定する必要がある。
### レストパラメーター
レストパラメーターは関数を可変長引数にするための仕組みである。
仮引数に`:rest`が指定された直後の変数をレストパラメーターに束縛する。
レストパラメーターは二つ以上指定することはできない。
下に示すように仮引数よりも余分な実引数が、
リストとして実行時にレストパラメーターに束縛される。
    (def restTest (first :rest params)
      (list first params))
    (restTest 1 2 3)
    => (1 (2 3))
    (restTest 1)
    => (1 :nil)
### キーワードパラメーター
キーワードパラメーターとは、
仮引数の宣言順に依存しないで実引数を指定できるようにする仕組みである。
仮引数に`:key`が指定された以降の値がキーワードパラメーターとして扱われる。
宣言方法はオプショナルパラメーターと同じである。
    (def manyKey (:key (k1 0) (k2 0) (k3 0))
      (list k1 k2 k3))
    (manyKey)
    => (0 0 0)
    (manyKey :k1 1)
    => (1 0 0)
    (manyKey :k1 1 :k3 1)
    => (1 0 1)
初期値が:nilである場合の構文糖も使えることに注意せよ。
## 無名関数
プログラムを書いていると、定義してまで使う程での処理でもないが、
関数を作成したい場面があるかもしれない。
このような場合にはスペシャルフォームfnを使用できる。
    (fn 仮引数のリスト 関数の本体)
fnに与える引数は、名前を指定しないという点を除いてdefと全く同じである。
次の例は引数を足す関数を返す関数addNである。
    (def addN (n)
      (fn (x)
          (+ x n)))
    (<- add10 (addN 10))
    (add10 2)
    => 12
    ((addN 1) 2)
    => 3
実は、defが行っている処理はfnで作られた関数を、
第一引数で指定された名前の変数に代入しているだけなのである。
このことについては、後述するマクロの項で述べる。
## 汎関数
前述したように関数はParenの一つのデータ型にすぎない。
そのため、他のデータ型である数値や文字列と同様に、
変数に代入したり、関数に引数として渡したり、
関数の返り値として返したりすることができる。
ここで、関数全体の集合のうち、
引数に関数をとる、或いは、返り値が関数であるように定義された関数を、
汎関数または、高階関数という。
汎関数を用いることにより、高度な抽象化を用いることができる。
この例は既に前述の汎関数addNで見た。
## 再帰関数
関数全体の集合のうち、関数の本体で自分自身を呼ぶような関数を再帰関数と呼ぶ。
再帰関数を用いると直感的にプログラムできることがある。
再帰関数の例として整数nの階乗を求める関数factorialを示す。
    (def factrial (n)
        (if (= n 1) 1
            (* n (factorial (- n 1)))))
数学的には
    factorial(n) {
        1, (n = 1),
        n * factorial(n - 1), (n > 1).
と書けるが、
再帰関数を用いることにより、階乗の定義をそのまま書き下せていることが分かる。
また、再帰関数全体の集合のうち、
自身の呼び出しごとにスタックが積まれないような関数を末尾再帰関数という。
上記のfactorialは呼び出しごとにスタックが積まれていくため末尾再帰関数ではない。
factorialは次のような末尾再起関数に変換できる。
    (def factorial (n ? acc 1)
        (if (= n 1) acc
            (factorial (- n 1) (* acc n))))
## 純粋関数
関数全体の集合のうち、次の性質を持つものを特に純粋関数という。
- 任意の引数に対して、返り値が時間に依存せずに一意に定まる
- 他に何も影響を与えない
このような性質を参照透過性という。
また、二つ目の性質
> 他に何も影響を与えない
のことを副作用という。
次のような処理は副作用である。
- 代入
- 入出力
定義から、次のような関数は純粋関数ではない。
- あるグローバル変数の値の3倍の数を返す関数
- 引数を標準出力に印字する関数
- 引数の値を3倍に変更する関数
- 現在時刻をシードとした0か1の乱数を返す関数を返す関数
逆に、次のような関数は純粋関数である。
ただし、一連の処理には副作用はないこととする。
- 引数を返す関数
- 引数の文字列表現を返す関数
- 引数の値の3倍の値を返す関数
- 引数をシードとした0か1の乱数を返す関数を返す関数
可能な限りプログラムは純粋関数で構成することが望ましい。
これは、純粋関数は関数に比べてとりうる状態が少なく、
一般的に汎用的な処理になりバグも発生しにくいことによる。

# 条件分岐
Parenにはいくつか条件分岐をするための仕組みが存在する。
- if
- cond
- case
- when
- unless
- and
- or

# 反復
# 配列
# 連想配列
# 構造体
# スペシャルフォーム
スペシャルフォームはParenのS式の評価ルールに従わない、
フォームごとに異なる特別なルールで評価される。
スペシャルフォームには次の種類が存在する。
- <-
- let
- if
- begin
- quote
- fn
## <-(代入)
    <- = '(<-' assign_args* ')'
    assign_args = variable s_expr
`<-`は現在の環境から最も近い環境に存在する変数に値を代入する。
代入対象の変数が環境から見つからない場合は、
現在の環境に対象変数を登録し、値を設定する。
引数の数は偶数でなければならない。
左から順に2n番目の変数に2n + 1番目の値を代入される。
評価結果はそれ以降の評価に干渉する。
フォームは最後に評価(代入)された値を返す。
## let(変数束縛)
    let = '(let' '(' let_form+ ')'
              s_expr* ')'
    let_form = '(' variable s_expr ')' | variable | nil
`let`は新しく変数を束縛する。
束縛する変数が既に宣言されていても構わない。
第一引数が変数束縛フォームのリストを表す。
変数束縛フォームがシンボルの場合は
第二引数以降が、第一引数で束縛した変数の環境下にて暗黙のbeginにより評価される。
## begin(逐次実行)
    '(begin' s_expr+ ')'
beginは引数のフォームを左から順に評価していき、
最後のフォームの評価結果を返す。
## if(条件分岐)
    (if (< n 0) -1
        (= n 0) 0
        1)
`if`は条件分岐を実現するスペシャルフォームである。
第一引数の評価結果が真の場合は第二引数を、
そうでなければ第三引数の評価結果が真の場合は…
のように評価される。
C言語系の条件分岐との比較イメージを示す。
    if (n < 0) return -1;
    else if (n = 0) return 0;
    else return 1;
## quote(クォート)
    (quote expr)
`quote`はS式`expr`の評価を見送り、`expr`そのものを返す。
その利用頻度から構文糖であるリードマクロ`\``が定義されている。
## fn(無名関数)
    (fn (args) body)
`fn`は関数を生成する。
第一引数`args`が仮引数のリストである。
呼び出し時に実引数に束縛される。
    ((fn (x y z) (* (+ x y) z)) 1 2 3)
    => 9
`args`は関数の仮引数で、次のパラメーターを指定することができる。
1. 必須パラメーター
2. オプショナルパラメーター
3. レストパラメーター
4. キーワードパラメーター
すべてのパラメーターを同時に組み合わせて指定することができるが、
その順番は上のとおりに指定しなければならない。
### 必須パラメーター
    (fn (x y z) body)
必須パラメーターは変数のリストである。
指定したパラメーターは必須となり、
関数呼び出し時に実引数が足りない場合はエラーとなる。
### オプショナルパラメーター
    (fn (x ? y1 y2 z1 z2) body)
オプショナルパラメーターは実引数が渡されなかった場合は指定された初期値を用いる。
`?`の後の引数はオプショナルパラメーターと見做される。
オプショナルパラメーターは名称と初期値を対で指定する必要がある。
上の例では、`y1`、`z1`がオプショナルパラメーター名で、
その値の初期値がそれぞれ`y2`、`x2`となる。
オプショナルパラメーターを指定した関数は、
実引数の数が少ない場合に初期値が使用される。
### レストパラメーター
    (fn (x . y) body)
引数のリストに`.`が出現した場合はその次の値をレストパラメーターとする。
仮引数よりも余分な実引数がリストとして実行時にレストパラメーターに束縛される。
### キーワードパラメーター
    (fn (x :key1 val1 :key2 val2) body)
引数のリストにキーワードが出現した場合は、
その直後の値が対となるキーワードパラメーターと見做される。

# マクロ
マクロはParenが読み込まれ、リードマクロが展開された後に実行される。
この実行をマクロ展開という。
マクロはリードマクロ、マクロ、スペシャルフォーム、 関数等、
すべてのParenの機能を使用してユーザが定義することができる。
マクロは使用される前に定義がされている必要がある。
マクロ展開は、展開結果にマクロが含まれなくなるまで再帰的に行われる。
# リードマクロ

# その他
# 命名規約
Parenでの命名規約をまとめる。
これは言語機能により強制されるわけではなく、
あくまで推奨されるものである。
## 命名方法の定義
    命名方法       定義
    ----------------------------------------------------------------------------
    パスカルケース 単語の区切りの最初の一文字を大文字にする命名法
    キャメルケース 最初の一文字目を小文字にする点を除きパスカルケースと同じ
    スネークケース 単語の句切れをアンダースコアでつなぐ命名法
    チェインケース 単語の句切れをハイフンでつなぐ命名法
## 命名規約速見表
下に示す命名規約は推奨すべき命名方法であり、
場合によってはこの限りではない。
    対象            命名方法
    ----------------------------------------------------------------------------
    ファイル        スネークケース
    定数            すべて大文字のスネークケース
    ローカル変数    キャメルケース
    グローバル変数  `$` + キャメルケース
    クラス          パスカルケース
    恒等変数        `:`から始まるキャメルケース
                    (ただし、型を表す場合はパスカルケースとする。)
    述語            末尾に`?`を付ける
    破壊的処理      末尾に`!`を付ける
    束縛系のマクロ  withから始める
    構造体          パスカルケース
変数は何を格納するかにより、命名規約が異なるため注意が必要。
