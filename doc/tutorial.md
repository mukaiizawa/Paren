Parenチュートリアル

# 概要
このチュートリアルはParenの基本的な概念や文法を早巡りすることを目的とする。読者には計算機科学の初等的な知識があることを前提とし、いくつかの専門用語は定義することなしに使用している。

ParenはS式によって記述されるプログラミング言語Lispの方言である。

# 目次
- 書式
- 序章
- コメント
- 数値
- 文字列
- キーワード
- シンボル
- リスト
- 関数
- 条件分岐
- 反復
- 配列
- 連想配列
- スペシャルオペレーター
- マクロ
- リードマクロ
- 例外処理
- クラス
- 付録

# 書式
この文書内の書式は次の規則で記述してある。
    記号 定義
    ----------------------------------------
    [ ]  []内は省略可能
    { }  {}内から一つ選択
    |    []、{}内の代替候補の区切り文字
    ...  直前の構文の零回以上の繰り返し
    ::=  左辺を右辺で定義
    --   左辺の右辺による説明
    =>   左辺の評価結果は右辺

# 序章
この章ではいくつかの簡単なプログラムを示すことを目的とする。

## Parenの実行
parenを起動するとreplが実行される。
    $ paren
    ) 

`)`がプロンプトである。プロンプトに続けてプログラムを記述すると評価され結果が印字される。
    ) 1
    1
    ) (+ 1 2 3 4)
    10
    ) (* (+ 1 2) 3 4)
    36

Parenのプログラムは演算子を前置し、被演算子と共に括弧で括る。このように演算子を前置する記法をポーランド記法乃至、前置記法といい、Parenの特徴の一つである。

## hello world
あるプログラミング言語を習得する唯一の方法は、その言語でプログラムを書くことである。そしてそれは、慣習により次のプログラムを書くことから始まる。
    次の文字列を印字せよ。
    hello world

文字列を印字するにはwrite_lineを使用する。
    ) (write_line "hello world")
    hello world
    "hello world"

write_lineの評価すると二行出力される。一行目がwrite_lineがコンソールへ印字した文字列であり、二行がwrite_lineの評価結果をreplが印字したものである。

すべての式はwrite_lineのように必ず値を返す。この仕様はParenの特徴の一つである。

## 複写関数
もうひとつの例として標準入力から標準出力に複写する関数copyを作成する。
    ; copy 第一版
    (function copy ()
      (let ((ch nil))
        (while ((/= ch :EOF))
          (<- ch (read_byte))
          (write_byte ch))))

関数を定義するにはfunctionマクロを使用する。例ではcopyという引数がない関数を定義している。

関数の本体では、read_byteで取得したバイトでシンボルchを束縛している。その後、chを参照してwrite_byteで標準出力に書き出している。

このプログラムは、
    Parenのすべての式は評価されると値を返す。

という性質を用いてより簡潔に書ける。束縛オペレータ―はシンボルに束縛した値を返す。その性質を利用した版を以下に示す。
    ; copy 第二版
    (function copy ()
      (let ((ch nil))
        (while ((/= (<- c (read_byte)) :EOF))
          (write_byte ch))))

ただし、返り値を濫用するプログラムは可読性を下げることがあるため注意が必要である。

# コメント
コメントはParenに無視されるため、プログラムの補足事項等を自由に記述することができる。

## 一行コメント
Parenは`;`から行末までをコメントと見做す。これを一行コメントと呼ぶ。
    ; 一行コメント
    ;; これも一行コメント

## 複数行コメント
Parenには複数行に跨がれるコメントは言語仕様として存在しない。ただし、複数行に跨がるコメントが必要になった場合は後述するリードマクロで容易に定義できる。

# 数値
Parenではすべての実数は数値型として扱われる。

## 数値リテラル
数値リテラルの書式を示す。
    [base x] number
    base -- 基数
    number -- 実数

基数は省略可能で、指定しない場合は10進数と見做される。また、基数に0を指定した場合は16進数と見做される。

## 評価
数値は評価されると自身を返す。
    ) 10
    10
    ) 3.141592
    3.141592
    ) 2x1010
    10
    ) 0x14
    10

## 算術関数
代表的な算術関数を次に示す。
    関数  処理
    -------------------
    +     加算
    -     減算
    *     乗算
    /     除算
    **    冪乗
    //    切り捨て除算
    mod   余り

これらの評価例を示す。
    ) (+ 3 4 5)
    12
    ) (- 10 4 5)
    1
    ) (* 3 4 5)
    60
    ) (/ 3 4 5)
    0.15
    ) (/ 3)
    0.33333
    ) (** 2 3)
    8
    ) (// 5 4)
    1
    ) (mod 6 4)
    2

# 文字列
文字列は文字列リテラルや組み込みのto_str関数等で作成できる。

## 文字列リテラル
文字列は評価されると自身を返す。文字列リテラルはダブルクォートで囲まれた文字の列である。
    ) "hello paren"
    "hello paren"

## 文字列の作成
オブジェクトから文字列を作成するにはto_strを使用する。to_str関数はParenのオブジェクトの表現を文字列として取得する。
    ) (to_str 123)
    "123"

## 文字列の結合
文字列の結合は+を使用する。
    ) (+ "hello" "_" "paren")
    "hello_paren"

## 文字列の長さの取得
文字列の長さを取得するには組み込み関数のlengthを使用する。
    ) (length "hello paren")
    11

## 部分文字列の取得
部分文字列を取得するにはsubseqを使用する。
    ) (subseq "hello paren" 6)
    "paren"
    ) (subseq "hello paren" 0 5)
    "hello"

第一引数のみ指定されている場合はその値以降の部分文字列を取得する。第二引数まで指定してある場合は、第一引数から第二引数の値の前までの部分文字列を取得する。ただし、どちらの場合も零から数える。

## 文字列の比較
文字列の比較は比較関数`=`で行う。
    ) (= "hello paren" "hello paren")
    true
    ) (= "Hello Paren" "hello paren")
    false

## 部分文字列が含まれるか判定
部分文字列が含まれているかどうか判定するにはinclude?を使用する。
    ) (include? "Hello Paren" "Hello")
    true
    ) (include? "Hello Paren" "hello")
    false

## 文字列の先頭がある部分文字列と一致するか判定
start_with?は文字列が特定の文字列で始まっているかを判定する。
    ) (start_with? "Hello Paren" "Hello")
    true
    ) (start_with? "Hello Paren" "hello")
    false

## 文字列の末尾がある部分文字列と一致するか判定
end_with?は文字列が特定の文字列で終了しているか判定する。
    ) (end_with? "Hello Paren" "Paren")
    true
    ) (end_with? "Hello Paren" "Hello")
    false

## 正規表現
Parenで正規表現を使用したい場合は:Regexモジュールをインクルードする。

詳細は:Regexモジュールのドキュメントを参照のこと。

# キーワード
キーワードは同名であるならばプログラムでただ一つだけ存在するという性質を持つオブジェクトである。アドレス比較で同一か判定可能なため列挙等に使用される。

キーワードを取得するためには次のいずれかの方法を用いる。
- キーワードリテラルを使用する
- to_key関数を使用する

## キーワードリテラル
キーワードリテラルは`:`から始まる英数字と一部の記号の列である。
次のいずれも有効なキーワードリテラルである。
    :0123
    :keyword_literal

厳密な仕様については言語仕様書の字句定義の章を参照のこと。

## to_key関数
to_key関数は文字列を受け取り、それに対応するキーワードを返す。
    ) (to_key "key")
    :key

## キーワードの評価
キーワードは評価されると自身を返す。
    ) :key
    :key

# シンボル
シンボルは任意のParenオブジェクトへの参照を保持するためのオブジェクトである。既に述べた数値や文字列の他、関数やリストやシンボルなどもParenのオブジェクトであるため、シンボルで参照を保持することができる。

## シンボル名
Parenのシンボル名は数字以外の英文字と一部の記号から始まり、その後、英数字と一部の記号が続く。

次のいずれもParenのシンボル名として有効である。
    var
    x1

シンボル名で使用できる文字の厳密な定義は言語仕様書の字句解析の章を参照されたい。

シンボル名が複数の単語で構成される場合は、単語の区切れをアンダースコアで区切る。

    user_name
    neighbor_node

## 環境
シンボルの保持するオブジェクトへの参照は環境で管理されている。

環境とは、一つのシンボルテーブルと零又は一つの環境への参照の対のことをいう。ここで、シンボルテーブルとはシンボルとオブジェクトへの参照の対の集合のことをいう。ただし、シンボルテーブルに存在する同一シンボルは高々一つである。

環境の持つ環境への参照の実体を親の環境という。これに対して、ある親の環境の参照元の環境を子の環境という。

Parenには親の環境が存在しないような環境が一つだけ存在する。この環境のことを大域環境という。

ある環境EのシンボルテーブルTにシンボルSとオブジェクトへの参照Pの対(S, P)が存在しているとき、EにSがPで束縛されているという。また、Tに対(S, P)を追加することを、EにSをPで束縛するという。これは、単にSをPで束縛する、乃至、Sを束縛するともいう。

式が評価される場合、必ずどこかの環境の下で評価される。Parenを起動した直後の環境は大域環境である。

## シンボルの評価
シンボルは評価されると、保持しているオブジェクトへの参照の実体を返す。ただし、シンボルの評価結果は評価される環境によって変わりうる。
シンボルの評価は次の手順で行われる。
    シンボルSが評価された環境EのシンボルテーブルにSが存在している場合、対応するオブジェクトへの参照の実体を返す。
    そうでなければEの親の環境に対して再帰的にシンボルテーブルの探索を行う。
    親の環境を辿っていき、大域環境のシンボルテーブルにSが存在しない場合はエラーとする。

このように、あるシンボルが保持するオブジェクトへの参照は、どの環境下でシンボルが評価されたのか考えなければ意味がない。

例えば、前述した`+`は大域環境に束縛されているシンボルの一つであり、評価されることによって引数の和を計算する関数が返されていたことになる。

## シンボルの束縛
シンボルを束縛するには束縛オペレーターを使用する。束縛オペレーターにはその用途から二種類されている。
    (<- variable_value ...) => result
    (<-- variable_value ...) => result
    variable_value ::= var val
    var -- シンボル
    val -- シンボルが保持するオブジェクトの参照の実体
    result -- 最後に束縛した値

`<-`は、現在の環境にシンボルが束縛されている場合はシンボルテーブルの値を更新する。そうでなければ、親の環境に対して再帰的に探索を続けてシンボルテーブルを更新する。大域環境にもシンボルが束縛されていない場合は、大域環境に新たにシンボルを束縛する。

`<--`は常に大域環境にシンボルを束縛する。大域環境にすでにシンボルが束縛されている場合はシンボルテーブルの値を更新する。

子の環境でシンボルを束縛すると、親の環境で同名のシンボルが束縛されている値が参照できなくなることからシンボルを隠すという。

シンボルを隠す行為は有用な用途があるためしばしば用いられる。

## 環境の作成
現在の環境を親にもつ環境を新しく作るにはマクロletを使用する。
    (let ([let_args ...]) [body ...]) => result
    let_args ::= { symbol (symbol value) }
    symbol -- 新しく作成する環境に束縛するシンボル
    value -- シンボルを束縛する値
    body -- 新しく作成する環境で評価する式
    result -- 新しく作成した環境で最後に評価した式の評価結果

letは新しく環境を作成し、第一引数のシンボルを束縛する。第二引数以降は作成した環境内で式を評価する。

letはマクロで定義された、環境という概念を意識した構文糖に過ぎない。このことについては後述する。

## グローバルシンボル
大域環境に束縛されたシンボルのことをグローバルシンボルという。グローバルシンボルは隠されない限り、すべての環境から参照できる。

慣習として、ほかのシンボルと区別がつきやすいようにグローバルシンボル名は次のように`$`から始める。
    $global_var

## 特殊なシンボル
システムであらかじめ組み込まれている、参照しかできない特殊なシンボルが存在する。

これらは大域環境に束縛されていて、再束縛が禁止されているためどこからでも参照ができる。
    シンボル 意味
    --------------------------------------
    true     真の代表値
    false    偽の代表値
    else     真の代表値(trueのalias)
    nil      空の代表値

## 定数
Parenでは言語機能として定数は存在しない。その代わりに、シンボルを定数として扱いたい値で束縛して用いる。この用途で使用するシンボルは他のシンボルと見分けがつくように慣習としてすべて大文字のシンボル名を使用する。
    ) (<-- PI 3.141592)
    3.141592

これらのシンボルを定数の用途として機能させるには、プログラマが注意を払わなければならない。
    ) (<- PI "pi")    ; 誤り
    "pi"

# リスト
リストはParenにおいて最も重要なデータ型であると同時に、Parenを記述するプログラムでもある。

## コンス
コンスとは、任意のParenオブジェクトへの参照carと、コンスまたはnilへの参照cdrの対のことをいう。

リストとは、コンスのcdrで辿れる全体、または、nilのことをいう。コンスはリストのノードであり、carはデータへの参照、cdrは次のノードへの参照であり、nilで終端している。リストとして空の代表値nilを扱う場合には、特に空のリストということがある。

あるコンスのcdrを辿っていった終端がnilを指している場合、そのコンス全体は純リストであるという。コンスの定義により、Parenの任意のリストはすべて純リストである。純リスト以外のリストが作れないという制約はほかのLisp方言と異なる特徴の一つとなる。

コンスは組み込み関数consで作ることができる。consの第一引数、第二引数が、それぞれ作成されるコンスのcarとcdrに対応する。ただし、コンスの定義にあてはまらない引数をconsに与えるとエラーとなる。
    ) (cons 1 nil)
    (1)
    ) (cons 1 (cons 2 nil))
    (1 2)
    ) (cons (cons 1 nil) (cons 2 nil))
    ((1) 2)

Parenはコンスを印字するときにコンスのcdrで辿れる全体、つまり、リストとして印字する。

リストは次の規則で印字される。
1. 左括弧を印字
2. carが指す値を印字する
   cdrが指す値がnilなら3を行う
   そうでなければ、再びcdrが指すコンスに対して2を行う
3. 右括弧を印字

    ) (cons 1 (cons 2 (cons 3 nil)))
    (1 2 3)

    +-----+-----+
    | car | cdr |
    +-----+-----+
       |     |    +-----+-----+
       |     +--->| car | cdr |
       |          +-----+-----+
       |             |     |    +-----+-----+
       |             |     +--->| car | cdr |
       |             |          +-----+-----+
       |             |             |     |
       |             |             |     +---> nil
       1             2             3

あるコンスのcarがコンスを指している場合でもそのルールは再帰的に適用される。
    ) (cons (cons 1 nil) (cons 2 (cons 3 nil)))
    ((1) 2 3)

    +-----+-----+
    | car | cdr |
    +-----+-----+
       |     |    +-----+-----+
       |     +--->| car | cdr |
       |          +-----+-----+
       |             |     |    +-----+-----+
       |             |     +--->| car | cdr |
       |             2          +-----+-----+
       |                           |     |
       |    +-----+-----+          |     +---> nil
       +--->| car | cdr |          3
            +-----+-----+
               |     |
               |     +---> nil
               1

任意のリストはcons関数で作ることができるが、複数の要素を持つようなリストを作ろうとすると、すぐに困ったことになる。
    ) (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 nil)))))
    (1 2 3 4 5)

そのため、Parenには引数を要素に持つようなリストを作成するための関数、
listが存在する。
    (list [arg ...])
    arg -- リストの要素

次のように、要素を引数にしてリストを作成できる。
    ) (list 1 2 3 4 5)
    (1 2 3 4 5)

リストの定義により、要素がリストであるようなリストも作成することもできる。
    ) (list (list 1 (list 2 3) 4 5))
    ((1 (2 3)) 4 5)

## carとcdrの参照
コンスが指す二つのポインタcar、cdrの指す場所を得る関数があり、
それぞれcarとcdrという。
    ) (list 1 2)
    (1 2)
    ) (car (list 1 2))
    1
    ) (cdr (list 1 2))
    (2)
    ) (car (cdr (list 1 2)))
    2

carとcdrは引数が空のリストである場合はnilを返す。
    ) (car nil)
    nil
    ) (cdr nil)
    nil
    ) (car (cdr (cdr (list 1))))
    nil

リストの要素を参照するときにcarとcdrを組み合わせることは頻繁にあるため、計四回までリストを辿るすべての組み合わせが定義されている。
    caar cadr cdar cddr
    caaar caadr cadar caddr cdaar cdadr cddar cdddr caaaar
    caaadr caadar caaddr cadaar cadadr caddar cadddr cdaaar cdaadr cdadar
    cdaddr cddaar cddadr cdddar cddddr

これらの関数については合成規則が分かるような等価な式を例示することにとどめる。
    (caar lis) <=> (car (car lis))
    (caddr lis) <=> (car (cdr (cdr lis)))
    lis -- 引数のリスト

## carとcdrへ代入
コンスのcarとcdrが指す場所を変更するには、それぞれcar、cdr関数の第二引数に値を指定する。
    ) (car (list 0 0 0) 1)
    1

これはすべての操作関数について成り立つ。
    ) (cdddr (list 0 1 2) (list 3 4 5))
    (0 1 2 3 4 5)

cdrが指す値を書き換える際、純リストでなくなるような代入はできない。

## リストの評価
ParenはS式によって記述される。S式とはアトム又はリストのことをいう。リスト以外のオブジェクトのことを総称してアトムという。
    S式
      - アトム
        - シンボル
        - 数値
        - 文字列
        - 配列
        - 関数
        - マクロ
      - リスト

S式は評価されると値を返す。

シンボルは評価されるとS式を返す。

シンボル以外のアトムは評価されると自身を返す。

リストは、まず最初に第一要素が評価される。リストの第一要素はリストであっても構わず、その場合は再帰的に処理が行われる。ここでは、第一要素の評価結果をオペレーターと呼ぶ。
    (operator [arg ...])
    operator -- オペレーター
    arg -- オペレーターに渡る引数

オペレーターが次のいづれかである場合はこのリストを評価可能なS式という。
- 関数
- スペシャルオペレーター
- マクロ

評価可能なS式でなかった場合はエラーとなる。そうでない場合はオペレーターの種類に従って評価が行われる。

### 関数
オペレーターが関数の場合、すべての引数を評価し、その結果を関数に渡して評価する。
    ) (+ 1 (* 2 3))
    7

上記の例では二つの関数`+`、`*`のそれぞれの引数`1`と`(* 2 3)`、`2`と`3`はそれぞれ評価されてから関数が評価されている。

### スペシャルオペレーター
スペシャルオペレーターはParenに組み込まれている特殊なオペレーターで、オペレーター毎に引数の扱いが異なる。詳しくはスペシャルオペレーターの章で述べる。

### マクロ
オペレーターがマクロの場合、すべての引数を評価することなしに、マクロに渡して評価する。ただし、マクロの定義のされ方によっては引数が評価されているようにも見える。詳しくはマクロの章で述べる。

そのため、オペレーターの定義を見ることなしに引数の扱われ方だけで、マクロかスペシャルオペレーターか関数か判断できないこともある。このことは、他の非Lisp系の言語と異なりParenのマクロはParenと別な言語ではなく、Parenに調和した自然な拡張(実際はParenそのものともいえる)であることを意味する。

## プログラムとデータ
既に述べたようにParenのプログラム、つまりS式はParenのデータである。

一方で、Parenのデータのうち、評価可能なS式はParenのプログラムである。

データとプログラムが相互に変換可能であるという事実は、プログラムを書くプログラムを書きやすくする。実際、マクロはこの事実を上手く利用した機能であり、Parenを強力な言語にしている。

実際に、次の式のように評価結果が評価可能なS式であるようなS式は簡単に思いつく。
    ) (list + 1 2 3)
    (+ 1 2 3)

ここで垣間見た可能性についてマクロの章で詳しく述べる。

# 関数
関数はParenの根幹をなすオブジェクトである。関数は柔軟な仮引数を定義することができる。

この文書内における関数という単語は、計算機科学における手続き程度の意味しかない。

## 関数の定義
関数を定義するにはマクロfunctionを用いる。
    (function function_name ([var ...
                               [:opt var_value ...]
                               [:rest var]
                               [:key var_value ...]])
        [body ...])
    var_value ::= {var | (var value)}
    function_name -- 定義する関数名
    var -- 仮引数名
    value -- 仮引数の初期値
    body -- 関数本体

functionは与えられた名前の関数を定義し、その関数を返す。
    ) (function double (x) (* 2 x))
    double
    ) (double 4)
    8

## 関数呼び出し
既に説明したように、関数を呼び出すには関数とその引数をリストにして評価する。
    ) (double 3)
    6
    ) (double 4)
    8

関数の実引数が仮引数に束縛できない場合はエラーとなる。関数の実引数の評価は必ず左から順に評価される。

## 仮引数
仮引数には次の種類がある。
1. 必須パラメーター
2. オプショナルパラメーター
3. レストパラメーター
4. キーワードパラメーター

任意の仮引数を同時に組み合わせることができるが、その場合は上の順番で指定しなければならない。

### 必須パラメーター
必須パラメーターは関数呼び出し時に必ず与えなければならない仮引数を定義する。

関数呼び出し時に必須パラメーターが足りない場合はエラーとなる。
    ) (function avg2 (x y)
        (/ (+ x y) 2))
    ) (avg 2 4)
    3

### オプショナルパラメーター
オプショナルパラメーターは関数呼び出し時に省略可能な仮引数を定義する。仮引数の`:opt`句にシンボル名と初期値をリストにして指定する。

関数呼び出し時にオプショナルパラメーターが省略された場合は初期値が使用される。
    ) (function x_add_y (x :opt (y 1))
        (+ x y))
    x_add_y
    ) (x_add_y 3)
    4
    ) (x_add_y 3 2)
    5

オプショナルパラメーターが初期値なしで定義された場合は、初期値としてnilを指定したものと見做される。

そのため次の二つの関数の仮引数は等価である。
    (function f1 (:opt x) expr)
    (function f2 (:opt (x nil)) expr)

オプショナルパラメーターは複数定義することもできる。
    ) (function concat (s1 :opt (s2 "") (s3 ""))
        (+ s1 s2 s3))
    ) (concat "hello")
    "hello"
    ) (concat "hello" " world")
    "hello world"
    ) (concat "hello" " world" "!!")
    "hello world!!"

ただし、あるオプショナルパラメーターを指定して関数を評価したい場合は、それ以前のオプショナルパラメーターはすべて明示的に指定する必要がある。

### レストパラメーター
レストパラメーターは可変長な実引数を受け取る仮引数を定義する。仮引数の`:rest`句に可変長引数を定義する。

関数呼び出し時に仮引数よりも多い実引数がリストとして束縛される。
    ) (function first_rest (first :rest rest)
        (list first rest))
    ) (first_rest 1 2 3)
    (1 (2 3))

レストパラメーターに束縛される実引数がない場合はnilが束縛される。
    ) (first_rest 1)
    (1 nil)

### キーワードパラメーター
キーワードパラメーターは、順序を問わない名前付きの仮引数を定義する。仮引数の`:key`句に指定する。

キーワードパラメーターには初期値を与えることができ、呼び出し時にキーワードパラメーターが省略された場合は初期値が使用される。キーワードパラメーターが初期値なしで定義された場合は初期値にnilを指定したものと見做される。
    ) (function test_key (:key (k1 1) (k2 2) k3)
        (list k1 k2 k3))
    test_key
    ) (test_key)
    (1 2 nil)
    ) (test_key :k1 -1)
    (-1 2 nil)

次のように、キーワードパラメーターの仮引数の順序と実引数の順序は一致しなくてもよい。
    ) (test_key :k3 3 :k1 -1)
    (-1 2 3)

## 汎関数
前述したように関数はアトムの種類の一つに過ぎない。そのため、他のデータ型である数値や文字列と同様に、シンボルに束縛させたり、関数に引数として渡したり、関数の返り値として返したりすることができる。

関数全体の集合のうち関数を引数に受け取る、または、返り値が関数であるように定義された関数を汎関数という。

## 汎関数ユーティリティ
Parenに組み込みで用意されている汎関数をいくつか示す。汎関数を用いることにより、高度な抽象化を用いることができる。
### リストを写像する
mapは引数のリストを写像した結果を返す汎関数である。
    (map fn list ...) => result
    fn -- 写像関数
    list -- 写像前のリスト
    result -- 写像後のリスト

次の例は、引数のリストを二倍する。
    ) (function double (* 2 x))
    double
    ) (map double (list 1 2 3))
    (2 4 6)

### リストをグルーピングする
group_byは指定した関数が返した結果でグルーピングする。
    (group_by fn list) => result
    fn -- グループ分けするカテゴリを返す関数
    list -- グループ分けするリスト
    result -- グルーピングされたリスト

次の例は、引数のリストを絶対値ごとにグルーピングする。
    ) (group abs (list -1 1 2 -3 3))
    ((1 -1 1) (2 2) (3 -3 3))

### リストから要素を取り除く
remove_ifは引数のリストの要素のち、関数が真を返す要素を取り除いたリストを返す。
    (remove_if fn list) => result
    fn -- 要素を取り除くか決める関数
    list -- 要素を取り除く対象のリスト
    result -- 要素を取り除いた後のリスト

次の例は、負の数を取り除いたリストを返す。
    ) (remove_if minus? (list 0 1 -2 3))
    (0 1 3)

## 再帰関数
関数全体の集合のうち、関数の本体で自分自身を呼ぶような関数を再帰関数と呼ぶ。

再帰関数を用いると直感的にプログラムできることがある。典型的な例として整数nの階乗を求める関数factorialを示す。
    (function factorial (n)
        (if ((= n 1) 1)
            (else (* n (factorial (- n 1))))))

これはfor文を用いるより、直感的である。
    (function factorial (n)
      (let ((result n))
        (while ((/= n 1) result) (*= reult (-- n)))))

また、再帰関数全体の集合のうち自身の呼び出しごとにスタックが積まれないような関数を末尾再帰関数という。

上記のfactorialは呼び出しごとにスタックが積まれていくため末尾再帰関数ではない。

factorialは次のような末尾再起関数に変換できる。

    (function factorial (n :opt (acc 1))
      (if ((= n 1) acc)
          (else (factorial (- n 1) (* acc n)))))

## 純粋関数
次の性質を参照透過性といい、関数全体の集合のうち、この性質を持つものを純粋関数という。
- 任意の引数に対して、返り値が環境に依存せずに一意に定まる
- 他に何も影響を与えない

また、二つ目の性質
    他に何も影響を与えない
のことを副作用という。

次のような処理は副作用がある。
- 親の環境への束縛
- 入出力

定義から、次のような関数は純粋関数ではない。
- あるグローバルシンボルの値の3倍の数を返す関数
- 引数を標準出力に印字する関数
- 引数の値を3倍に変更する関数

逆に、次の処理を行うだけの関数は純粋関数である。
- 引数を返す関数
- 引数の文字列表現を返す関数
- 引数の値の3倍の値を返す関数

可能な限りプログラムは純粋関数で構成することが望ましい。

これは、純粋関数はそうでない関数に比べてとりうる状態が少なく、一般的に汎用的な処理になりバグも発生しにくいことによる。

# 条件分岐
Parenには条件分岐のマクロifが存在する。

## 真偽値
Parenは次にあげる値を除き、すべて真と見做される。
- false
- nil
- 0
- ""

## if
ifは汎用的な条件分岐処理を行うためのマクロである。
    (if [clause ...]) => result
    clause ::= (test [body_form ...])
    test -- 処理を行うか否かを表す真偽値
    body_form -- testが真のときに評価される式
    result -- clauseがない場合はnil
              そうでなければ最後に評価した式の評価結果

ifは評価する条件と評価する式のリストのリストとなっている。ifは最初の引数から、そのリストの先頭の要素を評価する。

評価結果が真の場合はそのリストの残りの要素を順に評価し、そうでなければ次の引数に対して同じことを行う。
    ) (function to_roman (x)
        (if ((= x 1) :one)
            ((= x 2) :tow)
            ((= x 3) :three)
            (true :more)))
    ) (roman 1)
    :one
    ) (roman 4)
    :more

if全体は条件式が真を返す引数があれば、そのリストの最後の要素の評価結果を返す。そうでなければfalseを返す。

最後の引数がデフォルトを表す節の場合は慣習としてelseを用いる。

## 三項演算子
`?`は条件分岐を行うスペシャルオペレーターである。前述のifは?を用いたマクロで定義されている。
    (? test then_form else_form) => result
    test -- 真偽値
    then_form -- testが真の場合に評価される式
    else_form -- testが偽の場合に評価される式
    result -- 最後に評価した式

三項演算子は条件分岐が二通りで、分岐後に評価する式が簡潔な場合に有効である。

## 比較関数
Parenには、あるオブジェクトが等しいか判定する関数が二種類存在する。
    関数  処理
    ---------------
    =     同等判定
    same? 同一判定

ここで、あるオブジェクトA、Bの存在を仮定する。

AとBが同等であるとは、AとBの型が等しく概念的にも等しいと見做せることをいう。

AとBが同一であるとは、AとBがメモリ上の同一アドレスに存在することをいう。

これらの定義から次のことが言える。
- 同等である条件はオブジェクトの型により異なる。
- 同一であることは同等であることの必要条件であるが十分条件ではない。

`=`は二つ以上のオブジェクトがすべて同等であれば真を返す。
    ) (= 3 3 3)
    true
    ) (= 3 2)
    false
    ) (<- a 3 b 3)
    3
    ) (= a b)
    true

次のように型が異なる場合は、概念的に等しくても偽を返す。
    ) (= "3" 3)
    false

`same?`は、比較する二つ以上のオブジェクトがすべて同一である場合に真を返す。
    ) (same? 3 3)
    false
    ) (<- a 3 b 3)
    3
    ) (same? a b)
    false
    ) (<- a 3 b a)
    a
    ) (same? a b)
    true

`same?`はメモリ番地の比較をするだけなので高速である。また、Parenでは同じシンボルとキーワードはすべて同一なオブジェクトであることが保証されている。

## 述語の結合
ある式の評価結果が真か偽かを表すことを強調する場合その式を述語という。

複数の述語を結合する述語が、マクロで定義されている。
    名称 処理
    ------------------------------------------------------------------------
    and  すべての引数の評価結果が真の場合に最後の評価結果を返す。
         ただし、評価途中に偽を返す式があったら以降の評価を中断しfalseを返す。
    or   どれか一つの引数の評価結果が真の場合にその値を返す。
         ただし、評価途中に真を返す式があったら以降の引数は評価しない。
         また、すべての引数の評価結果が偽の場合はfalseを返す。
    not  述語が真の場合は偽を、偽の場合は真を返す。

# 反復
Parenには反復処理を行うためのオペレーターがいくつか存在する。
- while
- for

また、このほかに必要に応じてユーザが反復処理を行うマクロを定義することができる。

## while
whileは条件を満たす間反復するマクロである。
    (while (end_test_form [:result result_form])
        [body_form ...])
    end_test_form -- 反復判定式
    result_form -- 返り値として評価される式
    body_form -- 反復処理

次の手順で反復処理が行われる。
1. end_test_formを評価した結果が真なら2へ偽なら反復終了
2. body_formを逐次評価し、1へ戻る

反復終了後、result_formが指定してある場合は評価してwhileの返り値とし、そうでなければnilを返す。

## for
forはwhileよりも細かく反復条件を指定することができるマクロである。
    (for (init_form end_test_form step_form [:result result_form])
        [body_form ...])
    init_form ::= (var_val ...)
    var_val ::= {var | ((var [value])}
    end_test_form -- 反復判定式
    step_form -- 反復する度に評価される式
    result_form -- 返り値として評価される式
    body_form -- 反復処理

forは次の手順で評価される。
1. init_formのシンボルと値の組を環境に束縛する。
2. end_test_formを評価した結果が真の場合3へ、偽なら反復終了
3. body_formを逐次評価
4. step_formを評価して1へ戻る

反復終了後、result_formが指定してある場合は評価してforの返り値とし、そうでなければnilを返す。

単純なforの使用例として1から10までの和を返すプログラムを示す。
    ) (for (((i 0) (sum 0)) (<= i 10) (++ i) sum) (+= sum i))
    55

# 配列
配列は連続したメモリ上に任意のParenオブジェクトを確保するデータ構造である。

抽象的には配列で行える操作はリストで置き換え可能であるから、処理速度以外の理由で配列を使用することはない。

## 配列の生成
配列は組み込みのarray関数で作成する。
    (array size [initial_function])
    size -- 確保する要素数
    initial_function -- 初期化関数

配列は一度作成するとその大きさは変更できない。
    ) (array 3)
    #[nil nil nil]

初期化関数は引数を一つとる関数で次のように、
各要素番号を使用した初期化を行う。
    ) (array 3 (fn (i) (* i 2)))
    #[0 2 4]

## リードマクロによる生成
初期値があらかじめ決まっているような配列はリードマクロを使用できる。
    ) #[1 2 3]
    #[1 2 3]

## 要素の参照
配列の要素を参照するには組み込み関数の`[]`を使用する。
    ([] array index)
    array -- 配列
    index -- 添え字

添え字は零から数える。
    ) (<- arr #[1 2 3])
    #[1 2 3]
    ) ([] arr 1)
    2

配列が確保している範囲外にアクセスするとエラーとなる。

## 配列に代入
配列に代入するには参照と同じ関数`[]`を使用する。
    ([] array index value)
    index -- 零から数える場所
    value -- 代入する値

簡単な使用例を示す。
    ) (<- arr #[1 2 3])
    #[1 2 3]
    ) ([] arr 1 10]
    #[1 10 3]

また、式の返り値は配列となる。

## 多次元配列
配列の要素には任意のParenのオブジェクトを保持できるため、配列の各要素が配列であるような配列が定義できる。
このような配列を2次元配列という。この概念を拡張して、一般に多次元配列という。

Parenでは多次元配列をコアライブラリに含めることはしない。

# 連想配列
連想配列は添え字に任意のParenのオブジェクトを設定できる配列であるようなデータ構造である。

Parenの連想配列はハッシュテーブルにより実装されているため理論上はO(1)でデータの探索が可能。

## 連想配列の作成
連想配列を作成するには組み込みのmap関数を使用する。
    ) (map)
    #{}

要素を指定して初期化する場合はリードマクロを使用できる。下の例のようにキーと値をペアで指定する。
    ) #{key1 val1
        key2 val2
        key3 val3}
    #{key1 val1 key2 val2 key3 val3}

## 要素の参照
連想配列mapのキーkeyに対応する値を参照するには`{}`関数を使用する。
    ({} map key)

簡単な評価例を示す。
    ) (<- map #{:key1 :val1 :key2 :val2})
    #{:key1 :val1 :key2 :val2}
    ) ({} map :key2)
    :val2

ただし、keyに対応する値がない場合はnilを返す。そのため、keyが設定されているのか、否かは関数`has_key?`を使用する必要がある。

## 要素の設定
連想配列mapのキーに値を設定するには`{}`関数を使用する。
    ({} map key value)
    key -- キー
    value -- 値

簡単な評価例を示す。
    ) (<- map #{:key1 :val1 :key2 :val2})
    #{:key1 :val1 :key2 :val2}
    ) ({} map 3 :three)
    #{:key1 :val1 :key2 :val2 3 :three}

`{}`の返り値は変更後の連想配列となる。また、既にキーに対する値が連想配列に存在する場合は上書きする。
    ) ({} map :key2 :two)
    #{:key1 :val1 :key2 :two 3 :three}

# スペシャルオペレーター
スペシャルオペレーターはParenの他の評価規則に従わない特殊なオペレーターである。

スペシャルオペレーターには次の種類が存在する。
- <-/<--
- begin
- fn
- ?
- label/goto
- macro
- quote
- try/catch/finally/throw

## <-/<--(シンボル束縛)
束縛オペレータ―はシンボルの章で説明した。

## begin(逐次評価)
    (begin body_form ...) => result
    body_form -- 逐次評価する式
    result -- 最後に評価した式
              ただし、実行する式がなかった場合はnil

beginは左から順に式を評価し、引数がある場合は最後の式の評価結果を返し、そうでなければnilを返す。

beginは主に副作用を期待するマクロの展開結果に含まれる。

組み込みでは、forやwhileなど複数の式を評価するマクロの展開結果に含まれる。

このように利用者が直接見ることはないが、暗にマクロの展開結果で利用されているbeginを暗黙のbeginという。

## fn(無名関数)
    (fn ([var ...  [:opt var_value ...] [:rest var] [:key var_value ...]])
        body_form ...)
    => result
    var_value ::= {var | (var value)}
    var -- 仮引数名
    value -- 仮引数の初期値
    result -- 作成した関数

fnは関数を作成するスペシャルオペレーターである。

fnに与える引数は、名前を指定しないという点を除いてfunctionと全く同じである。

fnが作る関数のことをその名前がないことにちなみ、無名関数という。無名関数は汎関数を使うときにしばしば用いられる。

関数の章で述べたmapの使用例を再喝する。
    ) (function double (* 2 x))
    double
    ) (map double (list 1 2 3))
    (2 4 6)

これは、しばしば次のように書かかれる。
    ) (map (fn (x) (* 2 x)) (list 1 2 3))
    (2 4 6)

## if(条件分岐)
ifは条件分岐の章で述べた。

## label/goto(ジャンプ機構)
    (label statement ...) => result
    statement ::= {label_name | goto_form | other_form}
    goto_form ::= (goto label_name)
    label_name -- ジャンプ先を表すキーワード
    other_form -- 上記以外の式
    result -- nil

labelはgotoで制御をジャンプするためのコンテキストを作る。

gotoを使用するとlabel内で定義したキーワードへ制御がジャンプする。

label/gotoを直に使用することはほとんどなく、forやwhile等のマクロを定義するために使用する。

## macro(マクロ)
マクロの章で述べる。

## quote(評価見送り)
quoteは引数を評価しないようにするスペシャルオペレーターである。
    (quote expr)
    expr -- 評価しない式

次のように引数の値がそのまま返される。
    ) (<- a 3)
    3
    ) a
    3
    ) (quote a)
    a

このように、評価を見送ることをクォートするという。Parenでは、クォートすることが頻繁にあるため、そのための構文糖`'`がリードマクロで定義されている。

クォートする対象に`'`を前置するとその対象がクォートされる。
    ) 'a    ;; (quote a)
    a

クォートは次のように定数のリストを作成するときに利用できる。
    ) '(1 2 3)
    (1 2 3)

クォートは、評価するタイミングをずらすためにマクロ定義に頻繁に利用される。

## try/catch/finally/throw(例外処理機構)
これらのスペシャルオペレーターは例外処理の章で述べる。

# マクロ
マクロは、プログラムが評価される前に評価されるプログラムである。このことは、同一ファイル内に評価するタイミングの異なるソースコードが混在していることを意味する。

Parenのマクロが他の言語と大きく異なるのは、マクロが言語と調和していることである。これにより、マクロが言語の拡張を容易にする。

例えば、C言語のそれは、言語とは全く関係ない一つの言語に等しく、本質的には単に文字列の置換相当の処理を行っているに過ぎない。

## マクロ定義
マクロはスペシャルオペレーターmacroを使って定義する。
    (macro macro_name param_list body_form ...) => result
    param_list ::= ( { param_list | param } ... )
    param ::= sym ...  [:opt sym_val ...] [:rest sym] [:key sym_val ...]
    sym_val ::= { sym | (sym val) }
    macro_name -- 定義するマクロ名
    sym -- シンボル
    val -- 値
    args -- マクロの引数
    body_form -- 展開結果
    result -- nil

関数と類似しているが、マクロの方が引数をより柔軟に指定できる。

## マクロの評価
マクロが評価されることをマクロ展開という。

マクロ展開は展開結果にマクロが含まれなくなるまで再帰的に行われる。マクロ展開後に、展開結果が評価される。

## 組み込みのマクロ
ここではいくつかの組み込みマクロの定義を述べる。

whileはgotoフォームを安全に使うための制御構造を構築する。
    (macro while ((test) &body body)
       `(label :start_while
               (if (,test ,@body)
                   (:else (goto :end_while)))
               :end_while))

whileはgotoフォームが使用されているが、利用者はまったく気にせずに使用できる。
    ) (let ((i 0))
        (while (< i 10) (write (++ i))))
    0123456789

マクロは、しばしば他のマクロを用いて定義される。一つの例として組み込みマクロforを示す。
    (macro for ((let_args test_form step_form) &body body)
       `(let ,@let_args
          (while ,test_form
            ,@body
            ,step_form)))

    ) (for (((i 0)) (<  i 10) (++ i))
        (write i))
    0123456789


チュートリアルでマクロの有用性について述べるのは限界がある。興味のある方は、On Lispをおすすめする。

# リードマクロ
リードマクロはParenのリーダーに新しく読込み規則を追加する機能である。

## リードマクロの定義
リードマクロはreadmacroマクロにより定義できる。
    (readmacro matcher expander)
    matcher -- リードマクロが実行される文字の列
    expander -- 入力ストリームを受け取るリードマクロの展開時に評価される関数

## 複数行コメント
コメントの章でParenには複数行コメントがないが、
リードマクロによって簡単に定義できると述べた。
ここでは、Common Lispの複数行コメントを定義する。
Common Lispでは、`#|`から始まり、`|#`までの文字の列がコメントと見做される。
そのようなリードマクロは次のように定義できる。
    (readmacro "#|"
      (fn (stream)
        (while ((or (/= (read_byte stream) (to_byte "l"))
                    (/= (read_byte stream) (to_byte "#")))))))

# 例外処理機構
try/catch/finally/throwは例外処理を行うためのスペシャルオペレーター群である。
    (try [body_form ...]
        [(catch (type var) catch_body_form ...) ...]
        [(finaly catch_body_form ...)])
    (throw exception)

# クラス
Parenは関数型言語として設計されているが、ここではマクロを用いてParenの上に構築されたオブジェクト指向言語について述べる。以後、このドメイン特化言語をPOS(Paren Object System)と呼ぶ。

POSは次の特徴をもつ。

## クラスの作成
クラスはマクロclassにより作成する。
    (class class_name (interface ...)
      ((instans_var ...)
       (method ...)))
    class_name -- クラスの名前
    interface -- 実装するインターフェース
    instans_var -- クラスのインスタンス変数
    method -- クラスのメソッド

クラスは名前、インターフェース、インスタンス変数を指定して作成する。
TODO;

例として二次元実数空間の(一部の)元を表すクラスPointを示す。クラス名は慣習としてパスカルケースで命名する。
    (class Point ()
      ((x y)
       (.norm .to_string .add)))

Pointクラスはインスタンス変数xとyを持つ。classマクロは概ね、次のようなS式に展開される。
    (begin
      (<-- Point #{:type :Point
                   :super '()
                   :fields '(x y)})
      ({} $class :class_name Point))

展開結果から分かるように、クラスはグローバルシンボルに連想配列として管理される。

## スーパークラス
クラス定義時にスーパークラスを指定した場合スーパークラスのインスタンス変数が継承される。
    (class A () a)
    (class B (A) b)    ; a, b
    (class C (B) c)    ; a, b ,c

また、複数スーパークラスを指定することもでき、その場合はすべてのスーパークラスのインスタンス変数が継承される。
    (class D () d)
    (class E (C D) e)    ; a, b, c, d, e

スーパークラスを複数指定した場合、同名のインスタンス変数が存在する場合がある。その場合は、二つ目以降の同名のインスタンス変数は継承されない。即ち、作成するクラスのインスタンス変数は、宣言したインスタンス変数と、重複を取り除いたすべてのスーパークラスに宣言されているインスタンス変数である。

次のクラスの宣言は妥当である。
    (class X (A B C D E) x)    ; a b c d e x

型判定マクロtype?はスーパークラスに対しても真を返す。
    ) (type? (new B) :A)
    true
    ) (type? (new C) :D)
    false
    ) (type? (new E) :A)
    true

## インスタンスの生成
インスタンスの生成にはnewマクロを使用する。
    (new class)
    class -- 生成するインスタンスのクラス

Pointクラスのオブジェクトは次のように生成する。
    (<- p (new Point))

生成したオブジェクトのインスタンス変数はすべてnilで初期化される。

## インスタンスの型
インスタンスの型を調べるにはtypeマクロを使用する。
    (type class)
    class -- クラス名

クラスの型はキーワードで返る。
    ) (type (new Point))
    :Point

また、型を判定する述語としてtype?マクロがある。
    ) (type? (new Point) :Point)
    true

## インスタンス変数の参照と代入
クラス定義時にインスタンス変数へのアクセサが、`'.' + 'インスタンス変数名'`という名称で自動生成される。

アクセサにインスタンスを渡すと、そのインスタンス変数の値が返る。
    ) (.x (<- p (new Point)))
    nil

インスタンス変数の値を更新するにはアクセサの第二引数に値を指定する。
    ) (.x p 3)
    3
    ) (.x p)
    3

インスタンス変数更新時は、右辺の値が返る。

POSでは、すべてのインスタンス変数のアクセサが自動で生成される。クラスの外部に公開したくないインスタンス変数は慣習として`_`で始まるインスタンス変数名を付ける。

## メソッドの定義
POSではメソッドはクラスに属さず、グローバルシンボル$methodにメソッド名ごとにシグネチャをキーとする連想配列で管理される。前述したアクセサもメソッドである。

シグネチャとは、メソッドを一意に特定できる情報の組をいう。POSでは、メソッド名とメソッド呼び出しの仮引数の型の組である。

メソッドの定義はmethodマクロを使用する。methodマクロは、$methodにメソッドを登録するS式に展開される。
    (method method_name (required_params [sym ...]
                                         [:opt sym_val [sym_val ...]]
                                         [:key sym_val [sym_val ...]]
                                         [:rest sym])
        body ...)
    required_params ::= (class sym) [(class sym) ...]
    sym_val ::= {sym | (sym val)}
    method_name -- メソッド名
    class -- メソッドを決定するクラス
    sym -- シンボル
    body -- メソッド本体

methodマクロは仮引数リストの必須パラメーターに少なくとも一つのクラスとシンボルの対を渡す点を除いて、スペシャルフォームfnと同じである。

慣習として、メソッド名は`.`から始める。そのため、メソッド以外のシンボル名は`.`以外から始めることを強く推奨する。

メソッドのすべての必須パラメーターの型が実引数の型と一致している場合、そのメソッドは呼び出し可能であるという。

メソッドは呼び出し時に、呼び出し可能なメソッドが動的にディスパッチされて実行される。

例えば、次のクラスとメソッドが定義されている場合を考える。
    (class Duck ())
    (class Cat ())
    (method .sound ((Duck o)) "quack")
    (method .sound ((Cat o)) "myaa")

この場合、呼び出される引数の型により動的にメソッドがディスパッチされる。
    ) (.sound (new Duck))
    "quack"
    ) (.sound (new Cat))
    "myaa"

以下、実用的なPointクラスのメソッドの実装例をいくつか示す。

POSでは、インスタンスを初期化するメソッドを.initという名称で作成する。

Pointクラスには有用であると考えられる初期化処理が二つ存在する。即ち、任意の元と零元への初期化である。これらは次のように書ける。
    (method .init ((Point p) x y)
      (.x p x)
      (.y p y)
      p)
    (method .init ((Point p))
      (.init p 0 0))

ただし、このメソッドの組はキーワードパラメーターを用いて、ほとんど同じ処理を行う一つのメソッドにすることもできる。
    (method .init ((Point p) :key (x 0) (y 0))
        (.x p x)
        (.x p y)
        p)

一般に可読性の観点から、公開するインスタンス変数が多いほどキーワードパラメーターを用いてメソッドを定義するほうがよい。

POSでは、インスタンスの印字表現を取得するメソッドを.strというメソッドで定義する。Pointクラスでは次のように実装されるであろう。
    (method .str ((Point p))
      (+ "(" (.x p) "," (.y p) ")"))

実行例を示す。
    ) (.str (.init (new Point) :x 3 :y 2))
    "(3,2)"

最後の例として、二次元実数空間上の元の和を返すメソッドを示す。これは、初期化メソッドを用いて次のように書ける。
    (method .add ((Point p1) (Point p2))
      (.init (new Point)
             :x (+ (.x p1) (.x p2))
             :y (+ (.y p1) (.y p2))))

このメソッドの呼び出しは次のようになる。
    ) (.x (.add (.init (new Point) :x 3 :y 4)
                (.init (new Point) :x 5 :y 8)))
    8

メソッド定義時に、既に同一シグネチャが存在する場合はエラーとなる。例えば、次のメソッドは先の.addとシグネチャが一致しているためエラーとなる。
    (.add ((Point p) (Point q) :rest pointers) ...)

一方で、次のメソッドはすべて同時に定義できる。
    (.add ((X x) (Y y)) ...)
    (.add ((Y y) (Y y)) ...)
    (.add ((Y x) (X y)) ...)
    (.add ((X x) :rest y) ...)
    (.add ((X x) (X x) (Y y)) ...)

## メソッドのディスパッチ
呼び出し可能なメソッドが複数存在する場合を考える。

継承により複数のメソッドが呼び出し条件を満たした場合、メソッドは次の優先度で決定される。
    TODO

# Common Lispとの違い
Lisp経験者のために代表的なCommon Lispとの違いを述べる。

ただし、この中には言語で吸収できる差も含まれる。

## 代入演算子
Parenはアクセサの第二引数に値を指定するとその場所に値を代入する仕様で作られている。
    対象     参照            代入
    --------------------------------------------------
    コンス   (car var)       (car var val)
             (cdr var)       (cdr var val)
    配列     ([] var index)  ([] var index val)
    連想配列 ({} var index)  ({} var index val)
    構造体   (get var index) (set var index val)

## シンボルの変換
両者ともシンボルの大文字小文字を区別するが、Common Lispはデフォルトで大文字に変換するのに対して、Parenでは一切変換を行わない。

## 述語の名称
Parenでは述語の末尾を`?`で終わらせることを推奨している。

## 多値を返す関数
Parenは多値を返す関数はない。

## 純リスト
Parenの任意のリストは純リストである。

## 命名規約
ParenはCommon Lispとは異なる命名規約をとっている。
    対象            命名方法
    --------------------------------------------------------
    ファイル                  スネークケース
    定数                      すべて大文字のスネークケース
    ローカルシンボル              キャメルケース
    グローバルシンボル            `$` + キャメルケース
    クラス                    パスカルケース
    キーワード                `:`から始まるキャメルケース
                              (ただし、型を表す場合はパスカルケースとする。)
    述語                      末尾に`?`を付ける
    破壊的処理                末尾に`!`を付ける
    束縛系のマクロ            withから始める
    アナフォリック系のマクロ  最後に`*`を付ける
    構造体                    パスカルケース
