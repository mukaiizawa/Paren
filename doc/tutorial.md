Parenチュートリアル

# 概要
このチュートリアルはParenの基本的な概念や文法を早巡りすることを目的とする。読者には計算機科学の初等的な知識があることを前提とし、いくつかの専門用語は定義することなしに使用している。

ParenはS式によって記述されるプログラミング言語Lispの方言である。

# 目次
- 書式
- 序章
- コメント
- 数値
- 文字列
- キーワード
- シンボル
- リスト
- 関数
- 条件分岐
- 反復
- 配列
- マップ
- スペシャルオペレーター
- マクロ
- リードマクロ
- 例外処理
- クラス
- 付録

# 書式
この文書内の書式は次の規則で記述してある。
    記号 定義
    ----------------------------------------
    [ ]  []内は省略可能
    { }  {}内から一つ選択
    |    []、{}内の代替候補の区切り文字
    ...  直前の構文の零回以上の繰り返し
    ::=  左辺を右辺で定義
    --   左辺の右辺による説明
    =>   左辺の評価結果は右辺

# 序章
この章ではいくつかの簡単なプログラムを示すことを目的とする。

## Parenの実行
parenを起動するとreplが実行される。
    $ paren
    ) 
`)`がプロンプトである。プロンプトに続けてプログラムを記述すると評価され結果が印字される。
    ) 1
    1
    ) (+ 1 2 3 4)
    10
    ) (* (+ 1 2) 3 4)
    36

Parenのプログラムは演算子を前置し、被演算子と共に括弧で括る。このように演算子を前置する記法をポーランド記法乃至、前置記法といい、Parenの特徴の一つである。

## hello world
あるプログラミング言語を習得する唯一の方法は、その言語でプログラムを書くことである。そしてそれは、慣習により次のプログラムを書くことから始まる。

    次の文字列を印字せよ。
    hello world

文字列を印字するにはwrite_lineを使用する。

    ) (write_line "hello world")
    hello world
    "hello world"

write_lineの評価すると二行出力される。一行目がwrite_lineがコンソールへ印字した文字列であり、二行がwrite_lineの評価結果をreplが印字したものである。

すべての式はwrite_lineのように必ず値を返す。この仕様はParenの特徴の一つである。

## 複写関数
もうひとつの例として標準入力から標準出力に複写する関数copyを作成する。

    ; copy 第一版
    (function copy ()
      (let ((ch nil))
        (while ((/= ch :EOF))
          (<- ch (read_byte))
          (write_byte ch))))

関数を定義するにはfunctionマクロを使用する。例ではcopyという引数がない関数を定義している。

関数の本体では、read_byteで取得したバイトでシンボルchを束縛している。その後、chを参照してwrite_byteで標準出力に書き出している。

このプログラムは、

    Parenのすべて式は評価されると値を返す。

という性質を用いてより簡潔に書ける。束縛オペレータ―はシンボルに束縛した値を返す。その性質を利用した版を以下に示す。

    ; copy 第二版
    (function copy ()
      (let ((ch nil))
        (while ((/= (<- c (read_byte)) :EOF))
          (write_byte ch))))

ただし、返り値を濫用するプログラムは可読性を下げることがあるため注意が必要である。

# コメント
コメントはParenに無視されるため、プログラムの補足事項等を自由に記述することができる。

## 一行コメント
Parenは`;`から行末までをコメントと見做す。これを一行コメントと呼ぶ。

    ; 一行コメント
    ;; これも一行コメント

## 複数行コメント
Parenには複数行に跨がれるコメントは言語仕様として存在しない。ただし、複数行に跨がれるコメントが必要になった場合は後述するリードマクロで容易に定義できる。

# 数値
Parenではすべての実数は数値型として扱われる。

## 数値リテラル
数値リテラルの書式を示す。

    [base x] number
    base -- 基数
    number -- 実数

基数は省略可能で、指定しない場合は10進数と見做される。また、基数に0を指定した場合は16進数と見做される。

## 評価
数値は評価されると自身を返す。

    ) 10
    10
    ) 3.141592
    3.141592
    ) 2x1010
    10
    ) 0x14
    10

## 算術関数
代表的な算術関数を次に示す。

    関数  処理
    -------------------
    +     加算
    -     減算
    *     乗算
    /     除算
    **    冪乗
    //    切り捨て除算
    mod   余り

これらの実行例を示す。

    ) (+ 3 4 5)
    12
    ) (- 10 4 5)
    1
    ) (* 3 4 5)
    60
    ) (/ 3 4 5)
    0.15
    ) (/ 3)
    0.33333
    ) (** 2 3)
    8
    ) (// 5 4)
    1
    ) (mod 6 4)
    2

# 文字列
文字列は文字列リテラルや組み込みのto_str関数等で作成できる。

## 文字列リテラル
文字列は評価されると自身を返す。文字列リテラルはダブルクォートで囲まれた文字の列である。
    ) "hello paren"
    "hello paren"

## 文字列の作成
オブジェクトから文字列を作成するにはto_strを使用する。to_str関数はParenのオブジェクトの表現を文字列として取得する。
    ) (to_str 123)
    "123"

## 文字列の結合
文字列の結合は+を使用する。
    ) (+ "hello" "_" "paren")
    "hello_paren"

## 文字列の長さの取得
文字列の長さを取得するには組み込み関数のlengthを使用する。
    ) (length "hello paren")
    11

## 部分文字列の取得
部分文字列を取得するにはsubseqを使用する。
    ) (subseq "hello paren" 6)
    "paren"
    ) (subseq "hello paren" 0 5)
    "hello"

第一引数のみ指定されている場合はその値以降の部分文字列を取得する。第二引数まで指定してある場合は、第一引数から第二引数の値の前までの部分文字列を取得する。ただし、どちらの場合も零から数える。

## 文字列の比較
文字列の比較は比較関数`=`で行う。
    ) (= "hello paren" "hello paren")
    true
    ) (= "Hello Paren" "hello paren")
    false

## 部分文字列が含まれるか判定
部分文字列が含まれているかどうか判定するにはinclude?を使用する。
    ) (include? "Hello Paren" "Hello")
    true
    ) (include? "Hello Paren" "hello")
    false

## 文字列の先頭がある部分文字列と一致するか判定
start_with?は文字列が特定の文字列で始まっているかを判定する。
    ) (start_with? "Hello Paren" "Hello")
    true
    ) (start_with? "Hello Paren" "hello")
    false

## 文字列の末尾がある部分文字列と一致するか判定
end_with?は文字列が特定の文字列で終了しているか判定する。
    ) (end_with? "Hello Paren" "Paren")
    true
    ) (end_with? "Hello Paren" "Hello")
    false

## 正規表現
Parenで正規表現を使用したい場合は:Regexモジュールをインクルードする。
詳細は:Regexモジュールのドキュメントを参照のこと。

# キーワード
キーワードは同名であるならばプログラムでただ一つだけ存在するという性質を持つオブジェクトである。アドレス比較で同一か判定可能なため列挙等に使用される。

キーワードを取得するためには次のいずれかの方法を用いる。
- キーワードリテラルを使用する
- to_key関数を使用する

## キーワードリテラル
キーワードリテラルは`:`から始まる英数字と一部の記号の列である。
次のいずれも有効なキーワードリテラルである。
    :0123
    :keyword_literal

厳密な仕様については言語仕様書の字句定義の章を参照のこと。

## to_key関数
to_key関数は文字列を受け取り、それに対応するキーワードを返す。
    ) (to_key "key")
    :key

## キーワードの評価
キーワードは評価されると自身を返す。
    ) :key
    :key

# シンボル
シンボルは任意のParenオブジェクトへの参照を保持するためのオブジェクトである。既に述べた数値や文字列の他、関数やリストやシンボルなどもParenのオブジェクトであるため、シンボルで参照を保持することができる。

## シンボル名
Parenのシンボル名は数字以外の英文字と一部の記号から始まり、その後、英数字と一部の記号が続く。

次のいずれもParenのシンボル名として有効である。
    var
    x1
シンボル名で使用できる文字の厳密な定義は言語仕様書の字句解析の章を参照されたい。

シンボル名が複数の単語で構成される場合は、単語の区切れをアンダースコアで区切る。

    user_name
    neighbor_node

## 環境
シンボルの保持するオブジェクトへの参照は環境で管理されている。

環境とは、一つのシンボルテーブルと零又は一つの環境への参照の対のことをいう。ここで、シンボルテーブルとはシンボルとオブジェクトへの参照の対の集合のことをいう。ただし、シンボルテーブルに存在する同一シンボルは高々一つである。

環境の持つ環境への参照の実体を親の環境という。これに対して、ある親の環境の参照元の環境を子の環境という。

Parenには親の環境が存在しないような環境は高々一つしか存在しない。この環境のことを大域環境という。

ある環境EのシンボルテーブルTにシンボルSとオブジェクトへの参照Pの対(S, P)が存在しているとき、EにSがPで束縛されているという。また、Tに対(S, P)を追加することを、EにSをPで束縛するという。これは、単にSをPで束縛する、乃至、Sを束縛するともいう。

式が評価される場合、必ずどこかの環境の下で評価される。Parenを起動した直後の環境は大域環境である。
## シンボルの評価
シンボルは評価されると、保持しているオブジェクトへの参照の実体を返す。ただし、シンボルの評価結果は評価される環境によって変わりうる。
シンボルの評価は次の手順で行われる。

    シンボルSが評価された環境EのシンボルテーブルにSが存在している場合、対応するオブジェクトへの参照の実体を返す。
    そうでなければEの親の環境に対して再帰的にシンボルテーブルの探索を行う。
    親の環境を辿っていき、大域環境のシンボルテーブルにSが存在しない場合はエラーとする。

このように、あるシンボルが保持するオブジェクトへの参照は、どの環境下でシンボルが評価されたのか考えなければ意味がない。

例えば、前述した`+`は大域環境に束縛されているシンボルの一つであり、評価されることによって引数の和を計算する関数が返されていたことになる。

## シンボルの束縛
シンボルを束縛するには束縛オペレーターを使用する。束縛オペレーターにはその用途から二種類されている。
    (<- variable_value ...) => result
    (<-- variable_value ...) => result
    variable_value ::= var val
    var -- シンボル
    val -- シンボルが保持するオブジェクトの参照の実体
    result -- 最後に束縛した値

`<-`は、現在の環境にシンボルが束縛されている場合はシンボルテーブルの値を更新する。そうでなければ、親の環境に対して再帰的に探索を続けてシンボルテーブルを更新する。大域環境にもシンボルが束縛されていない場合は、大域環境に新たにシンボルを束縛する。

`<--`は常に大域環境にシンボルを束縛する。大域環境にすでにシンボルが束縛されている場合はシンボルテーブルの値を更新する。

## シンボルの再束縛
子の環境で親の環境に束縛されているシンボルを束縛する行為をシンボルを再束縛するという。子の環境でシンボルを評価すると、親の環境でシンボルが束縛されている値が参照できなくなることからシンボルを隠すともいう。

シンボルの再束縛は有用な用途があるためしばしば用いられるが、濫用しすぎるとプログラムの可読性が落ちるため注意が必要である。
## 環境の作成
現在の環境を親にもつ環境を新しく作るにはマクロletを使用する。

    (let ([let_args ...]) [body ...]) => result
    let_args ::= symbol [value]
    symbol -- 新しく作成する環境に束縛するシンボル
    value -- シンボルを束縛する値
    body -- 新しく作成する環境で評価する式
    result -- 新しく作成した環境で最後に評価した式の評価結果

letは新しく環境を作成し、第一引数のシンボルを束縛する。第二引数以降は作成した環境内で式を評価する。

letはマクロで定義された、環境という概念を意識した構文糖に過ぎない。このことについては後述する。

## グローバルシンボル
大域環境に束縛されたシンボルのことをグローバルシンボルという。グローバルシンボルは隠されない限り、すべての環境から参照できる。

慣習として、ほかのシンボルと区別がつきやすいようにグローバルシンボル名は次のように`$`から始める。
    $global_var

## 特殊なシンボル
システムであらかじめ組み込まれている、参照しかできない特殊なシンボルが存在する。
これらは大域環境に束縛されていて、再束縛が禁止されているためどこからでも参照ができる。
    シンボル 意味
    --------------------------------------
    true     真の代表値
    false    偽の代表値
    nil      空の代表値

## 定数
Parenでは言語機能として定数は存在しない。その代わりに、シンボルを定数として扱いたい値で束縛して用いる。この用途で使用するシンボルは他のシンボルと見分けがつくように慣習としてすべて大文字のシンボル名を使用する。

    ) (<-- PI 3.141592)
    3.141592

これらのシンボルを定数の用途として機能させるには、プログラマが注意を払わなければならない。

    ) (<- PI "pi")    ; 誤り
    "pi"

# リスト
リストはParenにおいて最も重要なデータ型であると同時に、Parenを記述するプログラムでもある。
## コンス
コンスとは、任意のParenオブジェクトへの参照carと、コンスまたはnilへの参照cdrの対のことをいう。

リストとは、コンスのcdrで辿れる全体、または、nilのことをいう。コンスはリストのノードであり、carはデータへの参照、cdrは次のノードへの参照であり、nilで終端している。リストとして空の代表値nilを扱う場合には、特に空のリストということがある。

あるコンスのcdrを辿っていった終端がnilを指している場合、そのコンス全体は純リストであるという。コンスの定義により、Parenの任意のリストはすべて純リストである。純リスト以外のリストが作れないという制約はほかのLisp方言と異なる特徴の一つとなる。

コンスは組み込み関数consで作ることができる。consの第一引数、第二引数が、それぞれ作成されるコンスのcarとcdrに対応する。ただし、コンスの定義にあてはまらない引数をconsに与えるとエラーとなる。


    ) (cons 1 nil)
    (1)
    ) (cons 1 (cons 2 nil))
    (1 2)
    ) (cons (cons 1 nil) (cons 2 nil))
    ((1) 2)

Parenはコンスを印字するときにコンスのcdrで辿れる全体、つまり、リストとして印字する。

リストは次の手順で、自然な形に印字される。
1. 左括弧を印字
2. carが指す値を印字する
   cdrが指す値がnilなら3を行う
   そうでなければ、再びcdrが指すコンスに対して2を行う
3. 右括弧を印字

    ) (cons 1 (cons 2 (cons 3 nil)))
    (1 2 3)

    +-----+-----+
    | car | cdr |
    +-----+-----+
       |     |    +-----+-----+
       |     +--->| car | cdr |
       |          +-----+-----+
       |             |     |    +-----+-----+
       |             |     +--->| car | cdr |
       |             |          +-----+-----+
       |             |             |     |
       |             |             |     +---> nil
       1             2             3

あるコンスのcarがコンスを指している場合でもそのルールは再帰的に適用される。

    ) (cons (cons 1 nil) (cons 2 (cons 3 nil)))
    ((1) 2 3)

    +-----+-----+
    | car | cdr |
    +-----+-----+
       |     |    +-----+-----+
       |     +--->| car | cdr |
       |          +-----+-----+
       |             |     |    +-----+-----+
       |             |     +--->| car | cdr |
       |             2          +-----+-----+
       |                           |     |
       |    +-----+-----+          |     +---> nil
       +--->| car | cdr |          3
            +-----+-----+
               |     |
               |     +---> nil
               1

任意のリストはcons関数で作ることができるが、複数の要素を持つようなリストを作ろうとすると、すぐに困ったことになる。

    ) (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 nil)))))
    (1 2 3 4 5)

そのため、Parenには引数を要素に持つようなリストを作成するための関数、
listが存在する。
    (list [arg ...])
    arg -- リストの要素

    ) (list 1 2 3 4 5)
    (1 2 3 4 5)

リストの定義により、要素がリストであるようなリストも作成することもできる。
    ) (list (list 1 (list 2 3) 4 5))
    ((1 (2 3)) 4 5)

## carとcdrの参照
コンスが指す二つのポインタcar、cdrの指す場所を得る関数があり、
それぞれcarとcdrという。
    ) (list 1 2)
    (1 2)
    ) (car (list 1 2))
    1
    ) (cdr (list 1 2))
    (2)
    ) (car (cdr (list 1 2)))
    2

carとcdrは引数が空のリストである場合はnilを返す。
    ) (car nil)
    nil
    ) (cdr nil)
    nil
    ) (car (cdr (cdr (list 1))))
    nil

リストの要素を参照するときにcarとcdrを組み合わせることは頻繁にあるため、計四回までリストを辿るすべての組み合わせが定義されている。

    caar cadr cdar cddr
    caaar caadr cadar caddr cdaar cdadr cddar cdddr caaaar
    caaadr caadar caaddr cadaar cadadr caddar cadddr cdaaar cdaadr cdadar
    cdaddr cddaar cddadr cdddar cddddr

これらの関数については合成規則が分かるような等価な式を例示することにとどめる。

    (caar lis) <=> (car (car lis))
    (caddr lis) <=> (car (cdr (cdr lis)))
    lis -- 引数のリスト

## carとcdrへ代入
コンスのcarとcdrが指す場所を変更するには、それぞれcar、cdr関数の第二引数に値を指定する。

    ) (car (list 0 0 0) 1)
    (1 0 0)

これはすべての操作関数について成り立つ。

    ) (cdddr (list 0 1 2) (list 3 4 5))
    (0 1 2 3 4 5)

cdrが指す値を書き換える際、純リストでなくなるような代入はできない。
## リストの評価
ParenはS式によって記述される。S式とはアトム又はリストのことをいう。リスト以外のオブジェクトのことを総称してアトムという。
    S式
      - アトム
        - 数値
        - 文字列
        - 配列
        - 関数
        - マクロ
      - リスト

S式は評価されると値を返す。アトムは、後述するシンボルを除いて評価されると自身を返す。リストは、まず最初にオペレーターが評価される。

    (operator [arg ...])
    operator -- オペレーター
    arg -- オペレーターに渡る引数

オペレーターはリストであっても構わず、その場合は再帰的に処理が行われる。次に、評価したオペレーターの種類にしたがってリストを評価する。

Parenのオペレーターには次の三種類が存在する。
- 関数
- スペシャルオペレーター
- マクロ

オペレーターの評価結果が上記のいずれでもない場合はエラーとなる。
### 関数
オペレーターが関数の場合、すべての引数を評価し、その結果を関数に渡して関数を評価する。
    ) (+ (- 1 1) (* 2 2) (* 3 3))
    13

上記の例では関数`+`、`-`、`*`の引数はそれぞれ評価されてから渡される。

### スペシャルオペレーター
スペシャルオペレーターはParenに組み込まれている特殊なオペレーターで、オペレーター毎に引数の扱いが異なる。詳しくはスペシャルオペレータので述べる。

### マクロ
オペレーターがマクロの場合、すべての引数を評価せずにマクロに渡し評価する。ただし、その定義のされ方によっては引数が評価されているようにも見える。詳しくはマクロの章で述べる。そのため、オペレーターの定義を見ることなしに引数の扱われ方だけで、マクロかスペシャルオペレーターか関数か判断できないこともある。

このことは、他の非Lisp系の言語と異なりParenのマクロはプログラムに調和し、自然な拡張をもたらすことを意味する。

## プログラムとデータ
既に述べたようにParenのプログラム、つまりS式はParenのデータである。

一方で、Parenのデータのうち、評価可能なS式はParenのプログラムである。

データとプログラムが相互に変換可能であるという事実は、プログラムを書くプログラムを書きやすくする。実際、マクロはこの事実に着眼した機能であり、Parenを強力な言語にしている。

ここで、上記の可能性について考える。次の式は既に示したように、評価されるとリストを返す。
    ) (list 1 2 3)
    (1 2 3)

もし、上の式が返される先頭の要素がオペレーターだとしたら評価可能な式になる。

例えば次の式はそれにあたる。
    ) (list + 1 2 3)
    (+ 1 2 3)

ここで垣間見た可能性についてマクロの章で詳しく述べる。

# 関数
関数はParenの根幹をなすオブジェクトである。ただし、この文書内における関数という単語は、計算幾何学における手続き程度の意味しかない。

## 関数の定義
関数を定義するにはマクロfunctionを用いる。
    (function function_name ([var ...
                             [:opt var_value ...]
                             [:rest var]
                             [:key var_value ...]])
        body_form ...)
    var_value ::= {var | (var value)}
    function_name -- 定義する関数名
    var -- 仮引数名
    value -- 仮引数の初期値
functionの第一引数、第二引数、第三引数以降のことを、
それぞれ、定義する関数の関数名、仮引数、本体という。
functionは与えられた名前の関数を定義し、その関数を返す。
    ) (function double (x) (* 2 x))
    double
    ) (double 4)
    8
functionで定義する関数は、組み込みのそれと何ら変わらない。
## 関数呼び出し
関数を呼び出すには、関数名とその引数をリストにして評価すればよい。
    ) (double 3)
    6
    ) (double 4)
    8
関数の仮引数と一致しない場合はエラーとなる。
関数の実引数の評価は必ず左から順に評価される。
## 仮引数
仮引数には次の種類がある。
1. 必須パラメーター
2. オプショナルパラメーター
3. レストパラメーター
4. キーワードパラメーター
任意のパラメーターを同時に組み合わせて指定することができるが、
同時に指定する際は、上の順番で指定しなければならない。
### 必須パラメーター
必須パラメーターは関数呼び出し時に必ず与えなければならない仮引数を定義する。
関数呼び出し時に必須パラメーターが足りない場合はエラーとなる。
    ) (function avg2 (x y)
        (/ (+ x y) 2))
    ) (avg 2 4)
    3
### オプショナルパラメーター
オプショナルパラメーターは関数呼び出し時に省略可能な仮引数を定義する。
仮引数の`:opt`句にシンボル名と初期値をリストにして指定する。
関数呼び出し時にオプショナルパラメーターが省略された場合は初期値が使用される。
    ) (function x_add_y (x :opt (y 1))
        (+ x y))
    x_add_y
    ) (x_add_y 3)
    4
    ) (x_add_y 3 2)
    5
オプショナルパラメーターの初期値を指定しない場合は、
実引数で指定されなかった場合にnilが初期値となる。
そのため次の二つの関数の仮引数は等価である。
    (function f1 (:opt x) ...)
    (function f2 (:opt (x nil)) ...)
オプショナルパラメーターは複数定義することもできる。
    ) (function concat (s1 :opt (s2 "") (s3 ""))
        (+ s1 s2 s3))
    ) (concat "hello")
    "hello"
    ) (concat "hello" " world")
    "hello world"
    ) (concat "hello" " world" "!!")
    "hello world!!"
ただし、i番目のオプショナルパラメーターを指定して関数を呼びたい場合は、
i - 1番目までのオプショナルパラメータをすべて指定する必要がある。
### レストパラメーター
レストパラメーターは可変長な実引数を受け取る仮引数を定義する。
仮引数の`:rest`句に可変長引数を定義する。
関数呼び出し時に仮引数よりも多い実引数がリストになり、
指定したレストパラ―メーターに束縛される。
    ) (function first_rest (first :rest rest)
        (list first rest))
    ) (first_rest 1 2 3)
    (1 (2 3))
レストパラメーターに束縛される実引数がない場合はnilが束縛される。
    ) (first_rest 1)
    (1 nil)
### キーワードパラメーター
キーワードパラメーターは、順序を問わない名前付きの仮引数を定義する。
仮引数の`:key`句に指定する。
キーワードパラメーターには初期値を与えることができ、
呼び出し時にキーワードパラメーターが省略された場合は初期値が使用される。
    ) (function test_key (:key (k1 1) (k2 2) k3)
        (list k1 k2 k3))
    test_key
    ) (test_key)
    (1 2 nil)
    ) (test_key :k1 -1)
    (-1 2 nil)
キーワードパラメーターの仮引数の順序と実引数の順序は一致しなくてもよい。
    ) (test_key :k3 3 :k1 -1)
    (-1 2 3)
## 汎関数
前述したように関数はアトムの種類の一つに過ぎない。
そのため、他のデータ型である数値や文字列と同様に、
シンボルに束縛したり、関数に引数として渡したり、
関数の返り値として返したりすることができる。
ここで、関数全体の集合のうち関数を引数に受け取る、
または、返り値が関数であるように定義された関数を汎関数乃至、高階関数という。
## 汎関数ユーティリティ
Parenに組み込みで用意されている汎関数をいくつか示す。汎関数を用いることにより、高度な抽象化を用いることができる。
### リストを写像する
    (map fn list ...) => result
    fn -- 写像関数
    list -- 写像前のリスト
    result -- 写像後のリスト
mapは引数のリストを写像した結果を返す汎関数である。
次の例は、引数のリストを二倍する。
    ) (function double (* 2 x))
    double
    ) (map double (list 1 2 3))
    (2 4 6)
### リストをグルーピングする
    (group_by fn list) => result
    fn -- グループ分けするカテゴリを返す関数
    list -- グループ分けするリスト
    result -- グルーピングされたリスト
groupは指定した関数が返した結果でグルーピングする。
    ) (group abs (list -1 1 2 -3 3))
    ((1 -1 1) (2 2) (3 -3 3))
### リストから要素を取り除く
    (remove_if fn list) => result
    fn -- 要素を取り除くか決める関数
    list -- 要素を取り除く対象のリスト
    result -- 要素を取り除いた後のリスト
次に、負の数を取り除く例を示す。
    ) (remove_if minus? (list 1 -2 3))
    (1 3)
## 再帰関数
関数全体の集合のうち、関数の本体で自分自身を呼ぶような関数を再帰関数と呼ぶ。
再帰関数を用いると直感的にプログラムできることがある。
再帰関数の例として整数nの階乗を求める関数factorialを示す。
    (function factrial (n)
        (if ((= n 1) 1)
            (true (* n (factorial (- n 1))))))
これはfor文を用いるより、直感的である。
    (function factrial (n)
        (<- result n)
        (while ((/= n 1) result)
            (*= reult (-- n))))
また、再帰関数全体の集合のうち、
自身の呼び出しごとにスタックが積まれないような関数を末尾再帰関数という。
上記のfactorialは呼び出しごとにスタックが積まれていくため末尾再帰関数ではない。
factorialは次のような末尾再起関数に変換できる。
    (function factorial (n :opt (acc 1))
        (if (= n 1) acc
            (factorial (- n 1) (* acc n))))
## 純粋関数
関数全体の集合のうち、次の性質を持つものを特に純粋関数という。
- 任意の引数に対して、返り値が時間に依存せずに一意に定まる
- 他に何も影響を与えない
このような性質を参照透過性という。
また、二つ目の性質
    他に何も影響を与えない
のことを副作用という。
次のような処理は副作用がある。
- 束縛
- 入出力
定義から、次のような関数は純粋関数ではない。
- あるグローバルシンボルの値の3倍の数を返す関数
- 引数を標準出力に印字する関数
- 引数の値を3倍に変更する関数
- 現在時刻をシードとした0か1の乱数を返す関数を返す関数
逆に、次の処理を行うだけの関数は純粋関数である。
- 引数を返す関数
- 引数の文字列表現を返す関数
- 引数の値の3倍の値を返す関数
- 引数をシードとした0か1の乱数を返す関数を返す関数
可能な限りプログラムは純粋関数で構成することが望ましい。
これは、純粋関数はそうでない関数に比べてとりうる状態が少なく、
一般的に汎用的な処理になりバグも発生しにくいことによる。

# 条件分岐
Parenには条件分岐のオペレータifが存在する。
上記のオペレーターが気にいらなかったり、
新たにオペレーターが必要になった場合は後述するマクロでいつでも拡張できる。
## 真偽値
Parenは次にあげる値を除き、すべて真と見做される。
- false
- nil
- 0
- ""
## if
ifは汎用的な条件分岐処理を行うためのスペシャルオペレーターである。
    (if [clause ...])
    clause ::= (test [body_form ...])
    test -- 処理を行うか否かを表す真偽値
    body_form -- testが真のときに評価される式
ifは評価する条件と評価する式のリストのリストとなっている。
ifは最初の引数から、そのリストの先頭の要素を評価する。
評価結果が真の場合はそのリストの残りの要素を順に評価し、
そうでなければ次の引数に対して同じことを行う。
    ) (function to_roman (x)
        (if ((= x 1) :one)
            ((= x 2) :tow)
            ((= x 3) :three)
            (true :more)))
    ) (roman 1)
    :one
    ) (roman 4)
    :more
if全体は条件式が真を返す引数があれば、そのリストの最後の要素の評価結果を返す。
そうでなければfalseを返す。
最後の引数がデフォルトを表す節の場合は慣習としてtrueを用いる。
## 三項演算子
Parenには三項演算子相当の`?`マクロが用意されている。
    (? test then_form else_form)
    test -- 真偽値
    then_form -- testが真の場合に評価される式
    else_form -- testが偽の場合に評価される式
三項演算子は条件分岐が二通りで、分岐後に評価する式が簡潔な場合に有効である。
## 比較関数
Parenには、あるオブジェクトが等しいか判定する関数が二種類存在する。
    関数 処理
    --------------
    =    同等判定
    same?  同一判定
ここで、あるオブジェクトA、Bの存在を仮定する。
AとBが同等であるとは、AとBの型が等しく概念的にも等しいと見做せることをいう。
AとBが同一であるとは、AとBがメモリ上の同一アドレスに存在することをいう。
これらの定義から次のことが言える。
- 同等である条件はオブジェクトの型により異なる。
- 同一であることは同等であることの必要条件であるが十分条件ではない。
`=`は二つ以上のオブジェクトがすべて同等であれば真を返す。
    ) (= 3 3 3)
    true
    ) (= 3 2)
    false
    ) (<- a 3 b 3)
    3
    ) (= a b)
    true
次のように型が異なる場合は、概念的に等しくても偽を返す。
    ) (= "3" 3)
    false
`same?`は、比較する二つ以上のオブジェクトがすべて同一である場合に真を返す。
    ) (same? 3 3)
    false
    ) (<- a 3 b 3)
    3
    ) (same? a b)
    false
    ) (<- b `a)
    a
    ) (same? a b)
    true
`same?`はメモリ番地の比較をするだけなので高速である。
また、Parenでは同一シンボルはすべて同一なオブジェクトであることが保証されている。
    ) (same? :a :a)
    true
    ) (<- a 3)
    3
    ) (same? a a)
    true
## 述語の結合
ある式の評価結果が真か偽を表すことを強調する場合その式を述語という。
Parenには述語を結合するオペレーターがある。
    名称 処理
    ------------------------------------------------------------------------
    and  すべての引数の評価結果が真の場合に最後の評価結果を返す。
         ただし、評価途中に偽を返す式があったら以降の評価を中断しfalseを返す。
    or   どれか一つの引数の評価結果が真の場合にその値を返す。
         ただし、評価途中に真を返す式があったら以降の引数は評価しない。
         また、すべての引数の評価結果が偽の場合はfalseを返す。
    not  述語が真の場合は偽を、偽の場合は真を返す。
Parenには`=`の否定を返す関数`/=`が存在するが、
notの定義により次の二つの式は等価となる。
    (/= expr1 expr2) <=> (not (= expr1 expr2))

# 反復
Parenには反復処理を行うためのオペレーターがいくつか存在する。
- for
- while
- each
また、このほかに必要に応じてユーザが反復処理を行うマクロを定義することができる。
## for
forマクロは汎用的な反復処理を実現する。
    (for (init_form end_test_form step_form [result_form])
        [body_form ...])
    init_form -- 初期化式
    end_test_form -- 反復判定式
    step_form -- 反復する度に実行される式
    result_form -- 返り値として評価される式
    body_form -- 反復処理
forは次の手順で実行される。
1. init_formを評価する。
2. end_test_formを評価した結果が真の場合3へ、偽なら反復終了
3. body_formを逐次評価
4. step_formを評価して1へ戻る
反復終了後、result_formが指定してある場合は評価してforの返り値とし、
そうでなければnilを返す。
単純なforの使用例として1から10までの和を返すプログラムを示す。
    ) (for ((<- i 1 sum 0) (<= i 10) (++ i) sum)
          (+= sum i))
    55
## while
whileは次の書式をとる。
    (while (end_test_form [result_form])
        [body_form ...])
    end_test_form -- 反復判定式
    result_form -- 返り値として評価される式
    body_form -- 反復処理
次の手順で反復処理が行われる。
1. end_test_formを評価した結果が真なら2へ偽なら反復終了
2. body_formを逐次評価し、1へ戻る
反復終了後、result_formが指定してある場合は評価してwhileの返り値とし、
そうでなければnilを返す。
## each
eachは引数が反復可能なオブジェクトの場合に使用できる。
反復できるオブジェクトとには次の種類が存在する。
- 配列
- リスト
eachは第一引数のリストの第一要素に反復時に使用するシンボル名を、
第二要素に反復する対象を指定する。
eachの第二引数移行が、反復処理の対象となる。
    (each (iterator object [result_form])
        [body_form ...])
    iterator -- each内の反復シンボル
    object -- 反復対象のコレクション
    result_form -- 返り値として評価される式
    body_form -- 反復処理
簡単な評価例を示す。
    ) (each (i (range 1 5))
          (write i))
    12345
    ) (each (i "12345")
          (write i))
    12345
反復終了後、result_formが指定してある場合は評価してeachの返り値とし、
そうでなければnilを返す。

# 配列
配列は連続したメモリ上にオブジェクトを確保するデータ構造である。
配列を使用するデータ構造は一般的にはリストで表現可能であるが、
処理速度等の理由により配列を採用する場合がある。
なお、Parenの配列はParenのオブジェクトなら何でも代入することができる。
## 配列の生成
配列は組み込みのarray関数で作成する。
    (array size [initial_function])
    size -- 確保する要素数
    initial_function -- 初期化関数
配列は一度作成するとその大きさは変更できない。
    ) (array 3)
    #[nil nil nil]
初期化関数は引数を一つとる関数で次のように、
各要素番号を使用した初期化を行う。
    ) (array 3 (fn (i) (* i 2)))
    #[0 2 4]
## リードマクロによる生成
初期値があらかじめ決まっているような配列はリードマクロを使用するとよい。
    ) #[1 2 3]
    #[1 2 3]
## 要素の参照
配列の要素を参照するには組み込み関数の`[]`を使用する。
次に書式を示す。
    ([] array index)
添え字は零から数える。
    ) (<- arr #[1 2 3])
    #[1 2 3]
    ) ([] arr 1)
    2
配列が確保している範囲外にアクセスするとエラーとなる。
## 配列に代入
配列に代入するには参照と同じ関数`[]`を使用する。
次に書式を示す。
    ([] array index value)
    index -- 零から数える場所
    value -- 代入する値
簡単な使用例を示す。
    ) (<- arr #[1 2 3])
    #[1 2 3]
    ) ([] arr 1 10]
    #[1 10 3]
また、式の返り値は配列となる。
## 多次元配列
配列の要素には任意のParenのオブジェクトを保持できるため、
配列の各要素が配列であるような配列が定義できる。
このような配列を2次元配列という。
この概念を拡張して、一般に多次元配列という。
Parenでは多次元配列をコアライブラリに含めることはせず、
モジュール:Matrixにて提供する。

# マップ
マップは配列の添え字に任意のParenのオブジェクトを設定できる配列である。
実装はハッシュテーブルにより実装されているため、
理論上はO(1)でデータの探索が可能。
詳細な仕様については別ドキュメントを参照されたい。
## マップの作成
マップを作成するには組み込みのmap関数を使用する。
    ) (map)
    #{}
要素を指定して初期化する場合はリードマクロを使用できる。
下の例のようにキーと値をペアで指定する。
    ) #{key1 val1
        key2 val2
        key3 val3}
    #{key1 val1 key2 val2 key3 val3}
## 要素の参照
マップmapのキーkeyに対応する値を参照するには`{}`関数を使用する。
    ({} map key)
簡単な評価例を示す。
    ) (<- map #{:key1 :val1 :key2 :val2})
    #{:key1 :val1 :key2 :val2}
    ) ({} map :key2)
    :val2
ただし、keyに対応する値がない場合はnilを返す。
そのため、keyが設定されているのか、否かは関数`has_key?`を使用する必要がある。
## 要素の設定
マップmapのキーに値を設定するには`{}`関数を使用する。
    ({} map key value)
    key -- キー
    value -- 値
簡単な評価例を示す。
    ) (<- map #{:key1 :val1 :key2 :val2})
    #{:key1 :val1 :key2 :val2}
    ) ({} map 3 :three)
    #{:key1 :val1 :key2 :val2 3 :three}
`{}`の返返り値はマップとなる。
また、既にキーに対する値がマップに存在する場合は上書きする。
    ) ({} map :key2 :two)
    #{:key1 :val1 :key2 :two 3 :three}

# スペシャルオペレーター
スペシャルオペレーターはParenのS式の評価ルールに従わない、
オペレーターごとに異なる特別なルールで評価される。
スペシャルオペレーターには次の種類が存在する。
- <-
- begin
- fn
- if
- label/goto
- macro
- quote
- try/catch/finally/throw
これらのうち、いくつかはすでに説明してきた。
ここでは、まだ説明していないスペシャルオペレーターについて述べる。
## <-(シンボル束縛)
代入オペレータ―はシンボル、環境の章で説明した。
## begin(逐次評価)
    (begin [body_form ...])
    body_form -- 逐次評価する式
beginは左から順に式を評価していく。
引数がある場合は最後の式の評価結果を返し、ない場合はnilを返す。
主に副作用を期待するマクロの展開結果に含まれる。
組み込みでは、forやwhileなど複数の式を実行するマクロの展開結果に含まれる。
このように利用者が直接見ることはないが、
暗に利用されているbeginを暗黙のbeginという。
## fn(無名関数)
    (fn ([var ...  [:opt var_value ...] [:rest var] [:key var_value ...]])
        body_form ...)
    var_value ::= {var | (var value)}
    var -- 仮引数名
    value -- 仮引数の初期値
fnは関数を作成するスペシャルオペレーターである。
fnに与える引数は、名前を指定しないという点を除いてfunctionと全く同じである。
fnが作る関数のことをその名前がないことにちなみ、無名関数という。
無名関数は汎関数を使うときにしばしば用いられる。
## if(条件分岐)
ifは条件分岐の章で述べた。
## label/goto(ジャンプ機構)
    (label statement ...)
    statement ::= {label_name | goto_form | other_form}
    goto_form ::= (goto label_name)
    label_name -- ジャンプ先を表すキーワード
    other_form -- 上記以外の式
labelは制御をジャンプさせるためのコンテキストを作る。
goto文を使用するとlabel内で定義したキーワードへ制御がジャンプする。
label/gotoを直に使用することはほとんどなく、
forやwhile等のマクロを定義するために使用する。
## macro(マクロ)
マクロの章で述べる。
## quote(評価見送り)
quoteは引数を評価しないようにするスペシャルオペレーターである。
    (quote expr)
    expr -- 評価しない式
次のように引数の値がそのまま返される。
    ) (<- a 3)
    3
    ) a
    3
    ) (quote a)
    a
このように、評価を見送ることをクォートするという。
Parenでは、クォートすることが頻繁にあるため、
そのための構文糖が用意されてある。
構文糖を使用するには次の例のように、
クォートしたい対象に`'`(クォート)を前置すればよい。
    ) 'a
    a
定数のリストを用いるときに利用することが多い。
    ) '(1 2 3)
    (1 2 3)
そのほか、評価するタイミングをずらすためにマクロ定義に頻繁に利用される。
## try/catch/finally/throw(例外処理機構)
    (try [body_form ...]
        [(catch (type var) catch_body_form ...) ...]
        [(finaly catch_body_form ...)])
    (throw exception)
try/catch/finally/throwは例外処理機構を扱うためのスペシャルオペレーター群である。

# マクロ
マクロはParenが読み込まれ、リードマクロが展開された後に評価される。
マクロはリードマクロ、マクロ、スペシャルオペレーター、 関数等、
すべてのParenの機能を使用してユーザが定義することができる。
マクロは使用される前に定義がされている必要がある。
マクロ展開は、展開結果にマクロが含まれなくなるまで再帰的に行われる。
一般的に、マクロとは次のようなプログラムのことを指す。
    あるプログラムが実行される前処理に実行されるプログラム
プログラムを書くプログラムといっても大きく外れていない。
Parenのマクロがほかの非Lisp系言語と大きく異なるのは、
マクロがそうでないプログラムと調和していることである。
例えば、C言語のそれはC言語とは全く関係ない別の言語に等しく、
ただ単に、文字列の置換を行っているに過ぎない。
一方でParenのそれはParenの関数やマクロを用いて定義できる。
## マクロ定義
マクロはスペシャルオペレーターmacroを使って定義する。
    (macro macro_name (args)
         body_form ...)
    macro_name -- 定義するマクロ名
    args -- マクロの引数
    body_form -- 展開結果
ここで、マクロの引数は無名関数を作るスペシャルフォームfnと同じ引数を受け取る。
macroで定義したマクロは関数と同じように呼び出す。
## マクロの評価
マクロが評価されることをマクロ展開という。
マクロ展開の結果のS式がプログラム実行時に再度評価される。
## 組み込みのマクロ
ここでは組み込みのマクロの一部を示す。
### 束縛マクロ
Parenには算術にまつわる次の束縛マクロが定義されている。
    手続き 処理
    --------------------------------------------
    ++     シンボルに1足した結果を束縛
    --     シンボルに1引いた結果を束縛
    +=     シンボルに+を評価した結果を束縛
    -=     シンボルに-を評価した結果を束縛
    /=     シンボルに/を評価した結果を束縛
    *=     シンボルに*を評価した結果を束縛
これらと等価な式を示す。
    (++ var) <=> (<- var (+ var 1))
    (-- var) <=> (<- var (- var 1))
    (+= var val) <=> (<- var (+ var val))
    (-= var val) <=> (<- var (- var val))
    (*= var val) <=> (<- var (* var val))
    (/= var val) <=> (<- var (/ var val))
    var -- シンボル
    val -- 増減値
一般にLisp系言語で束縛は禁忌と見做されがちだが、その記述の簡潔さのためであればParenでは積極的に使用する。
### 関数定義マクロ
functionは名前付きの関数を定義するためのマクロである。

# リードマクロ
リードマクロはParenのリーダーに新しく構文規則を追加する機能である。
そのため、Parenには構文があってないようなものであるということを垣間見る。
## リードマクロの定義
リードマクロはreadmacroマクロにより定義できる。
    (readmacro matcher expander)
    matcher -- リードマクロが実行される文字の列
    expander -- 入力ストリームを受け取るリードマクロの展開時に実行される関数
書式だけでは実際にどのようにリードマクロを定義するのかわかりにくいため、
有用なリードマクロの定義をいくつか示す。
## 複数行コメント
コメントの章でParenには複数行コメントがないが、
リードマクロによって簡単に定義できると述べた。
ここでは、Common Lispの複数行コメントを定義する。
Common Lispでは、`#|`から始まり、`|#`までの文字の列がコメントと見做される。
そのようなリードマクロは次のように定義できる。
    (readmacro #|
      (fn (stream)
        (<-
        body_form ...))

# goto文
TODO

# 例外処理機構
TODO

# クラス
Parenは関数型言語として設計されているが、
マクロの力により手続き型言語として使用することも十分可能であることを見てきた。
ここではマクロを用いてParenの上に構築されたオブジェクト指向言語について述べる。
以後、このドメイン特化言語をPOS(Paren Object System)と呼ぶ。
POSはCommon LispのCLOSから強い影響を受けているが、
強力すぎる機能をそぎ落とし、使用頻度が高い必要最低限の機能に抑えてある。
また、実装は簡潔に心がけ必要に応じてハックできる余地も残してある。
この章は、読者にオブジェクト指向の知識があることを前提として述べる。
## クラスの作成
クラスはマクロclassにより作成する。
    (class class_name (super_class ...)
        field ...)
    class_name -- 作成するクラスの名前
    super_class -- 作成するクラスのスーパークラス
    field -- 作成するクラスのインスタンスシンボル
書式から分かるように、POSでは次の特徴がある。
- 型の多重継承
- メソッドがクラスに属さない
classマクロは概ね、次のようなS式に展開される。
展開結果から分かるように、内部的にはただのマップである。
    (<- Class #{:type :class_name
                :super (list super_class ...)
                :fields #{:field false ...}})
例として二次元ベクトル空間の元を表すクラスPointを示す。
    (class Point () x y)
例のように、Parenではクラス名は慣習としてパスカルケースを用いる。
## インスタンスの生成
インスタンスの生成にはnewマクロを使用する。
    (new class [var val] ...)
    class -- 生成するインスタンスのクラス
    var -- インスタンスシンボル名称
    val -- varの初期値
前述したPointクラスのオブジェクトは次のように生成する。
    (<- p (new Point))
必要に応じてインスタンスシンボルを初期化することもできる。
初期化されていないシンボルの値はfalseとなる。
    (<- q (new Point :x 3 :y 4))
## インスタンスの型
インスタンスの型を調べるにはtypeマクロを使用する。
    (type class)
    class -- クラス名
クラスの型はクラス定義の際に、クラス名に対応するキーワードが自動的に設定される。
    ) (type p)
    :Point
また、型を判定する述語としてtype?マクロがある。
これはただ単に、同一判定をするS式に展開するマクロである。
    (type? p :Point) <=> (same? (type p) :Point)
## インスタンスシンボルの参照と代入
POSではクラス定義と同時にインスタンスシンボルへのアクセサが自動生成される。
自動生成されるアクセサはインスタンスシンボル名の前に`.`を付けたものとなる。
そのため、メソッド以外の識別子を`.`から始めることは推奨しない。
    ) (<- p (new Point :x 0 :y 0))
    p
    ) (.x p)
    :3
    ) (.x p 3)
    p
    ) (.x p)
    3
## メソッドの定義
メソッドの定義はmethodマクロを使用する。
    (method (required_params [:opt option_param ...]
                             [:key key_param ...]
                             [:rest rest_param])
        body ...)
    required_params ::= (class required_param) ...
    option_param ::= (option_param [initial_value]) ...
    key_param ::= (key_param [initial_value]) ...
    class -- メソッドを決定するクラス
    required_param -- 必須パラメーター
    option_param -- オプショナルパラメーター
    rest_param -- レストパラメーター
    body -- メソッド本体
methodは型とシンボル名のリストを必須パラメーターに指定するようなfunctionだと思えばよい。
二次元ベクトル空間上の元の和を返すメソッドを例として示す。
    (method .add ((Point p1) (Point p2))
        (new Point :x (+ (.x p1) (.x p2))
                   :y (+ (.y p1) (.y p2))))
なお、このメソッドを可変長引数に拡張することは、
methodで指定できるパラメーターが柔軟なため容易である。
作成したメソッドはクラスとは別のグローバルシンボル$methodに登録される。
このマクロはグローバルシンボル$methodにメソッド登録するS式に展開される。
先ほどの.addは概ね次のようなS式に展開される。

if .addが環境に存在するか .add関数の作成
else if .addがメソッドか .add関数にメソッド登録
else 衝突エラー

.add関数の実装イメージ
(function .add (&rest params)

    (add_method ({} $method .add)
                '(Point Point)
                '(new Point :x (+ (.x p1) (.x p2))
                            :y (+ (.y p1) (.y p2))))

$methodはキーにメソッド名称、値にその型ごとの実装のハッシュマップを持つ、
ハッシュマップである。
生成したオブジェクトの初期化は、慣習としてinitメソッドを定義してそこで行う。
    (init (new Point) :x 4 :y 5)
このようなinitは次のように定義されているであろう。
    (method init ((Point p) :key (x 0) (y 0))
        (.x p x)
        (.y p y))
例に示すように、実はインスタンス定義したインスタンスシンボルは、
自動でアクセサが生成される。
    (class Point () x y)
    (method .x ((Point p) :opt x)
      (if (false? x) ({} ({} :fields p) :x))
          (:else ({} ({} :fields p) :x x))))
    (method .y ((Point p) :opt y)
      (if ((nil? y) ({} ({} :fields p) :y))
          (:else ({} ({} :fields p) :y y))))
Parenでは宣言したインスタンスシンボルはすべて外部に公開する仕様である。
このことは、作成するクラスにドキュメントを書くことと、
使用するクラスのドキュメントを読むことを後押しする。
また、クラスをハックする手段を意図的に残している。

# Common Lispとの違い
Lisp経験者のために代表的なCommon Lispとの違いを述べる。
ただし、この中には言語で吸収できる差も含まれる。
## 束縛演算子
Common Lispでシンボルの束縛を行う場合、次のロジックで処理が行われる。
    1. 現在の環境にシンボルが束縛されている場合はその値を更新する。
    2. そうでなければ親の環境を辿っていき、見つかった場合はその環境の値を更新する。
    3. 親の環境にシンボルが束縛されていなかった場合は大域環境にシンボルを束縛する。
Parenでは二種類の束縛演算子が用意されていて、Common Lispの束縛演算子に加えて、必ず現在の環境に束縛する演算子が存在する。
    演算子 処理
    --------------------------------------
    ->     必ず現在の環境にシンボルを束縛
    -->    Common Lispのsetq相当の処理
これにより、letで明示的にシンボルを束縛してから代入を行う必要がなくなり代入の使用が容易になっている。
また、親の環境を辿る代入演算子も残すことによりクロージャの作成もできる。
シンボル以外に代入可能な式は次のように、アクセサの第二引数に代入値を指定する。
    左辺一覧
    対象   参照            代入
    -------------------------------------------
    シンボル   var             (<- var val)
    コンス (car var)       (car var val)
           (cdr var)       (cdr var val)
    配列   ([] var index)  ([] var index val)
    マップ ({} var index)  ({} var index val)
    構造体 (get var index) (set var index val)

## シンボルの変換
両者ともシンボルの大文字小文字を区別するが、Common Lispはデフォルトで大文字に変換するのに対して、Parenでは一切変換を行わない。

## 述語の名称
Parenでは述語の末尾を`?`で終わらせることを推奨している。

## 純リスト
Parenのリストはすべて純リストである。これは、リスト操作関数の定義に一貫性を持たせるための変更点である。
- position
- member
- find
例えば、Common Lispにて次の関数のうち純リスト以外での動作が規定されているのはどれかという問いに答えるのは難しい。

Parenの場合はすべてである。

## 命名規約
ParenはCommon Lispとは異なる命名規約をとっている。
    対象            命名方法
    --------------------------------------------------------
    ファイル                  スネークケース
    定数                      すべて大文字のスネークケース
    ローカルシンボル              キャメルケース
    グローバルシンボル            `$` + キャメルケース
    クラス                    パスカルケース
    キーワード                `:`から始まるキャメルケース
                              (ただし、型を表す場合はパスカルケースとする。)
    述語                      末尾に`?`を付ける
    破壊的処理                末尾に`!`を付ける
    束縛系のマクロ            withから始める
    アナフォリック系のマクロ  最後に`*`を付ける
    構造体                    パスカルケース
