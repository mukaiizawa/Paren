Parenチュートリアル

# 概要
このチュートリアルはParenの基本文法を早巡りすることを目的とする。読者には計算機科学の知識があることを前提とし、いくつかの専門用語は定義することなしに使用している。

ParenはS式によって記述されるプログラミング言語Lispの方言である。オブジェクトシステムなど着想の多くはCommon　Lispから受けている。Common Lispと最も異なる特徴を一つ上げるなら、Parenは手続き型言語としての側面が強いことである。一般に、代入が少ないプログラムはそうでない場合に比べ堅牢であるが冗長になりがちである。Parenは代入のリスクを自己管理でき、必要に応じて使用する玄人のための言語である。勿論、Lispユーザを魅了してやまない玄人のための機能、マクロも使える。

Parenは次の点を重視している。
- 開発速度
- ソースコードの短さ
逆に、次の点は犠牲となっている。
- 実行速度
- 堅牢さ

# 目次
- 書式
- 序章
- コメント
- 数値
- 文字列
- キーワード
- リスト
- 関数
- 変数
- 環境
- 条件分岐
- 反復
- 配列
- マップ
- スペシャルオペレーター
- マクロ
- リードマクロ
- 例外処理
- クラス
- Common Lispとの違い
- 付録

# 書式
この文書内の書式は次の規則で記述してある。
    記号 定義
    ----------------------------------------
    [ ]  []内は省略可能
    { }  {}内から一つ選択
    |    []、{}内の代替候補の区切り文字
    ...  直前の構文の零回以上の繰り返し
    ::=  左辺を右辺で定義
    --   左辺の右辺による説明
    =>   左辺の評価結果は右辺

# 序章
この章ではいくつかの簡単なプログラムを示すことを目的とする。

## Parenの実行
parenを起動するとreplが実行される。
    $ paren
    ) 
`)`がプロンプトである。プロンプトに続けてプログラムを記述すると、評価されて結果が返る。
    ) 1
    1
    ) (+ 1 2 3 4)
    10
    ) (* (+ 1 2) 3 4)
    36

Parenのプログラムは演算子を前置し、被演算子と共に括弧で括る。このように演算子を前置する記法をポーランド記法乃至、前置記法といい、Parenの特徴の一つとなっている。

## hello world
あるプログラミング言語を習得する唯一の方法は、その言語でプログラムを書くことである。そしてそれは、慣習により次のプログラムを書くことから始まる。
    次の文字列を印字せよ。
    hello world
文字列を印字するにはwrite_lineを使用する。
    ) (write_line "hello world")
    hello world
    "hello world"
write_line呼び出しによる二つの行はそれぞれ
1. write_lineが標準出力へ出力した結果
2. replが印字した式の評価結果
を意味する。
write_line関数は引数を標準出力に印字すると同時に、評価結果として引数を返す。
すべての式はwrite_lineのように必ず値を返す。この仕様はParenの特徴の一つである。

## 複写関数
もうひとつの例として標準入力から標準出力に複写する関数copyを作成する。
    ; copy 第一版
    (function copy ()
      (<- ch nil)
      (while ((!= ch :EOF))
        (<- ch (read_byte))
        (write_byte ch)))
関数を定義するにはfunctionマクロを使用する。例ではcopyという引数がない関数を定義している。

関数の本体では、chという変数にread_byteで標準入力から取得した文字を代入している。そのあとに、chに代入された文字をwrite_byteで標準出力に書き出している。
このプログラムは、
    Parenのすべて式は評価されると値を返す。
という性質を用いてより簡潔に書ける。
代入オペレータ―は代入した値を返すように設計されている。そのため、C言語のような簡潔なコードを記述することができる。
    ; copy 第二版
    (function copy ()
      (while ((!= (<- c (read_byte)) :EOF))
        (write_byte ch)))
この書き方の方がよりParenらしい。ただし、返り値を濫用すると可読性を下げることがあるため注意が必要である。

# コメント
コメントはParenに無視される。そのため、プログラムの補足などに用いる。
## 一行コメント
Parenは`;`から行末までをコメントと見做す。
これを一行コメントと呼ぶ。
    ; コメント
    ;; これもコメント
## 複数行コメント
Parenには複数行に跨がれるコメントは言語仕様として存在しない。ただし、複数行に跨がれるコメントが必要になった場合は後述するリードマクロで容易に定義できる。

# 数値
数値は数値リテラル、演算結果などにより作成される。
## 数値リテラル
Parenでは数値がそのまま数値リテラルと見做される。
## 評価
数値は評価されると自身を返す。
    ) 3
    3
    ) 3.141592
    3.141592
すべての実数は数値型のオブジェクトとして扱われる。
## 算術関数
代表的な算術関数を次に示す。
    関数  処理
    -------------------
    +     加算
    -     減算
    *     乗算
    /     除算
    **    冪乗
    //    切り捨て除算
    mod   余り
これらの実行例を示す。
    ) (+ 3 4 5)
    12
    ) (- 10 4 5) ; <=> (- (- 10 4) 5)
    1
    ) (* 3 4 5)
    60
    ) (/ 3 4 5)
    0.15
    ) (/ 3)
    0.33333
    ) (** 2 3)
    8
    ) (// 5 4)
    1
    ) (mod 6 4)
    2
非Lisp系言語では二項演算子として定義してあるものも、Parenでは可変長引数の関数に過ぎない。

# 文字列
文字列は文字列リテラルや組み込みのto_str関数等で作成できる。
## 文字列の作成
文字列リテラルはダブルクォートで囲まれた文字の列である。
    ) "hello paren"
    "hello paren"
Parenオブジェクトから文字列を作成するにはto_strを使用する。
文字列は評価されると自身を返す。
to_str関数はParenのオブジェクトの印字表現を返す。
    ) (to_str 123)
    "123"
## 文字列の結合
文字列の結合はstrcatを使用する。
    ) (strcat "hello" "_" "paren")
    "hello_paren"
## 文字列の長さの取得
文字列の長さを取得するには組み込み関数のlengthを使用する。
    ) (length "hello paren")
    11
## 部分文字列の取得
部分文字列を取得するにはsub_strを使用する。
    ) (sub_str "hello paren" 6)
    "paren"
    ) (sub_str "hello paren" 0 5)
    "hello"
第一引数のみ指定されている場合はその値以降の部分文字列を取得する。
第二引数まで指定してある場合は、
第一引数から第二引数の値の前までの部分文字列を取得する。
ただし、どちらの場合も零から数える。
## 文字列の比較
文字列の比較は比較関数`=`で行う。
    ) (= "hello paren" "hello paren")
    true
    ) (= "Hello Paren" "hello paren")
    false
## 部分文字列が含まれるか判定
部分文字列が含まれているかどうか判定するにはinclude?を使用する。
    ) (include? "Hello Paren" "Hello")
    true
    ) (include? "Hello Paren" "hello")
    false
## 文字列の先頭がある部分文字列と一致するか判定
startWith?は文字列が特定の文字列で始まっているかを判定する。
    ) (startWith? "Hello Paren" "Hello")
    true
    ) (startWith? "Hello Paren" "hello")
    false
## 文字列の末尾がある部分文字列と一致するか判定
endWith?は文字列が特定の文字列で終了しているか判定する。
    ) (endWith? "Hello Paren" "Paren")
    true
    ) (endWith? "Hello Paren" "Hello")
    false
## 正規表現
Parenで正規表現を使用したい場合は:Regexモジュールをインクルードする。
詳細は:Regexモジュールのドキュメントを参照のこと。

# キーワード
キーワードは同名であるならばプログラムでただ一つだけ存在するという性質を持つ。
キーワードを作成するには次のいずれかの方法を用いる。
- キーワードリテラルを使用する
- to_key関数を使用する
ただし、その性質上すでにシステムにその名前のキーワードが存在する場合、
新しくオブジェクトが作成されることはなく、その参照が返される。
## キーワードリテラル
キーワードリテラルは`:`から始まる英数字と一部の記号の列である。
次のいずれも有効なキーワードリテラルである。
    :0123
    :keyword_literal
厳密な仕様については言語仕様書の字句定義の章を参照のこと。
## to_key関数
to_key関数は文字列を受け取り、それに対応するキーワードを返す。
    ) (to_key "key")
    :key
## キーワードの評価
キーワードは評価されると自身を返す。
    ) :key
    :key

# リスト
リストはParenにおいて最も重要なオブジェクトであり、
同時にParenを記述するプログラムでもある。
## コンスの作成
リストを理解するためにはコンスを理解する必要がある。
コンスとは次に定義されるParenのオブジェクトである。
    次の条件を満たすParenのオブジェクトへのポインタcar、cdrの組をコンスという。
    carとは、任意のParenのオブジェクトを指すポインタのことをいう。
    cdrとは、コンス又は定数nilを指すポインタのことをいう。
コンスは組み込み関数consにより作ることができる。
consの第一引数、第二引数が、それぞれ作成されるコンスのcarとcdrに対応する。
    ) (cons 1 nil)
    (1)
    ) (cons 1 (cons 2 nil))
    (1 2)
    ) (cons (cons 1 nil) (cons 2 nil))
    ((1) 2)
コンスの定義から外れるような引数をconsに与えるとエラーとなる。
Parenはコンスを次の手順で印字する。
1. 左括弧を印字
2. carが指す値を印字する
   cdrが指す値がnilなら3を行う
   そうでなければ、再びcdrが指すコンスに対して2を行う
3. 右括弧を印字
図示すると次のようになる。
    ) (cons 1 (cons 2 (cons 3 nil)))
    (1 2 3)
    +-----+-----+
    | car | cdr |
    +-----+-----+
       |     |    +-----+-----+
       |     +--->| car | cdr |
       |          +-----+-----+
       |             |     |    +-----+-----+
       |             |     +--->| car | cdr |
       |             |          +-----+-----+
       |             |             |     |
       |             |             |     +---> nil
       1             2             3
あるコンスのcarがコンスを指している場合でもそのルールは再帰的に適用される。
    ) (cons (cons 1 nil) (cons 2 (cons 3 nil)))
    ((1) 2 3)
    +-----+-----+
    | car | cdr |
    +-----+-----+
       |     |    +-----+-----+
       |     +--->| car | cdr |
       |          +-----+-----+
       |             |     |    +-----+-----+
       |             |     +--->| car | cdr |
       |             2          +-----+-----+
       |                           |     |
       |    +-----+-----+          |     +---> nil
       +--->| car | cdr |          3
            +-----+-----+
               |     |
               |     +---> nil
               1
このように、あるコンスのcdrで辿れるコンス全体が括弧で囲われて印字される。
コンスのcdrで辿れるコンス全体のことをリストという。
これは、辿れるコンス全体が単方向リストと見做せるからである。
下に、その対応関係を示す。
    値   対応
    ---------------------------------------------
    cons 単方向リストのセル
    car  単方向リストが格納するオブジェクトへのポインタ
    cdr  次の単方向リストのセルへのポインタ
    nil  単方向リストの終端
あるコンスのcdrを辿っていった終端がnilを指している場合、
そのコンス全体は純リストであるという。
コンスの定義により、Parenの任意のリストはすべて純リストである。
純リスト以外のリストが作れないという制約は
ほかのLisp系の言語と比べると奇妙かもしれない。
最後に、Parenにはあるオブジェクトがリストか判定する関数と
コンスか判定する関数がそれぞれ存在する。
    ) (list? 1)
    false
    ) (cons? 1)
    false
    ) (list? (cons 1 nil))
    true
    ) (cons? (cons 1 nil))
    true
    ) (list? nil)
    true
    ) (cons? nil)
    false
この二つの関数は空を表す擬似変数nilを与えた場合を除き同じ結果を返す。
空を表す擬似変数nilに対してlist?がtrueを返すのは自然な実装であると考えられる。
以後、nilが要素がないリストのこと指している場合は空のリストと呼ぶ。
## リストの作成
リストはcons関数により作られるが、
複数の要素を持つようなリストを作ろうとすると、すぐに困ったことになる。
    ) (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 nil)))))
    (1 2 3 4 5)
そのため、Parenには引数を要素に持つようなリストを作成するための関数、
listが存在する。
    ) (list 1 2 3 4 5)
    (1 2 3 4 5)
リストの定義により、要素がリストであるようなリストも作成することもできる。
    ) (list (list 1 (list 2 3) 4 5))
    ((1 (2 3)) 4 5)
ここで、Parenのリストを作成する記述そのものが、
Parenのリストになっていることに注意されたい。
## carとcdrの参照
コンスが指す二つのポインタcar、cdrの指す場所を得る関数があり、
それぞれcarとcdrという。
    ) (list 1 2)
    (1 2)
    ) (car (list 1 2))
    1
    ) (cdr (list 1 2))
    (2)
    ) (car (cdr (list 1 2)))
    2
carとcdrは引数が空のリストである場合はnilを返す。
    ) (car nil)
    nil
    ) (cdr nil)
    nil
    ) (car (cdr (cdr (list 1))))
    nil
リストの要素を参照するときにcarとcdrを組み合わせることは頻繁にあるため、
計四回までリストを辿るすべての組み合わせが定義されている。
    caar cadr cdar cddr
    caaar caadr cadar caddr cdaar cdadr cddar cdddr caaaar
    caaadr caadar caaddr cadaar cadadr caddar cadddr cdaaar cdaadr cdadar
    cdaddr cddaar cddadr cdddar cddddr
これらの関数については合成規則が分かるような等価な式を例示することにとどめる。
    (caar lis) <=> (car (car lis))
    (caddr lis) <=> (car (cdr (cdr lis)))
    lis -- 引数のリスト
## carとcdrへ代入
コンスのcarとcdrが指す場所を変更するには、
それぞれcar、cdr関数の第二引数に値を指定する。
    ) (car (list 0 0 0) 1)
    (1 0 0)
これはすべての操作関数について成り立つ。
    ) (cdddr (list 0 1 2) (list 3 4 5))
    (0 1 2 3 4 5)
cdrが指す値を書き換える際、純リストでなくなるような代入はできない。
## リストの評価
ParenはS式によって記述される。
S式とはアトム又はリストのことをいう。
リスト以外のオブジェクトのことを総称してアトムという。
    S式
      - アトム
        - 数値
        - 文字列
        - 配列
        - 関数
        - マクロ
      - リスト
S式は評価されると値を返す。
アトムは、後述する変数を除いて評価されると自身を返す。
リストは次の手順で評価される。
    (operator [arg] ...)
    operator -- オペレーター
    arg -- オペレーターに渡る引数
リストが評価されるとき、まず最初にオペレーターが評価される。
オペレーターはリストであっても構わず、その場合は再帰的に処理が行われる。
次に、評価したオペレーターの種類にしたがってリストを評価する。
Parenのオペレーターには次の三種類が存在する。
- 関数
- スペシャルオペレーター
- マクロ
オペレーターの評価結果が上記のいずれでもない場合はエラーとなる。
### 関数の評価
関数は、すべての引数が評価されてから評価される。
    ) (+ (- 1 1) (* 2 2) (* 3 3))
    13
関数`+`、`-`、`*`の引数はそれぞれ評価されてから渡される。
### スペシャルオペレーターの評価
スペシャルオペレーターはParenに組み込まれている特殊なオペレーターで、
その種類ごとに引数の評価のされ方が異なる。
詳しくはスペシャルオペレータので述べる。
### マクロの評価
マクロはすべての引数を評価せずに評価される。
ただし、その定義のされ方によっては引数が評価されているようにも見える。
詳しくはマクロの章で述べる。
## プログラムとデータ
評価結果が評価可能なリストであるようなリストを考えることができる。
このことは、任意のParenのプログラムはParenのデータであるということと相まって、
ParenのデータはParenのプログラムになりうるということを意味する。
データとプログラムを相互に変換可能であることは、
プログラムを書くプログラムを書きやすくする。
実際、マクロはこの事実に着眼した機能であり、Parenを強力な言語にしている。

# 関数
関数はParenの根幹をなすオブジェクトである。
ただし、この文書内における関数という単語は、
計算幾何学における手続き(サブルーチン)程度の意味しかない。
## 関数の定義
関数を定義するにはマクロfunctionを用いる。
    (function function_name ([var ...
                             [:opt var_value ...]
                             [:rest var]
                             [:key var_value ...]])
        body_form ...)
    var_value ::= {var | (var value)}
    function_name -- 定義する関数名
    var -- 仮引数名
    value -- 仮引数の初期値
functionの第一引数、第二引数、第三引数以降のことを、
それぞれ、定義する関数の関数名、仮引数、本体という。
functionは与えられた名前の関数を定義し、その関数を返す。
    ) (function double (x) (* 2 x))
    double
    ) (double 4)
    8
functionで定義する関数は、組み込みのそれと何ら変わらない。
## 関数呼び出し
関数を呼び出すには、関数名とその引数をリストにして評価すればよい。
    ) (double 3)
    6
    ) (double 4)
    8
関数の仮引数と一致しない場合はエラーとなる。
関数の実引数の評価は必ず左から順に評価される。
## 仮引数
仮引数には次の種類がある。
1. 必須パラメーター
2. オプショナルパラメーター
3. レストパラメーター
4. キーワードパラメーター
任意のパラメーターを同時に組み合わせて指定することができるが、
同時に指定する際は、上の順番で指定しなければならない。
### 必須パラメーター
必須パラメーターは関数呼び出し時に必ず与えなければならない仮引数を定義する。
関数呼び出し時に必須パラメーターが足りない場合はエラーとなる。
    ) (function avg2 (x y)
        (/ (+ x y) 2))
    ) (avg 2 4)
    3
### オプショナルパラメーター
オプショナルパラメーターは関数呼び出し時に省略可能な仮引数を定義する。
仮引数の`:opt`句に変数名と初期値をリストにして指定する。
関数呼び出し時にオプショナルパラメーターが省略された場合は初期値が使用される。
    ) (function x_add_y (x :opt (y 1))
        (+ x y))
    x_add_y
    ) (x_add_y 3)
    4
    ) (x_add_y 3 2)
    5
オプショナルパラメーターの初期値を指定しない場合は、
実引数で指定されなかった場合にnilが初期値となる。
そのため次の二つの関数の仮引数は等価である。
    (function f1 (:opt x) ...)
    (function f2 (:opt (x nil)) ...)
オプショナルパラメーターは複数定義することもできる。
    ) (function concat (s1 :opt (s2 "") (s3 ""))
        (+ s1 s2 s3))
    ) (concat "hello")
    "hello"
    ) (concat "hello" " world")
    "hello world"
    ) (concat "hello" " world" "!!")
    "hello world!!"
ただし、i番目のオプショナルパラメーターを指定して関数を呼びたい場合は、
i - 1番目までのオプショナルパラメータをすべて指定する必要がある。
### レストパラメーター
レストパラメーターは可変長な実引数を受け取る仮引数を定義する。
仮引数の`:rest`句に可変長引数を定義する。
関数呼び出し時に仮引数よりも多い実引数がリストになり、
指定したレストパラ―メーターに束縛される。
    ) (function first_rest (first :rest rest)
        (list first rest))
    ) (first_rest 1 2 3)
    (1 (2 3))
レストパラメーターに束縛される実引数がない場合はnilが束縛される。
    ) (first_rest 1)
    (1 nil)
### キーワードパラメーター
キーワードパラメーターは、順序を問わない名前付きの仮引数を定義する。
仮引数の`:key`句に指定する。
キーワードパラメーターには初期値を与えることができ、
呼び出し時にキーワードパラメーターが省略された場合は初期値が使用される。
    ) (function test_key (:key (k1 1) (k2 2) k3)
        (list k1 k2 k3))
    test_key
    ) (test_key)
    (1 2 nil)
    ) (test_key :k1 -1)
    (-1 2 nil)
キーワードパラメーターの仮引数の順序と実引数の順序は一致しなくてもよい。
    ) (test_key :k3 3 :k1 -1)
    (-1 2 3)
## 汎関数
前述したように関数はアトムの種類の一つに過ぎない。
そのため、他のデータ型である数値や文字列と同様に、
変数に代入したり、関数に引数として渡したり、
関数の返り値として返したりすることができる。
ここで、関数全体の集合のうち関数を引数に受け取る、
または、返り値が関数であるように定義された関数を汎関数乃至、高階関数という。
## 汎関数ユーティリティ
Parenに組み込みで用意されている汎関数を例示する。
汎関数を用いることにより、高度な抽象化を用いることができる。
### リストを写像する
    (map fn list ...) => result
    fn -- 写像関数
    list -- 写像前のリスト
    result -- 写像後のリスト
mapは引数のリストを写像した結果を返す汎関数である。
次の例は、引数のリストを二倍する。
    ) (function double (* 2 x))
    double
    ) (map double (list 1 2 3))
    (2 4 6)
### リストをグルーピングする
    (group_by fn list) => result
    fn -- グループ分けするカテゴリを返す関数
    list -- グループ分けするリスト
    result -- グルーピングされたリスト
groupは指定した関数が返した結果でグルーピングする。
    ) (group abs (list -1 1 2 -3 3))
    ((1 -1 1) (2 2) (3 -3 3))
### リストから要素を取り除く
    (remove_if fn list) => result
    fn -- 要素を取り除くか決める関数
    list -- 要素を取り除く対象のリスト
    result -- 要素を取り除いた後のリスト
次に、負の数を取り除く例を示す。
    ) (remove_if minus? (list 1 -2 3))
    (1 3)
## 再帰関数
関数全体の集合のうち、関数の本体で自分自身を呼ぶような関数を再帰関数と呼ぶ。
再帰関数を用いると直感的にプログラムできることがある。
再帰関数の例として整数nの階乗を求める関数factorialを示す。
    (function factrial (n)
        (if (= n 1) 1
            (* n (factorial (- n 1)))))
これはfor文を用いるより、直感的である。
    (function factrial (n)
        (<- result n)
        (while ((!= n 1) result)
            (*= reult (-- n))))
また、再帰関数全体の集合のうち、
自身の呼び出しごとにスタックが積まれないような関数を末尾再帰関数という。
上記のfactorialは呼び出しごとにスタックが積まれていくため末尾再帰関数ではない。
factorialは次のような末尾再起関数に変換できる。
    (function factorial (n :opt (acc 1))
        (if (= n 1) acc
            (factorial (- n 1) (* acc n))))
## 純粋関数
関数全体の集合のうち、次の性質を持つものを特に純粋関数という。
- 任意の引数に対して、返り値が時間に依存せずに一意に定まる
- 他に何も影響を与えない
このような性質を参照透過性という。
また、二つ目の性質
    他に何も影響を与えない
のことを副作用という。
次のような処理は副作用がある。
- 代入
- 入出力
定義から、次のような関数は純粋関数ではない。
- あるグローバル変数の値の3倍の数を返す関数
- 引数を標準出力に印字する関数
- 引数の値を3倍に変更する関数
- 現在時刻をシードとした0か1の乱数を返す関数を返す関数
逆に、次の処理を行うだけの関数は純粋関数である。
- 引数を返す関数
- 引数の文字列表現を返す関数
- 引数の値の3倍の値を返す関数
- 引数をシードとした0か1の乱数を返す関数を返す関数
可能な限りプログラムは純粋関数で構成することが望ましい。
これは、純粋関数はそうでない関数に比べてとりうる状態が少なく、
一般的に汎用的な処理になりバグも発生しにくいことによる。

# 変数
Parenには変数に値を代入、参照する仕組みがある。
この章では簡単な使用例をいくつか挙げるだけにとどめ、
読者の理解のために厳密には誤った表現も用いる。
## 変数名
Parenの変数名は数字以外の英文字と一部の記号から始まり、
その後、英数字と一部の記号が続く。
次のいずれもParenの変数名として有効である。
    var
    x1
Parenでは様々な記号も変数名に使用することができる。
次にあげる変数名は(推奨しないが)すべて有効である。
変数名称で使用できる文字の厳密な定義は言語仕様書の字句解析の章を参照されたい。
    !$*+-0-9abc?
    m<__.__>m
一般に、複数の単語で構成されている変数名は、
単語の区切れをアンダースコアで区切る。
    user_name
    neighbor_node
## 代入処理
Parenの組み込みの特殊な評価を行うオペレーターのことを、
スペシャルオペレーターという、
変数に値を代入するにはそのうちの一つの`<-`オペレーターを使用する。
以降は代入オペレーターと呼ぶ。
    (<- variable_value ...) => result
    variable_value ::= var value
    var -- 変数名
    value -- 変数に代入する値
    result -- 最後に代入した値
代入オペレーターは変数varに代入する値valを組にして受け取る。
Parenでは代入する前に変数を宣言する必要はない。
代入オペレーターは最後に代入した値を返す。
    ) (<- a 0 b 1)
    1
代入オペレーターで複数の代入を行う場合は、
すべて左から順に評価されることが保証されている。
     ) (<- x (write_line 3)
           y (write_line (* x 2)))
     3
     6
     6
Parenが組み込みで使用している変数に値を代入することもできるが、
ほとんどの場合、ユーザの予期せぬ動作となってしまうだろう。
## 参照
変数は評価されると代入されている値を返す。
    ) (<- a 3 b 4)
    4
    ) a
    3
    ) b
    4
ただし、変数に値が代入されていない場合はエラーとなる。
## 定数
宣言時に初期値を代入し、それ以降は参照しかできない変数のことを定数という。
Parenには組み込みで次の定数が存在する。
    定数  初期値 意味
    ---------------------------------------------
    true  自身   真の代表値
    false 自身   偽の代表値
    nil   自身   空の代表値
定数に値を代入しようとするとエラーになる。
Parenでは組み込み以外の定数を定義することができない。
そのため、定数として扱う変数は、
慣習として他の変数と見分けがつくように大文字の変数名を使用する。
    ) (<- PI 3.141592
          MAX_BUF_SIZE 256)
    256
定数として扱う変数の値は容易に更新できてしまうため、
プログラマが注意して扱う必要がある。
    ) (<- PI 3)
    3

# 環境
Parenが変数とそれに対応づけられた値との関係を、
環境と呼ばれるモデルを採用して管理している。
Parenの変数について理解するために、環境の理解は必須となる。
## 環境モデル
式が評価される場合、必ずどこかの環境の下で評価される。
環境とは、変数と値の一対一の対応の集合と、
零又は、一つの環境への参照の対のことをいう。
ある環境が持つ、環境への参照のことを親の環境という。
また、その逆の関係を子の環境という。
定義により、ある環境は零又は、一つの親の環境を持つが、
一つの環境は零以上の子の環境を持つ。
親の環境が存在しないような環境は一つだけ存在し、トップレベルという。
Parenを起動した直後の環境はトップレベルである。
## 変数の束縛
ある環境の変数と値の対の集合に、
新しく要素を追加する行為をその環境に変数を束縛するという。
## 環境の作成
スペシャルオペレーターletは新しく環境を作成し、その環境で式を評価する。
    (let binding_form body_form ...) => result
    binding_form ::= ((var [val]) ...)
    var -- 新しく作成する環境に束縛する変数
    val -- 変数を束縛する値(省略された場合はnilが指定されたものと見做す)
    body_form -- 新しく作る環境内で評価する式
    result -- 最後のbody_formの評価結果
作成された新しい環境は、現在の環境を親の環境とする。
letの外側に出ると、再び現在の環境下で評価される。
## 変数の評価
変数は評価されると次の手順で値が探索される。
    もし、現在の環境に変数が束縛されているならその値を返す。
    束縛されていない場合は、親の環境に対して再帰的に探索を行う。
    ただし、トップレベルに束縛されていない場合は変数の未束縛エラーとなる。
変数の簡単な評価例を下に示す。
最初にトップレベルにa、b、cをそれぞれ1、2、3で束縛している。
    ) (<- a l b 2 c 3)
    3
    ) (* a b c)
    6
ここで、letでトップレベルの下に新しく環境を構築し、
その環境で積を評価してみる。
    ) (let ((a -1))
          (* a b c))
    -6
ここでのaは新しい環境に束縛された値、bとcはトップレベルの値である。
    ) (* a b c)
    6
トップレベルで束縛されている値は更新されていないため最初の評価結果と同じになる。
このように、ある変数の評価結果は評価される環境によって異なる。
## 代入規則
Parenの起動直後の環境はトップレベルであるから、
今までの代入の例はすべてトップレベルでの代入であった。
トップレベル以外の環境も考慮すると、代入は次の規則で処理される。
    代入する変数が束縛されている、現在の環境を含む最も近い親の環境を探し、
    その環境で束縛されている値を更新する。
    ただし、変数が束縛されていない場合はトップレベルに新しく束縛する。
代入の簡単な例を下に示す。
先ほどの例と同じようにa、b、cをトップレベルで束縛する。
    ) (<- a 1 b 2 c 3)
    3
    ) (* a b c)
    6
ここで、letでトップレベルの下に新しく環境を作成しその中で代入を行う。
    ) (let ((a 1) (b 2))
          (* (<- a -1) (<- b -2) (<- c -3)))
    -6
再度トップレベルで積をとると、
評価結果が最初の値と変わっていることが確認できる。
    ) (* a b c)
    -6
これは、新しく作成した環境でcに値を代入したとき、
トップレベルで束縛されているcの値が更新されたからである。
## スコープ
ある変数を参照可能な範囲のことを変数のスコープ乃至、可視範囲という。
Parenの変数のスコープは、変数の評価規則に従い次のようになる。
    ある変数のスコープはその変数が束縛されている環境から辿れるすべての子の環境である。
    ただし、辿りうる子の環境の中に同名の変数が束縛されている場合は、
    変数のスコープはその環境よりも親の環境までとなる。
親の環境で束縛されている変数を、子の環境で束縛することを、
変数の再束縛、乃至、変数のシャドーイングという。
## エクステント
あるオブジェクトがメモリ上に確保されてから破棄されるまでの期間のことを、
エクステント乃至、生存期間という。
Parenのオブジェクトには時間的な制約がなく、
他のあらゆるオブジェクトから参照の可能性がある限り破棄されることはない。
このようなエクステントを無限エクステントという。
Parenは無限エクステントであるから、
ある変数の参照先が既に破棄されていたというようなことはおこらない。
ただし、一旦メモリに確保されたオブジェクトが、
永遠に破棄されないというわけではない。
プログラムから参照する術がなくなったオブジェクトは、
ガーベージコレクションにより定期的に破棄される。
## グローバル変数
Parenではトップレベルで束縛された変数のことをグローバル変数という。
グローバル変数は再束縛されていないすべての環境から参照できる。
慣習として、ほかの変数と区別がつきやすいようにグローバル変数名は`$`から始める。
    $global_var
組み込みの代表的なグローバル変数を下に示す。
    変数名    値
    ---------------------------------------------
    $modules  importされているモジュールのリスト
    ...

# 条件分岐
Parenには条件分岐のオペレータifが存在する。
上記のオペレーターが気にいらなかったり、
新たにオペレーターが必要になった場合は後述するマクロでいつでも拡張できる。
## 真偽値
Parenは次にあげる値を除き、すべて真と見做される。
- false
- nil
- 0
- ""
## if
ifは汎用的な条件分岐処理を行うためのスペシャルオペレーターである。
    (if [clause ...])
    clause ::= (test [body_form ...])
    test -- 処理を行うか否かを表す真偽値
    body_form -- testが真のときに評価される式
ifは評価する条件と評価する式のリストのリストとなっている。
ifは最初の引数から、そのリストの先頭の要素を評価する。
評価結果が真の場合はそのリストの残りの要素を順に評価し、
そうでなければ次の引数に対して同じことを行う。
    ) (function to_roman (x)
        (if ((= x 1) :one)
            ((= x 2) :tow)
            ((= x 3) :three)
            (true :more)))
    ) (roman 1)
    :one
    ) (roman 4)
    :more
if全体は条件式が真を返す引数があれば、そのリストの最後の要素の評価結果を返す。
そうでなければfalseを返す。
最後の引数がデフォルトを表す節の場合は慣習としてtrueを用いる。
## 三項演算子
Parenには三項演算子相当の`?`マクロが用意されている。
    (? test then_form else_form)
    test -- 真偽値
    then_form -- testが真の場合に評価される式
    else_form -- testが偽の場合に評価される式
三項演算子は条件分岐が二通りで、分岐後に評価する式が簡潔な場合に有効である。
## 比較関数
Parenには、あるオブジェクトが等しいか判定する関数が二種類存在する。
    関数 処理
    --------------
    =    同等判定
    eq?  同一判定
ここで、あるオブジェクトA、Bの存在を仮定する。
AとBが同等であるとは、AとBの型が等しく概念的にも等しいと見做せることをいう。
AとBが同一であるとは、AとBがメモリ上の同一アドレスに存在することをいう。
これらの定義から次のことが言える。
- 同等である条件はオブジェクトの型により異なる。
- 同一であることは同等であることの必要条件であるが十分条件ではない。
`=`は二つ以上のオブジェクトがすべて同等であれば真を返す。
    ) (= 3 3 3)
    true
    ) (= 3 2)
    false
    ) (<- a 3 b 3)
    3
    ) (= a b)
    true
次のように型が異なる場合は、概念的に等しくても偽を返す。
    ) (= "3" 3)
    false
`eq?`は、比較する二つ以上のオブジェクトがすべて同一である場合に真を返す。
    ) (eq? 3 3)
    false
    ) (<- a 3 b 3)
    3
    ) (eq? a b)
    false
    ) (<- b `a)
    a
    ) (eq? a b)
    true
`eq?`はメモリ番地の比較をするだけなので高速である。
また、Parenでは同一変数はすべて同一なオブジェクトであることが保証されている。
    ) (eq? :a :a)
    true
    ) (<- a 3)
    3
    ) (eq? a a)
    true
## 述語の結合
ある式の評価結果が真か偽を表すことを強調する場合その式を述語という。
Parenには述語を結合するオペレーターがある。
    名称 処理
    ------------------------------------------------------------------------
    and  すべての引数の評価結果が真の場合に最後の評価結果を返す。
         ただし、評価途中に偽を返す式があったら以降の評価を中断しfalseを返す。
    or   どれか一つの引数の評価結果が真の場合にその値を返す。
         ただし、評価途中に真を返す式があったら以降の引数は評価しない。
         また、すべての引数の評価結果が偽の場合はfalseを返す。
    not  述語が真の場合は偽を、偽の場合は真を返す。
Parenには`=`の否定を返す関数`!=`が存在するが、
notの定義により次の二つの式は等価となる。
    (!= expr1 expr2) <=> (not (= expr1 expr2))

# 反復
Parenには反復処理を行うためのオペレーターがいくつか存在する。
- for
- while
- each
また、このほかに必要に応じてユーザが反復処理を行うマクロを定義することができる。
## for
forマクロは汎用的な反復処理を実現する。
    (for (init_form end_test_form step_form [result_form])
        [body_form ...])
    init_form -- 初期化式
    end_test_form -- 反復判定式
    step_form -- 反復する度に実行される式
    result_form -- 返り値として評価される式
    body_form -- 反復処理
forは次の手順で実行される。
1. init_formを評価する。
2. end_test_formを評価した結果が真の場合3へ、偽なら反復終了
3. body_formを逐次評価
4. step_formを評価して1へ戻る
反復終了後、result_formが指定してある場合は評価してforの返り値とし、
そうでなければnilを返す。
単純なforの使用例として1から10までの和を返すプログラムを示す。
    ) (for ((<- i 1 sum 0) (<= i 10) (++ i) sum)
          (+= sum i))
    55
## while
whileは次の書式をとる。
    (while (end_test_form [result_form])
        [body_form ...])
    end_test_form -- 反復判定式
    result_form -- 返り値として評価される式
    body_form -- 反復処理
次の手順で反復処理が行われる。
1. end_test_formを評価した結果が真なら2へ偽なら反復終了
2. body_formを逐次評価し、1へ戻る
反復終了後、result_formが指定してある場合は評価してwhileの返り値とし、
そうでなければnilを返す。
## each
eachは引数が反復可能なオブジェクトの場合に使用できる。
反復できるオブジェクトとには次の種類が存在する。
- 配列
- リスト
eachは第一引数のリストの第一要素に反復時に使用する変数名を、
第二要素に反復する対象を指定する。
eachの第二引数移行が、反復処理の対象となる。
    (each (iterator object [result_form])
        [body_form ...])
    iterator -- each内の反復変数
    object -- 反復対象のコレクション
    result_form -- 返り値として評価される式
    body_form -- 反復処理
簡単な評価例を示す。
    ) (each (i (range 1 5))
          (write i))
    12345
    ) (each (i "12345")
          (write i))
    12345
反復終了後、result_formが指定してある場合は評価してeachの返り値とし、
そうでなければnilを返す。

# 配列
配列は連続したメモリ上にオブジェクトを確保するデータ構造である。
配列を使用するデータ構造は一般的にはリストで表現可能であるが、
処理速度等の理由により配列を採用する場合がある。
なお、Parenの配列はParenのオブジェクトなら何でも代入することができる。
## 配列の生成
配列は組み込みのarray関数で作成する。
    (array size [initial_function])
    size -- 確保する要素数
    initial_function -- 初期化関数
配列は一度作成するとその大きさは変更できない。
    ) (array 3)
    #[nil nil nil]
初期化関数は引数を一つとる関数で次のように、
各要素番号を使用した初期化を行う。
    ) (array 3 (fn (i) (* i 2)))
    #[0 2 4]
## リードマクロによる生成
初期値があらかじめ決まっているような配列はリードマクロを使用するとよい。
    ) #[1 2 3]
    #[1 2 3]
## 要素の参照
配列の要素を参照するには組み込み関数の`[]`を使用する。
次に書式を示す。
    ([] array index)
添え字は零から数える。
    ) (<- arr #[1 2 3])
    #[1 2 3]
    ) ([] arr 1)
    2
配列が確保している範囲外にアクセスするとエラーとなる。
## 配列に代入
配列に代入するには参照と同じ関数`[]`を使用する。
次に書式を示す。
    ([] array index value)
    index -- 零から数える場所
    value -- 代入する値
簡単な使用例を示す。
    ) (<- arr #[1 2 3])
    #[1 2 3]
    ) ([] arr 1 10]
    #[1 10 3]
また、式の返り値は配列となる。
## 多次元配列
配列の要素には任意のParenのオブジェクトを保持できるため、
配列の各要素が配列であるような配列が定義できる。
このような配列を2次元配列という。
この概念を拡張して、一般に多次元配列という。
Parenでは多次元配列をコアライブラリに含めることはせず、
モジュール:Matrixにて提供する。

# マップ
マップは配列の添え字に任意のParenのオブジェクトを設定できる配列である。
実装はハッシュテーブルにより実装されているため、
理論上はO(1)でデータの探索が可能。
詳細な仕様については別ドキュメントを参照されたい。
## マップの作成
マップを作成するには組み込みのmap関数を使用する。
    ) (map)
    #{}
要素を指定して初期化する場合はリードマクロを使用できる。
下の例のようにキーと値をペアで指定する。
    ) #{key1 val1
        key2 val2
        key3 val3}
    #{key1 val1 key2 val2 key3 val3}
## 要素の参照
マップmapのキーkeyに対応する値を参照するには`{}`関数を使用する。
    ({} map key)
簡単な評価例を示す。
    ) (<- map #{:key1 :val1 :key2 :val2})
    #{:key1 :val1 :key2 :val2}
    ) ({} map :key2)
    :val2
ただし、keyに対応する値がない場合はnilを返す。
そのため、keyが設定されているのか、否かは関数`has_key?`を使用する必要がある。
## 要素の設定
マップmapのキーに値を設定するには`{}`関数を使用する。
    ({} map key value)
    key -- キー
    value -- 値
簡単な評価例を示す。
    ) (<- map #{:key1 :val1 :key2 :val2})
    #{:key1 :val1 :key2 :val2}
    ) ({} map 3 :three)
    #{:key1 :val1 :key2 :val2 3 :three}
`{}`の返返り値はマップとなる。
また、既にキーに対する値がマップに存在する場合は上書きする。
    ) ({} map :key2 :two)
    #{:key1 :val1 :key2 :two 3 :three}

# スペシャルオペレーター
スペシャルオペレーターはParenのS式の評価ルールに従わない、
オペレーターごとに異なる特別なルールで評価される。
スペシャルオペレーターには次の種類が存在する。
- <-
- begin
- fn
- if
- label/goto
- macro
- quote
- try/catch/finally/throw
これらのうち、いくつかはすでに説明してきた。
ここでは、まだ説明していないスペシャルオペレーターについて述べる。
## <-(変数束縛)
代入オペレーターは変数、環境の章で説明した。
## begin(逐次評価)
    (begin [body_form ...])
    body_form -- 逐次評価する式
beginは左から順に式を評価していく。
引数がある場合は最後の式の評価結果を返し、ない場合はnilを返す。
主に副作用を期待するマクロの展開結果に含まれる。
組み込みでは、forやwhileなど複数の式を実行するマクロの展開結果に含まれる。
このように利用者が直接見ることはないが、
暗に利用されているbeginを暗黙のbeginという。
## fn(無名関数)
    (fn ([var ...  [:opt var_value ...] [:rest var] [:key var_value ...]])
        body_form ...)
    var_value ::= {var | (var value)}
    var -- 仮引数名
    value -- 仮引数の初期値
fnは関数を作成するスペシャルオペレーターである。
fnに与える引数は、名前を指定しないという点を除いてfunctionと全く同じである。
fnが作る関数のことをその名前がないことにちなみ、無名関数という。
無名関数は汎関数を使うときにしばしば用いられる。
## if(条件分岐)
ifは条件分岐の章で述べた。
## label/goto(ジャンプ機構)
    (label statement ...)
    statement ::= {label_name | goto_form | other_form}
    goto_form ::= (goto label_name)
    label_name -- ジャンプ先を表すキーワード
    other_form -- 上記以外の式
labelは制御をジャンプさせるためのコンテキストを作る。
goto文を使用するとlabel内で定義したキーワードへ制御がジャンプする。
label/gotoを直に使用することはほとんどなく、
forやwhile等のマクロを定義するために使用する。
## macro(マクロ)
マクロの章で述べる。
## quote(評価見送り)
quoteは引数を評価しないようにするスペシャルオペレーターである。
    (quote expr)
    expr -- 評価しない式
次のように引数の値がそのまま返される。
    ) (<- a 3)
    3
    ) a
    3
    ) (quote a)
    a
このように、評価を見送ることをクォートするという。
Parenでは、クォートすることが頻繁にあるため、
そのための構文糖が用意されてある。
構文糖を使用するには次の例のように、
クォートしたい対象に`'`(クォート)を前置すればよい。
    ) 'a
    a
定数のリストを用いるときに利用することが多い。
    ) '(1 2 3)
    (1 2 3)
そのほか、評価するタイミングをずらすためにマクロ定義に頻繁に利用される。
## try/catch/finally/throw(例外処理機構)
    (try [body_form ...]
        [(catch (type var) catch_body_form ...) ...]
        [(finaly catch_body_form ...)])
    (throw exception)
try/catch/finally/throwは例外処理機構を扱うためのスペシャルオペレーター群である。

# マクロ
マクロはParenが読み込まれ、リードマクロが展開された後に評価される。
マクロはリードマクロ、マクロ、スペシャルオペレーター、 関数等、
すべてのParenの機能を使用してユーザが定義することができる。
マクロは使用される前に定義がされている必要がある。
マクロ展開は、展開結果にマクロが含まれなくなるまで再帰的に行われる。
一般的に、マクロとは次のようなプログラムのことを指す。
    あるプログラムが実行される前処理に実行されるプログラム
プログラムを書くプログラムといっても大きく外れていない。
Parenのマクロがほかの非Lisp系言語と大きく異なるのは、
マクロがそうでないプログラムと調和していることである。
例えば、C言語のそれはC言語とは全く関係ない別の言語に等しく、
ただ単に、文字列の置換を行っているに過ぎない。
一方でParenのそれはParenの関数やマクロを用いて定義できる。
## マクロ定義
マクロはスペシャルオペレーターmacroを使って定義する。
    (macro macro_name (args)
         body_form ...)
    macro_name -- 定義するマクロ名
    args -- マクロの引数
    body_form -- 展開結果
ここで、マクロの引数は無名関数を作るスペシャルフォームfnと同じ引数を受け取る。
macroで定義したマクロは関数と同じように呼び出す。
## マクロの評価
マクロが評価されることをマクロ展開という。
マクロ展開の結果のS式がプログラム実行時に再度評価される。
## 組み込みのマクロ
ここでは組み込みのマクロの一部を示す。
### 代入マクロ
Parenには算術にまつわる次の代入マクロが定義されている。
    手続き 処理
    --------------------------------------------
    ++     変数に1足した結果を代入
    --     変数に1引いた結果を代入
    +=     変数に+を評価した結果を代入
    -=     変数に-を評価した結果を代入
    /=     変数に/を評価した結果を代入
    *=     変数に*を評価した結果を代入
これらと等価な式を示す。
    (++ var) <=> (<- var (+ var 1))
    (-- var) <=> (<- var (- var 1))
    (+= var val) <=> (<- var (+ var val))
    (-= var val) <=> (<- var (- var val))
    (*= var val) <=> (<- var (* var val))
    (/= var val) <=> (<- var (/ var val))
    var -- 変数
    val -- 増減値
一般にLisp系言語で代入行為は禁忌と見做されがちだが、
その記述の簡潔さのためであればParenでは積極的に使用する。
### 関数定義マクロ
functionは名前付きの関数を定義するためのマクロである。

# リードマクロ
リードマクロはParenのリーダーに新しく構文規則を追加する機能である。
そのため、Parenには構文があってないようなものであるということを垣間見る。
## リードマクロの定義
リードマクロはreadmacroマクロにより定義できる。
    (readmacro matcher expander)
    matcher -- リードマクロが実行される文字の列
    expander -- 入力ストリームを受け取るリードマクロの展開時に実行される関数
書式だけでは実際にどのようにリードマクロを定義するのかわかりにくいため、
有用なリードマクロの定義をいくつか示す。
## 複数行コメント
コメントの章でParenには複数行コメントがないが、
リードマクロによって簡単に定義できると述べた。
ここでは、Common Lispの複数行コメントを定義する。
Common Lispでは、`#|`から始まり、`|#`までの文字の列がコメントと見做される。
そのようなリードマクロは次のように定義できる。
    (readmacro #|
      (fn (stream)
        (<-
        body_form ...))

# goto文
TODO

# 例外処理機構
TODO

# クラス
Parenは関数型言語として設計されているが、
マクロの力により手続き型言語として使用することも十分可能であることを見てきた。
ここではマクロを用いてParenの上に構築されたオブジェクト指向言語について述べる。
以後、このドメイン特化言語をPOS(Paren Object System)と呼ぶ。
POSはCommon LispのCLOSから強い影響を受けているが、
強力すぎる機能をそぎ落とし、使用頻度が高い必要最低限の機能に抑えてある。
また、実装は簡潔に心がけ必要に応じてハックできる余地も残してある。
この章は、読者にオブジェクト指向の知識があることを前提として述べる。
## クラスの作成
クラスはマクロclassにより作成する。
    (class class_name (super_class ...)
        field ...)
    class_name -- 作成するクラスの名前
    super_class -- 作成するクラスのスーパークラス
    field -- 作成するクラスのインスタンス変数
書式から分かるように、POSでは次の特徴がある。
- 型の多重継承
- メソッドがクラスに属さない
classマクロは概ね、次のようなS式に展開される。
展開結果から分かるように、内部的にはただのマップである。
    (<- Class #{:type :class_name
                :super (list super_class ...)
                :fields #{:field false ...}})
例として二次元ベクトル空間の元を表すクラスPointを示す。
    (class Point () x y)
例のように、Parenではクラス名は慣習としてパスカルケースを用いる。
## インスタンスの生成
インスタンスの生成にはnewマクロを使用する。
    (new class [var val] ...)
    class -- 生成するインスタンスのクラス
    var -- インスタンス変数名称
    val -- varの初期値
前述したPointクラスのオブジェクトは次のように生成する。
    (<- p (new Point))
必要に応じてインスタンス変数を初期化することもできる。
初期化されていない変数の値はfalseとなる。
    (<- q (new Point :x 3 :y 4))
## インスタンスの型
インスタンスの型を調べるにはtypeマクロを使用する。
    (type class)
    class -- クラス名
クラスの型はクラス定義の際に、クラス名に対応するキーワードが自動的に設定される。
    ) (type p)
    :Point
また、型を判定する述語としてtype?マクロがある。
これはただ単に、同一判定をするS式に展開するマクロである。
    (type? p :Point) <=> (eq? (type p) :Point)
## インスタンス変数の参照と代入
POSではクラス定義と同時にインスタンス変数へのアクセサが自動生成される。
自動生成されるアクセサはインスタンス変数名の前に`.`を付けたものとなる。
そのため、メソッド以外の識別子を`.`から始めることは推奨しない。
    ) (<- p (new Point :x 0 :y 0))
    p
    ) (.x p)
    :3
    ) (.x p 3)
    p
    ) (.x p)
    3
## メソッドの定義
メソッドの定義はmethodマクロを使用する。
    (method (required_params [:opt option_param ...]
                             [:key key_param ...]
                             [:rest rest_param])
        body ...)
    required_params ::= (class required_param) ...
    option_param ::= (option_param [initial_value]) ...
    key_param ::= (key_param [initial_value]) ...
    class -- メソッドを決定するクラス
    required_param -- 必須パラメーター
    option_param -- オプショナルパラメーター
    rest_param -- レストパラメーター
    body -- メソッド本体
methodは型と変数名のリストを必須パラメーターに指定するようなfunctionだと思えばよい。
二次元ベクトル空間上の元の和を返すメソッドを例として示す。
    (method .add ((Point p1) (Point p2))
        (new Point :x (+ (.x p1) (.x p2))
                   :y (+ (.y p1) (.y p2))))
なお、このメソッドを可変長引数に拡張することは、
methodで指定できるパラメーターが柔軟なため容易である。
作成したメソッドはクラスとは別のグローバル変数$methodに登録される。
このマクロはグローバル変数$methodにメソッド登録するS式に展開される。
先ほどの.addは概ね次のようなS式に展開される。

if .addが環境に存在するか .add関数の作成
else if .addがメソッドか .add関数にメソッド登録
else 衝突エラー

.add関数の実装イメージ
(function .add (&rest params)

    (add_method ({} $method .add)
                '(Point Point)
                '(new Point :x (+ (.x p1) (.x p2))
                            :y (+ (.y p1) (.y p2))))

$methodはキーにメソッド名称、値にその型ごとの実装のハッシュマップを持つ、
ハッシュマップである。
生成したオブジェクトの初期化は、慣習としてinitメソッドを定義してそこで行う。
    (init (new Point) :x 4 :y 5)
このようなinitは次のように定義されているであろう。
    (method init ((Point p) :key (x 0) (y 0))
        (.x p x)
        (.y p y))
例に示すように、実はインスタンス定義したインスタンス変数は、
自動でアクセサが生成される。
    (class Point () x y)
    (method .x ((Point p) :opt x)
      (if (false? x) ({} ({} :fields p) :x))
          (:else ({} ({} :fields p) :x x))))
    (method .y ((Point p) :opt y)
      (if ((nil? y) ({} ({} :fields p) :y))
          (:else ({} ({} :fields p) :y y))))
Parenでは宣言したインスタンス変数はすべて外部に公開する仕様である。
このことは、作成するクラスにドキュメントを書くことと、
使用するクラスのドキュメントを読むことを後押しする。
また、クラスをハックする手段を意図的に残している。

# Common Lispとの違い
Lisp経験者のために代表的なCommon Lispとの違いを述べる。
ただし、この中には言語で吸収できる差も含まれる。
## 代入演算子
Common Lispで代入を行う場合、次のロジックで処理が行われる。
    1. 現在の環境に変数が束縛されている場合はその値を更新する。
    2. そうでなければ親の環境を辿っていき、見つかった場合はその環境の値を更新する。
    3. 親の環境に変数が束縛されていなかった場合はトップレベルに変数を束縛する。
Parenでは二種類の代入演算子が用意されていて、Common Lispの代入演算子に加えて、必ず現在の環境に束縛する演算子が存在する。
    演算子 処理
    --------------------------------------
    ->     必ず現在の環境に変数を束縛
    -->    Common Lispのsetq相当の処理
これにより、letで明示的に変数を束縛してから代入を行う必要がなくなり代入の使用が容易になっている。
また、親の環境を辿る代入演算子も残すことによりクロージャの作成もできる。
変数以外に代入可能な式は次のように、アクセサの第二引数に代入値を指定する。
    左辺一覧
    対象   参照            代入
    -------------------------------------------
    変数   var             (<- var val)
    コンス (car var)       (car var val)
           (cdr var)       (cdr var val)
    配列   ([] var index)  ([] var index val)
    マップ ({} var index)  ({} var index val)
    構造体 (get var index) (set var index val)

## シンボルの変換
両者ともシンボルの大文字小文字を区別するが、Common Lispはデフォルトで大文字に変換するのに対して、Parenでは一切変換を行わない。

## 述語の名称
Parenでは述語の末尾を`?`で終わらせることを推奨している。

## 命名規約
ParenはCommon Lispとは異なる命名規約をとっている。
    対象            命名方法
    --------------------------------------------------------
    ファイル                  スネークケース
    定数                      すべて大文字のスネークケース
    ローカル変数              キャメルケース
    グローバル変数            `$` + キャメルケース
    クラス                    パスカルケース
    キーワード                `:`から始まるキャメルケース
                              (ただし、型を表す場合はパスカルケースとする。)
    述語                      末尾に`?`を付ける
    破壊的処理                末尾に`!`を付ける
    束縛系のマクロ            withから始める
    アナフォリック系のマクロ  最後に`*`を付ける
    構造体                    パスカルケース
