Parenチュートリアル

# 概要
このチュートリアルはParenの機能を早巡りすることを目的とする。
ParenはS式によって記述される、最古のプログラミング言語Lispの方言である。
ただし、実装されている関数やマクロや、
それらの命名などは相当著者好みのものとなっている。
Parenのコンセプトを示す。
- programmable programming language
- ability to rapidly develop
- runnable on all major platforms 
- easy and simple to learn
- never programming without enjoying

# 目次
- 書式
- Hello Paren
- コメント
- 変数
- 環境
- 数値
- 文字列
- リスト
- 関数
- 条件分岐
- 反復
- 配列
- マップ
- 構造体
- スペシャルオペレーター
- マクロ
- リードマクロ
- 例外処理
- 付録

# 書式
チュートリアルを記載するにあたり、書式を次に定義するBNFで記載する。
    記号 定義
    ----------------------------------------
    [ ]  括弧内は省略可能
    { }  括弧内から一つ選択
    |    括弧内の代替候補の区切り文字
    ...  直前の構文を零回以上繰り返す

# Hello Paren
Parenで標準出力に出力するには組み込みのprint関数を使用する。
関数を呼び出すには関数名とその引数を括弧で括って記述する。
    (print "Hello Paren")
    Hello Paren
    => "Hello Paren"
これがParenの基本的な構文となる。
`=>`はParenの評価結果を表す。
二つの行はそれぞれ
1. printが標準出力へ出力した結果
2. print関数の評価結果
を意味する。
このように、Parenの式はすべて値を返す。
Parenの世界へようこそ。

# コメント
Parenには一行コメントどドキュメンテーションコメントの二種類のコメントがあり、
用途によりそれぞれ使い分ける。
## 一行コメント
Parenでは`;`から行末までがコメントとして扱われ、無視される。
これを一行コメントと呼ぶ。
    ; コメント
    ;; これもコメント
## ドキュメンテーションコメント
また、`"""`と`"""`で囲んだ領域もコメントとして扱われ、無視される。
これをドキュメンテーションコメントと呼ぶ。
    """
    ドキュメンテーションコメント
    複数行に跨がれます。
    """
ドキュメンテーションコメントには改行を含めることもできる。
自作するモジュールや、モジュール内のグローバル変数、関数、マクロ等には、
ドキュメンテーションコメントを記載することが望ましい。
Parenにはソースコード中のドキュメンテーションコメントを、
html形式のドキュメントに変換する機能があり、自動で文書化される。
具体的な使用方法や、仕様については別紙を参照されたい。

# 変数
Parenには変数に値を代入、参照する仕組みがある。
変数のスコープやエクステントについては、
後述する環境モデルの章で述べる。
そのため、この章では変数の簡単な取り扱い方を理解することを目標とし、
読者の理解のために厳密には誤った表現も用いる。
## 変数名
Parenの変数名は数字以外の英文字と一部の記号から始まり、
その後、英数字と一部の記号が続く。
次のいずれもParenの変数名として有効である。
    var
    x1
Parenでは様々な記号も変数名に使用することができる。
次にあげる変数名は(推奨されるような名称かはさておき)すべて有効である。
変数名称で使用できる文字の厳密な定義は言語仕様書の字句解析の章を参考されたい。
    !$*+-0-9abc?
    m<__.__>m
一般に、複数の単語で構成されている変数名は、
単語の区切れをアンダースコアで区切る。
    neighbor_count
    prim_table
このような命名方法をスネークケースという。
## 代入
変数に値を代入するにはスペシャルオペレーター`<-`を使用する。
以降はこれを代入オペレーターとよぶ。
Parenには特殊な式の評価方法が組み込みで用意されており、
代入オペレーターはそのうちの一つとなる。
それらをスペシャルオペレーターというが、これについては後の章を参照されたい。
代入オペレーターには代入したい変数varと値valを組にして指定する。
    (<- variable_value ...)
    variable_value ::= var value
    var -- 変数名
    var -- 変数に代入する値
代入オペレーターは最後に代入した値を返す。
    (<- a 0
        b 1)
    => 1
この性質を利用すると、
標準入力から標準出力へ複写するプログラムは次のように書ける。
    (while (!= (<- c (getc)) :EOF)
        (putc c))
代入オペレーターで複数の代入を行う場合は、
すべて左から順に評価されることが保証されている。
     (<- x 3
         y (* x 2))
     => 6
     (* x y)
     => 18
Parenが組み込みで使用している変数に値を代入することもできるが、
ほとんどの場合、ユーザの予期せぬ動作となってしまうだろう。
## 参照
すでに見てきたように変数に代入されている値を参照するには変数を評価すればよい。
    (<- a 3 b 4)
    => 4
    a
    => 3
    b
    => 4
ただし、変数に値が代入されていない場合はエラーとなってしまう。
    unknown_variable
    => Error
変数を評価させたくない場合があるかもしれない。
そのような場合はスペシャルオペレーター`quote`が使える。
quoteは引数を評価せずに、そのまま返す。
    (<- a 3)
    => 3
    a
    => 3
    (quote a)
    => a
このように、評価を見送ることをクォートするという。
Parenでは、クォートすることが頻繁にあるため、
そのための構文糖が用意されてある。
構文糖を使用するには次の例のように、
クォートしたい対象に`'`(クォート)を前置すればよい。
    'a ; <=> (quote a)
    => a
## 恒等変数
代入できず、評価されると常に自身が返ってくる特殊な変数がある。
Parenではこのような変数を恒等変数という。
最初の一文字が`:`から始まっている変数は恒等変数と見做される。
    :key
    => :key
    (<- :key 3)
    => Eroor
恒等変数の性質は便利であるため、Parenではいくつか有用な用途がある。
## グローバル変数
プログラムのどこからでも参照できる変数をグローバル変数という。
Parenを起動した直後に変数に値を代入するとグローバル変数と見做される。
グルーバル変数名称は`$`から始めることが推奨される。
    $global_var
## 定数
Parenには言語機能として定数は存在しない。
そのため、定数として扱いたい変数を定義する場合、
他の変数と見分けがつくように大文字の変数名を使用する。
    (<- PI 3.141592
        MAX_BUF_SIZE 256)
    => 256
定数の値を書き換えないように、プログラマは注意する必要がある。
    (<- PI 3)
    => 3
## 真偽値
Parenの真偽値は先に述べた恒等変数を用いて表現される。
    恒等変数 真偽値
    ---------------
    :t       真
    :nil     偽
ただし、:tは真を表す代表の値で、
実際には、:nil以外の値はすべて真と見做される。

# 環境
Parenが変数とそれに対応づけられた値との関係を、
環境と呼ばれるモデルを採用して管理している。
Parenの変数について理解するために、環境の理解は必須となる。
## 環境モデル
環境とは、零または一つの自身以外の環境への参照および、
変数とその値の一対一の対応の集合の組のことをいう。
ある環境が持つ、環境への参照の実体のことを親の環境という。
逆に、親の環境に対して、自身のことを子の環境という。
定義により、ある環境は一つの親を持つが、一つの環境は複数の子の環境を持ちうる。
環境への参照がない(親の環境が存在しない)ような環境はParenには一つしかない。
その環境のことを特に、トップレベルという。
ある式が評価される場合、必ずどこかの環境の下で評価される。
Parenを起動した直後の環境はトップレベルとなる。
## 変数の束縛
ある環境の変数とそれに対応付けられた値との集合に、
変数とその値の組を追加する行為をその環境にvarをvalで束縛するという。
前述した代入を、環境モデルを考慮して次のように再定義するとこうなる。
ある環境下で変数varに値valを代入するとは、
現在の環境に変数varを値valで束縛することである。
この定義により今までの代入の例は、
すべてトップレベルに変数を束縛してきたことにほかならない。
## 環境の作成
現在の環境への参照をもつ新しい環境を作るには、
スペシャルオペレーターletを使用する。
    (let binding_form body_form ...)
    binding_form ::= ((var [val]) ...)
letは値valに束縛する変数varの組と、
新しく作成する環境下で評価する式で記述される。
valは省略可能で、その場合varは:nilが指定されたものと見做される。
また、letは最後に評価された結果を返す。
## 変数の評価
ある環境下で変数varがどのように評価されるか述べる。
最初にトップレベルにa、b、cをそれぞれ0、1、2で束縛している。
次にそれらの積を評価し、結果が0なのが確認できる。
    (<- a 0 b 1 c 2)
    => 2
    (* a b c)
    => 0
この動作はすでに前述した例の通りである。
ここで、letでトップレベルの下に新しく環境を構築し、
その環境にa、b、cをそれぞれ1、2、3で束縛している。
この新しい環境内でそれらの積を評価すると、
結果がトップレベルでの評価と異なっていることが確認できる。
    (let ((a 1) (b 2) (c 3))
        (* a b c))
    => 6
また、最後にletの外(つまりトップレベル)で再度積を評価すると、
結果は再び0になる。
    (* a b c)
    => 0
この結果はParenが次の手順で変数の値を取得するためである。
もし、現在の環境に変数が束縛されているならその値を返す。
そうでなく、トップレベルでないならば親の環境に対して再帰的に探索を行う。
それでもなく、トップレベルならばエラーとなる。
定義により、環境のことを考えることなしに、
変数が束縛されている値を考えることに意味はない。
たとえば、次の例では評価される環境によって
現在の環境から直近の環境に束縛されている値が返る。
    (let ((a 0))
      (print a)
      (let ((a 1))
        (print a)
        (let ((a 2))
          (print a)
          (let ((a 3))
            (print a)))))
    0
    1
    2
    3
    => 3
## 変数のスコープ
ある変数が有効な範囲のことを変数のスコープという。
環境モデルを用いると次のように定義できる。
ある変数のスコープはその変数が束縛されている環境から辿れる子の環境すべてである。
ただし、辿れる子の環境の中にその変数が束縛されている場合は、
変数のスコープはその環境よりも親の環境までとなる。
このように、親の環境で束縛されている変数を、
そこから辿れる子の環境で再束縛することを変数のシャドーイングという。
## 変数のエクステント
ある変数の生存期間のことを変数のエクステントという。
Parenの変数には時間的な制約がなく、
参照の可能性が存在し続ける限り束縛が存在し続ける。
このようなエクステントを無限エクステントという。
厳密には、変数が永遠に破棄されないわけではなく、
どのオブジェクトからも参照されていないといなされた場合、
その変数はガーベージコレクションにより破棄される。
実際は有限の生存期間であっても、
それがプログラム内で使用することがないと保証されているために、
無限エクステントと見做せる。

# 数値
今までの章ではさりげなく算術関数を使用してきたが、
この章でそれらについて詳しく述べる。
## 評価
数値は評価されると、自身を返す。
    3
    => 3
    3.333
    => 3.333
Parenではすべての実数が数値型として扱われる。
## 算術関数
代表的な算術関数を次に示す。
    関数  処理
    -------------------
    +     加算
    -     減算
    *     乗算
    /     除算
    **    冪乗
    //    切り捨て除算
    mod   余り
これらの関数についてはその簡潔さから実行例のみ示す。
    (+ 3 4 5)
    => 12
    (- 10 4 5)
    => 1 ; <=> (- (- 10 4) 5)
    (* 3 4 5)
    => 60
    (/ 3 4 5)
    => 0.15
    (/ 3)
    => 0.33333
    (** 2 3)
    => 8
    (// 5 4)
    => 1
    (mod 6 4)
    => 2
加算や減算など非Lisp系言語では二項演算子として定義してあるものも、
Parenでは可変長引数の関数に過ぎない。
## 代入手続き
Parenには算術にまつわる次の代入マクロが定義されている。
    手続き 処理
    --------------------------------------------
    ++     変数に1足した結果を代入
    --     変数に1引いた結果を代入
    +=     変数に+を実行した結果を代入
    -=     変数に-を実行した結果を代入
    /=     変数に/を実行した結果を代入
    *=     変数に*を実行した結果を代入
これらと等価な式を示す。
ただし、varは変数名でvalはvarに変更を与える値であると仮定する。
    (+= var val) <=> (<- var (+ var val))
    (-= var val) <=> (<- var (- var val))
    (*= var val) <=> (<- var (* var val))
    (/= var val) <=> (<- var (/ var val))

# 文字列
Parenでは、ダブルクォートで囲まれた文字の列が文字列と見做される。
文字列は評価されると自身を返す。
    "Hello Paren"
    => "Hello Paren"
## 文字列の結合
文字列の結合は数値の加算と同じ組み込み関数+を用いる。
    (+ "Hello" "Paren")
    => "Hello Paren"
## 文字列の長さの取得
文字列の長さを取得するには組み込み関数のlengthを使用する。
    (length "Hello Paren")
    => 11
## 部分文字列の取得
部分文字列を取得するにはsubStringを使用する。
    (subString "Hello Paren" 6)
    => "Paren"
    (subString "Hello Paren" 0 5)
    => "Hello"
第一引数のみ指定されている場合はその値以降の部分文字列を取得する。
第二引数まで指定してある場合は、
第一引数から第二引数の値の前までの部分文字列を取得する。
ただし、どちらの場合も零から数える。
## 文字列の比較
文字列の比較は比較関数`=`で行う。
    (= "Hello Paren" "Hello Paren")
    => :t
    (= "Hello Paren" "hello paren")
    => :nil
## 部分文字列が含まれるか判定
部分文字列が含まれているかどうか判定するにはinclude?を使用する。
    (include? "Hello Paren" "Hello")
    => :t
    (include? "Hello Paren" "hello")
    => :nil
## 文字列の先頭がある部分文字列と一致するか判定
startWith?は文字列が特定の文字列で始まっているかを判定する。
    (startWith? "Hello Paren" "Hello")
    => :t
    (startWith? "Hello Paren" "hello")
    => :nil
## 文字列の末尾がある部分文字列と一致するか判定
endWith?は文字列が特定の文字列で終了しているか判定する。
    (endWith? "Hello Paren" "Paren")
    => :t
    (endWith? "Hello Paren" "Hello")
    => :nil
## 正規表現
Parenで正規表現を使用したい場合は:Regexモジュールをインクルードすること。
説明はそちらのドキュメントに譲る。

# リスト
リストはParenにおいて最も重要なデータ構造であり、
同時にParenを記述するプログラムでもある。
## コンスの作成
リストを理解するためにはコンスを知る必要がある。
コンスとはParenのデータへのポインタを二つ持ったデータ構造である。
二つのポインタが指す領域のうち、
片方をcar、もう一方をcdrと呼ぶ。
コンスは組み込み関数consにより作ることができる。
consの第一引数、第二引数が、それぞれ作成されるコンスのcarとcdrにあたる。
    (cons 1 :nil)
    => (1)
    (cons 1 (cons 2 :nil))
    => (1 2)
    (cons (cons 1 :nil) (cons 2 :nil))
    => ((1) 2)
Parenはコンスを次のように印字する。
1. 左括弧を印字
2. carが指す値を印字し、
   cdrが指す値が:nilなら3へ
   そうでなければ、再びcdrが指すコンスに対して2へ
3. 右括弧を印字
図示すると次のようになる。
    (cons 1 (cons 2 :nil))
    => (1 2)
    |car cdr|
      |   |
      | |car cdr|
      |   |   |
      1   2  :nil
このように、あるコンスのcdrで辿れるコンス全体が括弧で囲われて印字される。
ここで、コンスの厳密な定義を与える。
1. コンスはParenのデータへの二つのポインタcar、cdrをもつ
2. carは任意のParenのデータを指せる
3. cdrはコンスまたは:nilを指せる
定義より、cdrがコンスまたは:nil以外を指すようなコンスは作れない。
    (cons 1 2)
    => Error
コンスのcdrで辿れるコンス全体のことをリストという。
これは、辿れるコンス全体が単方向リストのデータ構造と見做せるからである。
下に、その対応関係を示す。
    値   対応
    ---------------------------------------------
    cons 単方向リストのセル
    car  単方向リストが格納するデータへのポインタ
    cdr  次の単方向リストのセルへのポインタ
    :nil 単方向リストの終端
ここで、:nilのことを特に空のリストという。
実際に、Parenのリスト操作関数は:nilが空のリストであるように振舞う。
Parenには引数がリストか判定する関数list?があるが、:nilもリストと見做される。
    (list? (cons 1 :nil))
    => :t
    (list? 3)
    => :nil
    (list? :nil)
    => :t
あるコンスのcdrを辿っていった終端が:nilを指している場合、
そのコンス全体は純リストであるという。
Parenのコンスの定義により、Parenの任意のリストはすべて純リストである。
純リスト以外のリストが作れないという制約は
ほかのLisp系の言語と比べると奇妙かもしれない。
最後に、Parenには引数がコンスか判断する関数cons?がある。
    (cons? 1)
    => :nil
    (cons? (cons 1 :nil))
    => :t
    (cons? :nil)
    => :nil
## carとcdrの参照
コンスが指す二つのポインタcar、cdrの指す場所を得る関数があり、
それぞれcarとcdrという。
    (<- lis (cons 1 (cons 2 :nil)))
    => (1 2)
    (car lis)
    => 1
    (cdr lis)
    => (2)
    (car (cdr lis))
    => 2
carとcdrは引数が空のリストの場合は:nilを返す。
    (car :nil)
    => :nil
    (cdr :nil)
    => :nil
    (car (cdr (cdr lis)))
    => :nil
carとcdrを組み合わせることは頻繁にあるため、
計五回までリストを辿るすべての組み合わせが定義されている。
    (cadr lis)
    => 2
    (cddr lis)
    => :nil
    (caddr lis)
    => :nil
## carとcdrへ代入
コンスのcarとcdrが指す場所を変更するには参照と同じcarとcdrを使用する。
これらは第二引数を与えると、参照先を第二引数に変更する。
    (<- a (cons 1 (cons 2 (cons 3 :nil))
    => (1 2 3)
    (car a)
    => 1
    (car a 0)
    => (0 2 3)
勿論、すべての操作関数でも同じ処理となる。
    (cadr a 1)
    => (0 1 3)
cdrが指す値を書き換える際、
Parenのコンスの定義から外れるような変更はエラーとなる。
    (cdddr a 4)
    => Error
## リストの作成
リストは関数consにより作られるが、
複数の要素を持つようなリストを作ろうとすると、すぐに困ったことになる。
    (cons 1 (cons 2 (cons 3 (cons 4 (cons 5 :nil)))))
    => (1 2 3 4 5)
そのため、Parenには引数を要素に持つようなリストを作成するための関数、
listが存在する。
    (list 1 2 3 4 5)
    => (1 2 3 4 5)
リストの定義により、要素がリストであるようなリストも作成することもできる。
    (list (list 1 (list 2 3) 4 5))
    => ((1 (2 3)) 4 5)
ここで、Parenのリストを作成する記述そのものが、
Parenのリストになっていることに注意されたい。
## リストの評価
既に説明した文字列、数値、変数等はリストではない。
これらをリストに対して、アトムと呼ぶ。
ParenはS式によって記述されると述べたが、
S式とはアトム又はリストのことをいう。
つまり、Parenはアトム又はリストによって記述されることに他ならない。
アトムの評価方法については都度その項目で述べてきた。
リストの評価方法については明示的に述べることはなかったが、
すべてこの形式であったはずである。
    (オペレーター 第一引数 第二引数 ...)
リストはまず最初に、オペレーターが評価される。
オペレーターはリストであっても構わず、その場合は再帰的に処理が行われる。
次に、評価したオペレーターの種類にしたがってリストを評価する。
第一要素の評価結果がオペレーターではなかった場合はエラーとなる。
    (1 2 3)
    => Error
Parenのオペレーターには次の三種類が存在する。
- 関数
- スペシャルオペレーター
- マクロ
ここでは各オペレーターの評価方法について簡単に述べ、詳細な説明は後の章に譲る。
関数は、すべての引数を評価した値をその関数の実引数として実行する。
listやconsなどは関数である。
関数は次のようなイメージで引数が評価されてから関数が実行される。
    (* (- 5 4) 3)
        ; *の第一引数の評価
        (- 5 4)
            ; -の第一引数の評価
            5
            <= 5
            ; -の第二引数の評価
            4
            <= 4
        <= 1
        ; *の第二引数の評価
        3
        <= 3
    ; *の評価
    (* 1 3)
    => 3
スペシャルオペレーターはParenに組み込まれている特殊なオペレーターで、
その種類ごとに引数の評価のされ方が異なる。
例えば、前述した代入オペレーターは奇数番目の引数は評価しないが、
偶数番目の引数は評価する。
    a
    => Error ; 変数未束縛によるエラー
    (<- a (list 1))
    => (1)
上の例では、もし代入オペレーターが関数ならば、
すべての引数を評価した結果をその関数の引数とするため、
aが評価されてエラーとなるはずである。
quoteもその特殊なオペレーターのうちの一つである。
    'a ; <=> (quote a)
    => a
マクロは定義のされ方により関数のように振舞う場合もあるし、
スペシャルオペレーターのように振舞うこともある。
マクロの定義次第で評価方法が異なるという点では、
スペシャルオペレーターと同じであるが、
ユーザが定義することができるという点で異なる。
この強力な機能については後述する。
今の段階では、関数が基本的なリストの評価ルールで、
それ以外の特殊な評価が行われるのがマクロであり、
スペシャルオペレーターはユーザが定義できないマクロである。
というくらいの認識で構わない。

# 関数
関数はParenの根幹をなすデータ型である。
ただし、この文書内における関数という単語は、
計算幾何学における手続き(サブルーチン)程度の意味しかない。
## 関数の定義
関数を定義するにはマクロdefを用いる。
次に、与えられた引数を二倍した値を返す関数を定義する例を示す。
    (def double (x)
      (* 2 x))
defの第一引数は定義する関数の名前であり、ここではdoubleとした。
第二引数は定義する関数の仮引数のリストとなる。
ここでは必須の引数を一つ受け取るのでその仮引数名をxとした。
仮引数のリストには後述するいくつかの指定方法がある。
第三引数以降は関数の本体のリストである。
関数の本体は左から順に逐次実行される。
## 関数呼び出し
定義した関数を呼び出すには、呼び出したい関数が第一要素、
その関数に渡したいi番目の引数がi + 1番目の要素であるようなリストを評価する。
先に定義したdoubleを呼び出す例を示す。
    (double 3)
    => 6
    (double 4)
    => 8
第一要素が関数であるようなリストの評価は次の順で行われる。
1. リストの第一要素を評価する。(今考えているのはこの評価結果が関数である)
2. リストの第二要素以降を番号を若い順に評価する。
3. 関数の実引数として、第二要素以降の評価結果を渡す。
4. 関数の本体が実行される。
## 仮引数の定義
関数を定義するときに指定する仮引数にはいくつか種類がある。
1. 必須パラメーター
2. オプショナルパラメーター
3. レストパラメーター
4. キーワードパラメーター
任意のパラメーターを同時に組み合わせて指定することができるが、
同時に指定する際は、上の順番で指定しなければならない。
### 必須パラメーター
必須パラメーターは変数により指定される。
指定したパラメーターは必須となり、
関数呼び出し時に実引数が足りない場合はエラーとなる。
    (double 2)
    => 4
    (double)
    => Error
    (def avg2 (x y)
      (/ (+ x y) 2))
    (avg 2 4)
    => 3
    (avg 2)
    => Error
### オプショナルパラメーター
オプショナルパラメーターは引数に初期値を与える仕組みである。
呼び出し時に省略された場合はその初期値が使用される。
仮引数に`:opt`が出現した以降の値がオプショナルパラメーターとして扱われる。
オプショナルパラメーターは変数名とその初期値をリストで指定する。
    (def incN (x :opt (x 1))
      (+ x adding))
    (incN 3)
    => 4
    (incN 3 2)
    => 5
初期値が:nilであるようなオプショナルパラメーターは、
オプショナルパラメーター名だけ指定することができる構文糖がある。
そのため、次の二つの関数は等価である。
    (def opt1 (:opt (x :nil)) x)
    (def opt2 (:opt x) x)
また、別のパラメーターが出現するまで複数指定することができる。
    (def concat (s1 :opt s2 s3)
      (+ s1 (if (nil? s2) ""
                (if (nil? s3) s2
                    (+ s2 s3)))))
    (concat "Hello")
    => "hello"
    (concat "Hello" "World")
    => "HelloWorld"
    (concat "Hello" "World" "!!")
    => "HelloWorld!!"
ただし、オプショナルパラメーターを複数指定する場合に、
i番目のオプショナルパラメーターを指定して関数を呼びたい場合は、
i - 1番目までのオプショナルパラメータをすべて指定する必要がある。
### レストパラメーター
レストパラメーターは関数を可変長引数にするための仕組みである。
仮引数に`:rest`が指定された直後の変数をレストパラメーターに束縛する。
レストパラメーターは二つ以上指定することはできない。
下に示すように仮引数よりも余分な実引数が、
リストとして実行時にレストパラメーターに束縛される。
    (def restTest (first :rest params)
      (list first params))
    (restTest 1 2 3)
    => (1 (2 3))
    (restTest 1)
    => (1 :nil)
### キーワードパラメーター
キーワードパラメーターとは、
仮引数の宣言順に依存しないで実引数を指定できるようにする仕組みである。
仮引数に`:key`が指定された以降の値がキーワードパラメーターとして扱われる。
宣言方法はオプショナルパラメーターと同じである。
    (def manyKey (:key (k1 0) (k2 0) (k3 0))
      (list k1 k2 k3))
    (manyKey)
    => (0 0 0)
    (manyKey :k1 1)
    => (1 0 0)
    (manyKey :k1 1 :k3 1)
    => (1 0 1)
初期値が:nilである場合の構文糖も使えることに注意せよ。
## 無名関数
プログラムを書いていると、定義してまで使う程での処理でもないが、
関数を作成したい場面があるかもしれない。
このような場合にはスペシャルオペレーターfnを使用できる。
    (fn 仮引数のリスト 関数の本体)
fnに与える引数は、名前を指定しないという点を除いてdefと全く同じである。
次の例は引数を足す関数を返す関数addNである。
    (def addN (n)
      (fn (x)
          (+ x n)))
    (<- add10 (addN 10))
    (add10 2)
    => 12
    ((addN 1) 2)
    => 3
実は、defが行っている処理はfnで作られた関数を、
第一引数で指定された名前の変数に代入しているだけなのである。
このことについては、後述するマクロの章で述べる。
## 汎関数
前述したように関数はParenの一つのデータ型にすぎない。
そのため、他のデータ型である数値や文字列と同様に、
変数に代入したり、関数に引数として渡したり、
関数の返り値として返したりすることができる。
ここで、関数全体の集合のうち、
引数に関数をとる、或いは、返り値が関数であるように定義された関数を、
汎関数または、高階関数という。
汎関数を用いることにより、高度な抽象化を用いることができる。
この例は既に前述の汎関数addNで見た。
## 再帰関数
関数全体の集合のうち、関数の本体で自分自身を呼ぶような関数を再帰関数と呼ぶ。
再帰関数を用いると直感的にプログラムできることがある。
再帰関数の例として整数nの階乗を求める関数factorialを示す。
    (def factrial (n)
        (if (= n 1) 1
            (* n (factorial (- n 1)))))
数学的には
    factorial(n) {
        1, (n = 1),
        n * factorial(n - 1), (n > 1).
と書けるが、
再帰関数を用いることにより、階乗の定義をそのまま書き下せていることが分かる。
また、再帰関数全体の集合のうち、
自身の呼び出しごとにスタックが積まれないような関数を末尾再帰関数という。
上記のfactorialは呼び出しごとにスタックが積まれていくため末尾再帰関数ではない。
factorialは次のような末尾再起関数に変換できる。
    (def factorial (n ? acc 1)
        (if (= n 1) acc
            (factorial (- n 1) (* acc n))))
## 純粋関数
関数全体の集合のうち、次の性質を持つものを特に純粋関数という。
- 任意の引数に対して、返り値が時間に依存せずに一意に定まる
- 他に何も影響を与えない
このような性質を参照透過性という。
また、二つ目の性質
> 他に何も影響を与えない
のことを副作用という。
次のような処理は副作用である。
- 代入
- 入出力
定義から、次のような関数は純粋関数ではない。
- あるグローバル変数の値の3倍の数を返す関数
- 引数を標準出力に印字する関数
- 引数の値を3倍に変更する関数
- 現在時刻をシードとした0か1の乱数を返す関数を返す関数
逆に、次のような関数は純粋関数である。
ただし、一連の処理には副作用はないこととする。
- 引数を返す関数
- 引数の文字列表現を返す関数
- 引数の値の3倍の値を返す関数
- 引数をシードとした0か1の乱数を返す関数を返す関数
可能な限りプログラムは純粋関数で構成することが望ましい。
これは、純粋関数は関数に比べてとりうる状態が少なく、
一般的に汎用的な処理になりバグも発生しにくいことによる。

# 条件分岐
Parenには条件分岐のオペレータifが存在する。
上記のオペレーターが気にいらなかったり、
新たにオペレーターが必要になった場合は後述するマクロでいつでも拡張できる。
## if
ifは一般的かつ、汎用的な条件分岐を実現する。
    (if (test-form1 form1-1 ...)
        (test-form2 form2-1 ...)
        ...
        (test-formN formN-1 ...))
ifの引数はリストのリストである。
ifは最初の引数から、そのリストの先頭の要素を評価する。
評価結果が真の場合はそのリストの残りの要素を順に評価し、
そうでなければ次の引数に対して同じことを行う。
    (def roman (x)
      (if ((= x 1) :one)
          ((= x 2) :tow)
          ((= x 3) :three)
          (:else :more)))
    (roman 1)
    => :one
    (roman 4)
    => :more
if全体は条件式が真を返す引数があれば、その引数の最後の要素の評価結果を返す。
そうでなければ:nilを返す。
最後の引数がデフォルト節である場合は、
:defaultや:elseや:tなど分かりやすいものを使用するとよい。
ちなみにifは他のLisp系言語におけるcondと同じ処理となる。
## 比較関数
Parenには、あるオブジェクトが等しいか判定する関数が二種類存在する。
    関数 処理
    --------------
    =    同等判定
    eq?  同一判定
ここで、あるオブジェクトA、Bの存在を仮定する。
AとBが同等であるとは、AとBの型が等しく概念的にも等しいと見做せることをいう。
AとBが同一であるとは、AとBがメモリ上の同一アドレスに存在することをいう。
これらの定義から次のことが言える。
- 同等である条件はオブジェクトの型により異なる。
- 同一であることは同等であることの必要条件であるが十分条件ではない。
`=`は二つ以上のオブジェクトがすべて同等であれば真を返す。
    (= 3 3 3)
    => :t
    (= 3 2)
    => :nil
    (<- a 3 b 3)
    => 3
    (= a b)
    => :t
次のように型が異なる場合は、概念的に等しくても偽を返す。
    (= "3" 3)
    => :nil
`eq?`は、比較する二つ以上のオブジェクトがすべて同一である場合に真を返す。
    (eq? 3 3)
    => :nil
    (<- a 3 b 3)
    => 3
    (eq? a b)
    => :nil
    (<- b `a)
    => a
    (eq? a b)
    => :t
`eq?`はメモリの番地の比較をするだけなので高速である。
また、Parenでは同一変数はすべて同一なオブジェクトであることが保証されている。
    (eq? :a :a)
    => :t
    (<- a 3)
    => 3
    (eq? a a)
    => :t
## 述語の結合
ある式の評価結果が真か偽を表すことを強調する場合その式を述語という。
Parenには述語を結合するオペレーターがある。
    名称 処理
    ------------------------------------------------------------------------
    and  すべての引数の評価結果が真の場合に最後の評価結果を返す。
         ただし、評価途中に偽を返す式があったら以降の評価を中断し:nilを返す。
    or   どれか一つの引数の評価結果が真の場合にその値を返す。
         ただし、評価途中に真を返す式があったら以降の引数は評価しない。
         また、すべての引数の評価結果が偽の場合は:nilを返す。
    not  述語が真の場合は偽を、偽の場合は真を返す。
Parenには`=`の否定を返す関数`!=`が存在するが、
notの定義により次の二つの式は等価となる。
    (!= expr1 expr2)
    <=> (not (= expr1 expr2))

# 反復
Parenには反復を実現するオペレーターがいくつかある。
- for
- while
- each
また、このほかの反復処理はマクロを用いてユーザが自由に拡張可能である。
## for
forは次の書式をとる。
    (for (init-form end-test-form step-form [result-form])
        form ...)
forが評価されるとき、最初にinit-formが実行される。
そのあとに次の順で反復処理が行われる。
1. end-test-formを評価した結果が真の場合2へ、偽なら反復終了
2. すべてのformを逐次実行
3. step-formを評価して1へ戻る
反復終了後に、result-formが指定してある場合は評価してfor全体の返り値とする。
指定していない場合は:nilを返す。
単純なforの使用例として1から10までの和を返すプログラムを示す。
    (for ((<- i 1 sum 0) (<= i 10) (+! i 1) sum)
        (+! sum i))
    => 55
## while
whileは次の書式をとる。
    (while (end-test-form [result-form])
        form...)
次の手順で反復処理が行われる。
1. end-test-formを評価した結果が真なら2へ偽なら反復終了
2. formを逐次実行し、1へ戻る
while全体として、result-formが指定されている場合はその評価結果を返す。
指定されていない場合は:nilを返す。
## each
eachは引数が反復可能なオブジェクトの場合に使用できる。
反復できるオブジェクトとには次の種類が存在する。
- 配列
- リスト
eachは第一引数のリストの第一要素に反復時に使用する変数名を、
第二要素に反復する対象を指定する。
eachの第二引数移行が、反復処理の対象となる。
    (each (iterator object [result-form])
        form...)
簡単な実行例を示す。
    (each (i (range 1 5))
        (print i))
    => 12345
    (each (i "12345")
        (print i))
    => 12345
また、第一引数のリストに第三要素が指定されている場合、
反復終了後のeach全体としてその式を評価した結果を返す。

# 配列
配列は連続したメモリ上にデータを確保するデータ構造である。
配列で表現することのできる任意のデータ構造はリストでも再現可能であるが、
処理速度等の理由により配列を採用する場合はがある。
なお、Parenの配列はParenのデータなら何でも代入することができる。
## 配列の生成
配列は組み込みのarray関数で作成する。
arrayの書式を示す。
    (array size [initial_function])
sizeは必須パラメーターで作成する配列の大きさを指定する。
なお、配列は一度作成するとその大きさは変更できない。
    (array 3)
    => [:nil :nil :nil]
初期化関数`initial_function`は省略可能で、
指定しない場合は、初期値:nilで初期化される。
初期化関数は引数を一つとる関数で次のように、
各要素番号を使用した初期化が可能。
    (array 3 (fn (i) (* i 2)))
    => [0 2 4]
## リードマクロによる生成
初期値があらかじめ決まっているような配列はリードマクロを使うと便利である。
    #[1 2 3]
    => [1 2 3]
## 要素の参照
配列の要素を参照するには組み込み関数の`[]`を使用する。
次に書式を示す。
    ([] array index)
添え字は零から数える。
    (<- arr #[1 2 3])
    => [1 2 3]
    ([] arr 1)
    => 2
配列が確保している範囲外にアクセスするとエラーとなる。
    ([] arr 3)
    => Error
## 配列の要素の更新
配列の要素を更新するには参照と同じ関数`[]`を使用する。
次に書式を示す。
    ([] array index value)
簡単な使用例を示す。
    (<- arr #[1 2 3])
    => [1 2 3]
    ([] arr 1 10]
    => [1 10 3]
また、式の返り値は配列となる。
## 多次元配列
配列の要素には任意のParenのデータを保持できるため、
配列の各要素が配列であるような配列が定義できる。
このような配列を2次元配列という。
この概念を拡張して、一般に多次元配列という。
Parenでは多次元配列をコアライブラリに含めることはせず、
モジュールとして提供する。

# マップ
マップは配列の添え字に任意のParenデータを設定できる配列である。
実装はハッシュテーブルにより実装されているため、
理論上はO(1)でデータの探索が可能。
詳細な仕様については別ドキュメントを参照されたい。
## マップの作成
マップを作成するには組み込みのmap関数を使用する。
    (map)
    => {}
要素を指定して初期化する場合はリードマクロを使用できる。
下の例のようにキーと値をペアで指定する。
    #{key1 val1
      key2 val2
      key3 val3}
    => {key1 val1 key2 val2 key3 val3}
## 要素の参照
マップmapのキーkeyに対応する値を参照するには`{}`関数を使用する。
    ({} map key)
簡単な実行例を示す。
    (<- map #{:key1 :val1 :key2 :val2})
    => {:key1 :val1 :key2 :val2}
    ({} map :key2)
    => :val2
ただし、keyに対応する値がない場合は:nilを返す。
そのため、keyが設定されているのか、否かは関数hasKey?を使用する必要がある。
## 要素の設定
マップmapのキーkeyに値valueを設定するには`{}`関数を使用する。
    ({} map key value)
簡単な実行例を示す。
    (<- map #{:key1 :val1 :key2 :val2})
    => {:key1 :val1 :key2 :val2}
    ({} map 3 :three)
    => {:key1 :val1 :key2 :val2 3 :three}
返り値はマップとなる。
また、既にキーに対する値がマップに存在する場合は上書きする。
    ({} map :key2 :two)
    => {:key1 :val1 :key2 :two 3 :three}

# 構造体
TODO

# スペシャルオペレーター
スペシャルオペレーターはParenのS式の評価ルールに従わない、
オペレーターごとに異なる特別なルールで評価される。
スペシャルオペレーターには次の種類が存在する。
- <-
- let
- if
- do
- quote
- fn
これらのうち、いくつかはすでに説明してきた。
ここでは、まだ説明していないスペシャルオペレーターについて述べる。
## let(変数束縛)
    let = '(let' '(' let_form+ ')'
              s_expr* ')'
    let_form = '(' variable s_expr ')' | variable | nil
`let`は新しく変数を束縛する。
束縛する変数が既に宣言されていても構わない。
第一引数が変数束縛式のリストを表す。
変数束縛式がシンボルの場合は
第二引数以降が、第一引数で束縛した変数の環境下にて暗黙のdoにより評価される。
## do(逐次実行)
    '(do' s_expr+ ')'
doは引数を左から順に評価していき、
最後の式の評価結果を返す。
## try(例外処理コンテキスト作成)
    '(try' s_expr+ ')'
tryは例外発生時に内部のcach
## quote(クォート)
    (quote expr)
`quote`はS式`expr`の評価を見送り、`expr`そのものを返す。
その利用頻度から構文糖であるリードマクロ`\``が定義されている。

# マクロ
マクロはParenが読み込まれ、リードマクロが展開された後に実行される。
この実行をマクロ展開という。
マクロはリードマクロ、マクロ、スペシャルオペレーター、 関数等、
すべてのParenの機能を使用してユーザが定義することができる。
マクロは使用される前に定義がされている必要がある。
マクロ展開は、展開結果にマクロが含まれなくなるまで再帰的に行われる。
## マクロ定義
TODO

# リードマクロ
TODO

# goto文
TODO

# 例外処理機構
TODO

# 付録
## 左辺一覧
Parenで左辺となりうる対称の一覧を示す。
    対象   参照            代入
    -------------------------------------------
    変数   var             (<- var val)
    コンス (car var)       (car var val)
           (cdr var)       (cdr var val)
    配列   ([] var index)  ([] var index val)
    マップ ({} var index)  ({} var index val)
    構造体 (get var index) (set var index val)
その使用頻度から組み込みの代入手続きは
> 副作用をもつオペレーターの末尾には`!`を付ける。
という命名規約を破っている。

## 命名規約
Parenでの命名規約をまとめる。
これは言語機能により強制されるわけではなく、
あくまで推奨されるものである。
### 命名方法の定義
    命名方法       定義
    -----------------------------------------------------------------------
    パスカルケース 単語の区切りの最初の一文字を大文字にする命名法
    キャメルケース 最初の一文字目を小文字にする点を除きパスカルケースと同じ
    スネークケース 単語の句切れをアンダースコアでつなぐ命名法
    チェインケース 単語の句切れをハイフンでつなぐ命名法
### 命名規約速見表
下に示す命名規約は推奨すべき命名方法であり、
場合によってはこの限りではない。
    対象            命名方法
    --------------------------------------------------------
    ファイル                  スネークケース
    定数                      すべて大文字のスネークケース
    ローカル変数              キャメルケース
    グローバル変数            `$` + キャメルケース
    クラス                    パスカルケース
    恒等変数                  `:`から始まるキャメルケース
                              (ただし、型を表す場合はパスカルケースとする。)
    述語                      末尾に`?`を付ける
    破壊的処理                末尾に`!`を付ける
    束縛系のマクロ            withから始める
    アナフォリック系のマクロ  最後に`*`を付ける
    構造体                    パスカルケース
