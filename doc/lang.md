Paren言語仕様書

# 概要
この資料はParenの仕様を定義する。
Parenのチュートリアルは別紙を参照のこと。

# 基本概念
ParenはCommon Lisp、Scheme、Arc等のLisp系の言語を参考に、
より、簡潔に記述できるよう設計したプログラミング言語である。
Common Lispのように強力なマクロの機能を備える。
Parenは次のコンセプトで作られた。
- より短く書ける
- 迅速な開発に適している
- 書いていて楽しい
逆に、次のような項目は全く考慮しない。
- 実行速度
- 健全なマクロ

# S式
Parenはアトムまたはリストにより記述される。
この記述をS式と呼ぶ。
S式は評価されるとS式を返す。

# メタ言語
Parenの文法を以下のEBNF表記で定義する。
    x? -- xは省略可能。
    . -- 任意の一文字
    x* -- xの零回以上の繰り返し。
    x+ -- xの一回以上の繰り返し。
    (x | y) -- xまたはy。
    'x' -- 固定字句。文字の並びxを示す。xは複数の場合もある。
    [...] -- 文字グループ。[]内で指定された文字の何れか。
             x-yと表記された場合はxとyの間の何れかを表す。
             先頭に~を指定した場合は[]内で指定された文字以外の何れかを示す。
    ::= -- 定義。左辺で示される構文要素を右辺で定義される。
## 注意事項
メタ言語内で、可読性のため空白を挿入することがあるが、
その空白はメタ言語において無視されるものとする。
固定字句及び文字グループ中で`\`を記述した場合、後続する文字そのものを意味する。
ただし、`\t`及び`\n`はそれぞれタブ文字、改行文字を意味するものとする。
量指定子は特に指定がなければ最長一致とする。

# 字句規則
ここで述べる字句規則はリードマクロ展開後のものであり、
展開前の字句規則はリードマクロの定義に従う。
## 字句の区切り(separator)
    separator ::= space | comment
プログラムは空白又はコメントにより区切られる。
これらは要素の区切りとして使用される以外は無視される。
### 空白(space)
    space ::= [\t\n ]
空白はタブ文字、改行文字、半角スペースである。
### コメント(comment)
    comment ::= (line_comment | documentation_coment)
    line_comment ::= ';' [^\n]*
    documentation_coment ::= '"""' .* '"""'
コメントは一行コメントとドキュメンテーションコメントの二種類存在する。
一行コメントは`;`から行末までである。
ドキュメンテーションコメントは`"""`で始まり`"""`で囲まれた領域であり、
最短一致で字句解析されるため、内部で`"""`を使用することはできない。
## S式(s_expr)
    s_expr ::= list | atom
S式はリストまたはアトムである。
### リスト(list)
    list ::= '(' (s_expr (separator s_expr)*)* ')'
リストは零以上のS式を括弧`(`、`)`で括ったものである。
要素がないリストは空のリストと呼び、
セマンティックス上は後述するキーワード`:nil`と等価である。
### アトム(atom)
    atom ::= (identifier | number | string)
atomは次のリテラルがある。
- 識別子
- 数値
- 文字列
#### 識別子(variable)
    identifier ::= (identifier_first+ identifier_rest* | identifier_special)
    identifier_first ::= [!$%&*/:<=>?a-zA-Z^_|]
    identifier_rest ::= (identifier_first | [#'0-9])*
    identifier_special ::= ('+' | '++' | '-' | '--')
識別子は一部の記号及び数字を除く文字から始まり、
ほとんどすべてのascii文字が任意の数続く。
#### 数値(number)
    number ::= [+-]? [0-9]+ ('.' [0-9]+)?
Parenでは指数表記等はサポートしない。
処理の簡潔化のため、`001`等も数字と見做し、`1`と評価する。
#### 文字列(string)
    string ::= '"' ([^"\\] | esc)* '"'
    esc ::= '\\' .
文字列はダブルクォートで囲まれた文字またはエスケープシーケンスの列である。
エスケープシーケンスは'\'から始まり次の一文字によりその意味が異なる。
- n: 改行
- t: 水平タブ
- それ以外の文字: その文字そのもの

# リードマクロ
リードマクロはParenの読み込み時に展開される。
展開結果にリードマクロが含まれる場合は再帰的に展開される。
ここでは厳密に定義することはせず、
意味論的にどのように展開されるべきかについて述べる。
## クォート(quote)
    ''' s_expr
    => (quote s_expr)
クォートはS式の前に`'`を付けたものである。
展開結果はスペシャルフォーム`quote`で囲まれる。
この展開を`s_expr`をクォートする。乃至、`s_expr`がクォートされるという。
## バッククォート(tilde)
    '`' s_expr
    => (back_quote s_expr)
バッククォートはその後に読み込まれるS式内に、
後述するカンマまたは、カンマアットが含まれている場合を除き、
クォートと同じ振る舞いをする。
## カンマ(comma)
カンマはバッククォート内でのみ使用でき、
外で使用した場合はエラーとなる。
バッククォート内のフォームは評価対象外となるが、
その中のカンマ内のフォームを評価対象にする。
この展開をアンクォートするという。
評価例を示す。
    `(list 1 ',(list 2 3))
    => (list 1 '(2 3))
## カンマアット(comma_at)
カンマアットリードマクロは評価結果を、
外側のListに結合させる点を除き、
カンマリードマクロと同じである。
評価例を示す。
    `(list 1 ,@(list 2 3))
    => (list 1 2 3)
## 配列(array)
    '#[' s_expr* ']'
    => (array s_expr)
配列は鍵括弧`[`、`]`で囲まれたS式である。
展開後は、配列を生成するS式となる。
## マップ(map)
    '#{' (s_expr s_expr)* '}'
    => (map s_expr)
マップは括弧`{`、`}`で囲まれたS式の対である。
展開後は、マップを生成するS式となる。
