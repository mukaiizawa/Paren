覚書

# 概要
Parenを作成するにあたり検討した記録などを示す。

# 総称関数
初期のParenの関数は次の仕様で策定されていた。
- すべての関数は総称関数である
- 総称関数は実行時に第一引数の型から動的にディスパッチされる
- 引数のない総称関数は許さない
この策定の背景には次の背景がある。
- 型ごとのメソッドの乱立を避けたい
  =, string=, char=等
memo- packageをなくし、型で構造化したい
しかし、この仕様は次の理由で取りやめとなった。
- 引数無しの関数が使えないのため不便
- primitiveに総称関数をサポートすると実装が複雑になる
- 書いていてつまらない
- Parenらしくない

# 代入
代入を行う際に、次の二つのケースが考えられる。
1. 代入対象の変数が現在の環境に束縛されている場合
2. 代入対象の変数が現在の環境に束縛されていない場合
clの場合、現在の環境に束縛されていた場合はその値を更新する。
そうでなければ、親の環境を再帰的に探索して更新する。
トップレベルにも束縛されていない場合はトップレベルに束縛する。
Parenでは代入を頻繁に使用するため、
現在の環境に変数束縛されていない場合に親の環境に束縛する仕様は不便だと思われる。
例えば次のソースコードはトップレベルにcを束縛してしまう。
    (function copy ()
      (while ((!= (<- c (getc)) :EOF))
        (putc ch)))
## 代入を二種類用意する方法
もし、現在の環境で未束縛の場合に親の環境の変数を更新したい場合は、
代入オペレーターを二種類用意する必要がある。
一つは、現在の環境に変数がない場合に自身の環境に新しく変数束縛するもの。
もう一つは、現在の環境に変数がない場合は親の環境を探索するものである。
## 代入を環境ローカルにする方法
代入する際に現在の環境に変数が束縛されていない場合は、
必ず現在の環境に値を束縛するようにする。
この方法を採用した場合、最悪の場合は代入を二種類定義する方法にシフトが可能。
関数が新しく環境を作成すると考えるとclみたいにletで明示的に環境を作成することはなくなるか。
## 方針 2017-10-18
次の仕様で実装することにする。
代入オペレーターは2種類実装する。
    オペレーター 処理
    ----------------------------------------------------------------
    <-           現在の環境に束縛されている場合はその値を更新
                 そうでなければ、現在の環境に束縛
    <--          現在の環境に束縛されている場合はその値を更新
                 そうでなければ、親の環境を探索
次のようにな記号も考えたが、タイプ数など様々な理由により却下
- ::=
定義として使用したいが、その場合よく使うローカル変数に束縛する演算子となり、タイプ数が多くなりがち
- <<-
第二候補
- <<
シフト演算子に見える
- <=
不等号に見える
- <-!
schemeのように破壊的なオペレーターに統一的につけているわけではないため見送り
- !<-
同上

# 入出力関数
Parenオブジェクトを出力する関数の名称をどうすればよいか検討する。
ちなみにclの主要な関数は次のとおり
- prin1
- print
- princ
- pprint
2017-10-19
次の仕様で実装する。
    関数       処理
    -----------------------------------------
    write_expr Parenオブジェクトとして出力
    write      書き込み
    write_line 書き込み後改行
    read_expr  Parenオブジェクトとして入力
    read_char  一文字読み込み
    read_line  一行読み込み

# クラス
Parenは関数型言語として設計されているが、
マクロの力により、手続き型言語として使用することも十分可能であることを見てきた。
ここではマクロを用いてParenの上に構築されたオブジェクト指向言語について述べる。
以後、このオブジェクトシステムをPOOP(Paren Object Oriented Programming)と呼ぶ。
POOPはCommon LispのCLOSから強い影響を受けているが、
強力すぎる機能をそぎ落として、使用頻度が高い必要最低限の機能に抑えてある。
また、実装の簡潔に心がけ必要に応じてハックできる余地も残してある。
## クラスの作成
クラスはマクロclassにより作成する。
    (class class_name (super_class ...)
        field ...)
    class_name -- 作成するクラスの名前
    super_class -- 作成するクラスのスーパークラス
    field -- 作成するクラスのインスタンス変数
classマクロは次のような式に展開される。
    (<- Class #{:type :Class
                :super '(:SuperClass ...)
                :fields #{:field :nil ...}})
二次元ベクトル空間の元を表すクラスPointを示す。
例のように、クラス名は慣習としてパスカルケースを用いる。
    (class Point () x y)
作成したクラスはグローバル変数$classに登録される。
クラスの実態は次に示すようなキーと値を持つようなハッシュマップである。
    キー    値
    -------------------------------
    :type   型
    :super  親クラスのリスト
    :fields このクラスのフィールドのリスト
クラスの構成から分かるように、メソッドはクラスに属さない。
Parenのメソッドは次に示すように、呼び出し時に動的にディスパッチされる。
クラスの型を調べるにはtypeマクロを使用する。
    (type Class) <=> ({} Class :type)
    => :Class
## インスタンスの生成
インスタンスの生成にはnewマクロを使用する。
newの実態は、クラスをディープコピーするだけである。
Parenのクラスシステムはクラスベースというよりはプロトタイプベースに近い。
    (new Class) <=> (copy Class)
## メソッドの定義
メソッドの定義はmethodマクロを使用する。
methodは型と変数名のリストを必須パラメーター指定するようなdefだと思えばよい。
このマクロはグローバル変数$methodにメソッド登録するS式に展開される。
    (method .method ((Class c))
       body_forms)
    <=> ({} ({} $method .method) '(:Class) body_form)
$methodはキーにメソッド名称、値にその型ごとの実装のハッシュマップを持つ、
ハッシュマップである。
生成したオブジェクトの初期化は、慣習としてinitメソッドを定義してそこで行う。
    (init (new Point) :x 4 :y 5)
このようなinitは次のように定義されているであろう。
    (method init ((Point p) :key (x 0) (y 0))
        (.x p x)
        (.y p y))
例に示すように、実はインスタンス定義したインスタンス変数は、
自動でアクセサが生成される。
    (class Point () x y)
    (method .x ((Point p) :opt x)
      (if ((nil? x) ({} ({} :fields p) :x))
          (:else ({} ({} :fields p) :x x))))
    (method .y ((Point p) :opt y)
      (if ((nil? y) ({} ({} :fields p) :y))
          (:else ({} ({} :fields p) :y y))))
Parenでは宣言したインスタンス変数はすべて外部に公開する仕様である。
このことは、作成するクラスにドキュメントを書くことと、
使用するクラスのドキュメントを読むことを後押しする。
また、クラスをハックする手段を意図的に残している。
