覚書

# 概要
Parenを作成するにあたり検討した記録などを示す。

# 総称関数
初期のParenの関数は次の仕様で策定されていた。
- すべての関数は総称関数である
- 総称関数は実行時に第一引数の型から動的にディスパッチされる
- 引数のない総称関数は許さない

この策定の背景には次の背景がある。
- 型ごとのメソッドの乱立を避けたい(=, string=, char=等)
- packageをなくし、型で構造化したい

この仕様は次の理由で取りやめとする。
- 引数無しの関数が使えないのため不便
- primitiveに総称関数をサポートすると実装が複雑になる

# 代入
代入を行う際に、次の二つのケースが考えられる。
1. 代入対象の変数が現在の環境に束縛されている場合
2. 代入対象の変数が現在の環境に束縛されていない場合

clの場合、現在の環境に束縛されていた場合はその値を更新し、そうでなければ、親の環境を再帰的に探索して更新する。

ただし、トップレベルにも束縛されていない場合はトップレベルに束縛する。

Parenでは代入を頻繁に使用するため、現在の環境に変数束縛されていない場合に親の環境に束縛する仕様は不便だと思われる。

例えば次のソースコードはトップレベルにcを束縛してしまう。
    (function copy ()
      (while ((!= (<- c (getc)) :EOF))
        (putc ch)))

2017-11-27
Lisp系の言語はマクロで暗にコンテキストが生成されるため、現在のコンテキストに無条件に束縛するという行為は危険であることが分かった。

例えば、forが新しく環境を作るか否かで動作が異なる。もしforが環境を作る場合は予期した動作にならない。
    (function f ()
        (<- x 0)
        (for (<- i 0) (< i 10) (++ i)
            (write (<- x (* i x)))))

勿論、forが新たにコンテキストを作ることを理解していれば上の環境に伝番する代入オペレーターを使用すれば問題ない。
    (<-- x (* i x))

しかしながら、マクロの実装を常に把握しておくのは難しく、デバッグが困難なバグを生み出してしまう危険がある。

そのため、Parenに実装するオペレーターは次の二つに変更する。

    オペレーター 処理
    ----------------------------------------------------------------
    <-           束縛対象のシンボルが見つかるまで親の環境を探索する。
                 見つからなければ大域環境に束縛する。
    <--          必ず大域環境に束縛する。

# 入出力関数
Parenの入出力関数について検討する。

ちなみにclの主要な関数は次のとおり
- prin1
- print
- princ
- pprint

2017-10-19
次の仕様で実装する。
    関数       処理
    -----------------------------------------
    write_expr Parenオブジェクトとして出力
    write      書き込み
    write_line 書き込み後改行

    read_expr  Parenオブジェクトとして入力
    read_char  一文字読み込み
    read_byte  一バイト書き込み
    read_line  一行読み込み

# 真偽値の扱いについて
2018-06-04
parenの真偽値は次のように策定していた。
    ## 真偽値
    Parenは次にあげる値を除き、すべて真と見做される。
    - false
    - nil
    - 0
    - ""

しかし、次のようにifのelse節が省略されている場合に返り値がnilであると期待しているコードが書けなくなる。
    (<- map (lambda (lis f) (if lis (cons (f (car lis)) (map (cdr lis) f)))))
    (map '(1 2 3) (lambda (x) (+ x x)))
    ; (2 4 6 . false)

これに対して次のようなことを考えた。
- 明示的にifのelse句を書くようにする
- pythonのように、偽の値をそれぞれの型に都合のよいように解釈する(1 + true => 2)
- 偽と見做す値をnilのみにする

2018-06-05
listが最重要データ構造であり、ifの返り値がnilであることになれているため偽と見做す値をnilのみに修正した。

# letのスペシャルフォームに変更
2018-06-07
当初letの実装はlambdaのマクロによる実装を考えていたが、次の理由によりスペシャルフォームに変更した。
- 処理速度向上のため
- 次のような再帰関数束縛のため
    (let ((rec (lambda (x) (if x (rec (cdr x))))))
        ...)
- 展開結果が分かりにくかったため

# データリストの概念の導入
2018-06-21
POSシステム実装にあたり、あれば便利だなということで新しい仕様を考案。

データリストとは、第一要素がキーワードであるような連想配列をいう。
    (:A ....)

特に、第一要素のキーワードをこのデータリストの型という。

データリストは評価されると自身を返す。

# オブジェクト
2018-07-09
データリストの発想を発展させてPOSシステムのオブジェクトを定義する。

POSシステムでは、第一要素がキーワードのリストのことをオブジェクトという。
このとき、第一要素(したがって、キーワード)をオブジェクトの型という。

    <object> ::= (<type> <field_list> ...)
    <field_list> ::= (<field> <field_value>)

オブジェクトの型以外の要素はすべてリストとなっており、それぞれのリストは

例(文字列オブジェクト)

例えば次の文字列リテラルはリードマクロによって次のオブジェクトに展開される。
    "hello world"

    (:String (val (array 104 101 108 108 111 32 119 111 114 108 100))
             (length 3)
             (hash 0x234234))

# プロトタイプベース
2018-07-23

parenのPOSシステムをプロトタイプベースにしてみてはどうかと思い至った。
下に示すように、関数呼び出しの記法が納得いけば問題ないか。

(function . (k o :optional v)
 "
 # vが与えられていない場合
 オブジェクトoからプロパティkに対応する値を取得する。
 # vが与えられた場合
 オブジェクトoのプロパティkに値を設定する。
 ")

; define abstruct class
(class Reader () :rd read-byte)
;; (<- Reader (clone Object))

(.read-byte Reader (lambda () ((.fgetc OS))))


(class AheadReader (Reader) :reader :nextch next-char skip-char)
;; (<- AheadReader (clone Reader))

(<- r ((.init (new AheadReader)) :rd (.init 
; (<- r (clone Reader))


# コンスの記法
コンスセルはCLでは次のように表記されていた。

(cons 1 2)
> (1 . 2)

.をプロパティアクセス演算子にしたいので、新しくハットをコンスの記号としてはどうか。
(cons 1 2)
> (1 ^ 2)

.よりもコンスセルらしい気がしなくもないが、違和感がすごい。

2018-07-27
コンスが中間記法なのが気になる。

(cons a b)と等価な記法を{a b}にしようと考えた。
