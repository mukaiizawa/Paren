覚書

# 概要
Parenを作成するにあたり検討した記録などを示す。

# 総称関数
初期のParenの関数は次の仕様で策定されていた。
- すべての関数は総称関数である
- 総称関数は実行時に第一引数の型から動的にディスパッチされる
- 引数のない総称関数は許さない
この策定の背景には次の背景がある。
- 型ごとのメソッドの乱立を避けたい
  =, string=, char=等
- packageをなくし、型で構造化したい
しかし、この仕様は次の理由で取りやめとなった。
- 引数無しの関数が使えないのため不便
- primitiveに総称関数をサポートすると実装が複雑になる
- 書いていてつまらない
- Parenらしくない

# クラス機構の実装
## クラスの作成
クラスはマクロclassにより作成する。
    (class Class (SuperClass ...)
        field ...)
    <=>
    (progn
        (<- Class #{:type :Class
                    :super '(:SuperClass ...)
                    :fields #{:field :nil ...}})
        ({} $class :Class Class))
作成したクラスはグローバル変数$classに登録される。
クラスの実態は次に示すようなキーと値を持つようなハッシュマップである。
    キー    値
    -------------------------------
    :type   型
    :super  親クラスのリスト
    :fields このクラスのフィールドのリスト
クラスの構成から分かるように、メソッドはクラスに属さない。
Parenのメソッドは次に示すように、呼び出し時に動的にディスパッチされる。
クラスの型を調べるにはtypeマクロを使用する。
    (type Class) <=> ({} Class :type)
    => :Class
## インスタンスの生成
インスタンスの生成にはnewマクロを使用する。
newの実態は、クラスをディープコピーするだけである。
Parenのクラスシステムはクラスベースというよりはプロトタイプベースに近い。
    (new Class) <=> (copy Class)
## メソッドの定義
メソッドの定義はmethodマクロを使用する。
methodは型と変数名のリストを必須パラメーター指定するようなdefだと思えばよい。
このマクロはグローバル変数$methodにメソッド登録するS式に展開される。
    (method .method ((Class c))
       body_forms)
    <=> ({} ({} $method .method) '(:Class) body_form)
$methodはキーにメソッド名称、値にその型ごとの実装のハッシュマップを持つ、
ハッシュマップである。
生成したオブジェクトの初期化は、慣習としてinitメソッドを定義してそこで行う。
    (init (new Point) :x 4 :y 5)
このようなinitは次のように定義されているであろう。
    (method init ((Point p) :key (x 0) (y 0))
        (.x p x)
        (.y p y))
例に示すように、実はインスタンス定義したインスタンス変数は、
自動でアクセサが生成される。
    (class Point () x y)
    (method .x ((Point p) :opt x)
      (if ((nil? x) ({} ({} :fields p) :x))
          (:else ({} ({} :fields p) :x x))))
    (method .y ((Point p) :opt y)
      (if ((nil? y) ({} ({} :fields p) :y))
          (:else ({} ({} :fields p) :y y))))
Parenでは宣言したインスタンス変数はすべて外部に公開する仕様である。
このことは、作成するクラスにドキュメントを書くことと、
使用するクラスのドキュメントを読むことを後押しする。
また、クラスをハックする手段を意図的に残している。
