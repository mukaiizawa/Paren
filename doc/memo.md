覚書

# 概要
Parenを作成するにあたり検討した記録などを示す。

# 総称関数
初期のParenの関数は次の仕様で策定されていた。
- すべての関数は総称関数である
- 総称関数は実行時に第一引数の型から動的にディスパッチされる
- 引数のない総称関数は許さない

この策定の背景には次の背景がある。
- 型ごとのメソッドの乱立を避けたい(=, string=, char=等)
- packageをなくし、型で構造化したい

この仕様は次の理由で取りやめとする。
- 引数無しの関数が使えないのため不便
- primitiveに総称関数をサポートすると実装が複雑になる

# 代入
代入を行う際に、次の二つのケースが考えられる。
1. 代入対象の変数が現在の環境に束縛されている場合
2. 代入対象の変数が現在の環境に束縛されていない場合

clの場合、現在の環境に束縛されていた場合はその値を更新し、そうでなければ、親の環境を再帰的に探索して更新する。

ただし、トップレベルにも束縛されていない場合はトップレベルに束縛する。

Parenでは代入を頻繁に使用するため、現在の環境に変数束縛されていない場合に親の環境に束縛する仕様は不便だと思われる。

例えば次のソースコードはトップレベルにcを束縛してしまう。
    (function copy ()
      (while ((!= (<- c (getc)) :EOF))
        (putc ch)))

2017-11-27
Lisp系の言語はマクロで暗にコンテキストが生成されるため、現在のコンテキストに無条件に束縛するという行為は危険であることが分かった。

例えば、forが新しく環境を作るか否かで動作が異なる。もしforが環境を作る場合は予期した動作にならない。
    (function f ()
        (<- x 0)
        (for (<- i 0) (< i 10) (++ i)
            (write (<- x (* i x)))))

勿論、forが新たにコンテキストを作ることを理解していれば上の環境に伝番する代入オペレーターを使用すれば問題ない。
    (<-- x (* i x))

しかしながら、マクロの実装を常に把握しておくのは難しく、デバッグが困難なバグを生み出してしまう危険がある。

そのため、Parenに実装するオペレーターは次の二つに変更する。

    オペレーター 処理
    ----------------------------------------------------------------
    <-           束縛対象のシンボルが見つかるまで親の環境を探索する。
                 見つからなければ大域環境に束縛する。
    <--          必ず大域環境に束縛する。

# 入出力関数
Parenの入出力関数について検討する。

ちなみにclの主要な関数は次のとおり
- prin1
- print
- princ
- pprint

2017-10-19
次の仕様で実装する。
    関数       処理
    -----------------------------------------
    write_expr Parenオブジェクトとして出力
    write      書き込み
    write_line 書き込み後改行

    read_expr  Parenオブジェクトとして入力
    read_char  一文字読み込み
    read_byte  一バイト書き込み
    read_line  一行読み込み

# 真偽値の扱いについて
2018-06-04
parenの真偽値は次のように策定していた。
    ## 真偽値
    Parenは次にあげる値を除き、すべて真と見做される。
    - false
    - nil
    - 0
    - ""

しかし、次のようにifのelse節が省略されている場合に返り値がnilであると期待しているコードが書けなくなる。
    (<- map (lambda (lis f) (if lis (cons (f (car lis)) (map (cdr lis) f)))))
    (map '(1 2 3) (lambda (x) (+ x x)))
    ; (2 4 6 . false)

これに対して次のようなことを考えた。
- 明示的にifのelse句を書くようにする
- pythonのように、偽の値をそれぞれの型に都合のよいように解釈する(1 + true => 2)
- 偽と見做す値をnilのみにする

2018-06-05
listが最重要データ構造であり、ifの返り値がnilであることになれているため偽と見做す値をnilのみに修正した。

# letのスペシャルフォームに変更
2018-06-07
当初letの実装はlambdaのマクロによる実装を考えていたが、次の理由によりスペシャルフォームに変更した。
- 処理速度向上のため
- 次のような再帰関数束縛のため
    (let ((rec (lambda (x) (if x (rec (cdr x))))))
        ...)
- 展開結果が分かりにくかったため

# データリストの概念の導入
2018-06-21
POSシステム実装にあたり、あれば便利だなということで新しい仕様を考案。

データリストとは、第一要素がキーワードであるような連想配列をいう。
    (:A ....)

特に、第一要素のキーワードをこのデータリストの型という。

データリストは評価されると自身を返す。

# オブジェクト
2018-07-09
データリストの発想を発展させてPOSシステムのオブジェクトを定義する。

POSシステムでは、第一要素がキーワードのリストのことをオブジェクトという。
このとき、第一要素(したがって、キーワード)をオブジェクトの型という。

    <object> ::= (<type> <field_list> ...)
    <field_list> ::= (<field> <field_value>)

オブジェクトの型以外の要素はすべてリストとなっており、それぞれのリストは

例(文字列オブジェクト)

例えば次の文字列リテラルはリードマクロによって次のオブジェクトに展開される。
    "hello world"

    (:String (val (array 104 101 108 108 111 32 119 111 114 108 100))
             (length 3)
             (hash 0x234234))

# プロトタイプベース
2018-07-23

parenのPOSシステムをプロトタイプベースにしてみてはどうかと思い至った。
下に示すように、関数呼び出しの記法が納得いけば問題ないか。

(function . (k o :optional v)
 "
 # vが与えられていない場合
 オブジェクトoからプロパティkに対応する値を取得する。
 # vが与えられた場合
 オブジェクトoのプロパティkに値を設定する。
 ")

; define abstruct class
(class Reader () :rd read-byte)
;; (<- Reader (clone Object))

(.read-byte Reader (lambda () ((.fgetc OS))))


(class AheadReader (Reader) :reader :nextch next-char skip-char)
;; (<- AheadReader (clone Reader))

(<- r ((.init (new AheadReader)) :rd (.init 
; (<- r (clone Reader))

一見問題なさそうに見えるがメソッド呼び出しの記述が冗長になる。

例えばjsなどでは
    a.b();

で済むものが、
    ((.b a))

のようになる。これは、プロパティ参照とメソッド呼び出しのシンタックスがいずれも括弧を必要とするためである。

次のような例では手に負えなくなる。
    a.b().c.d()
    ((.d (.c ((.b a)))))

# リテラル/リーダマクロの見直し
2018-07-30
POSシステムで'.'を総称関数やプロパティのアクセサに使用したいため、コンスセルのシンタックスを修正する。

修正後の記法は次の通り。

コンス
    [x y] ; (cons x y)

リスト
    (x y z)

連想リスト
    ([a 0]
     [b 1]
     [c 2])

2018-08-23
結局、consであるべきだ、という場所すべてに適用したくなってしまうのでやめようかということになった。
    (let ([a 1] [b 2])
      ...)

# よいプログラミング言語とは
よいプログラミング言語にはどのような条件がそなわっているべきか。
- 学習コストが低い
- 素早く記述できる
- 柔軟性

学習コストが低いということは覚えることが少ないということで、プログラムを記述する速度に寄与すると考える。

例えば、数値の加算と文字列の結合が'+'でできると便利。また、mulkのフィーチャーのような機能は必須ではなかろうか。Magnitudeを定義すると比較演算が実装されるのは魅力的である。

柔軟性に関しては、lispのマクロに及ぶものはないと考える。

その点、柔軟過ぎてしまうと、結果としてできることが増えすぎてしまい学習コストが高くなる恐れがあるのでそれに注意したいところ。

# プロトタイプとメソッドベース
parenをプロトタイプベースの言語に仕上げる構想があったが、メソッド呼び出しが冗長な記述になるためCLOSのようなメソッドベースな言語を構築するのがよさそう。

メソッドベースのOOPのイメージ
構造体＋メソッド群

メソッドは呼び出し時に動的に決定される。

例えば'+'というメソッドが呼び出された場合に実行される関数がレシーバによって変わる。

    (+ 1 2 3)
    (+ "123" "456")

必要な機能は大まかに次の通り。
- インスタンス変数を保持する機構
- クラス階層を保持する機構
- メソッドを保持する機構
- メソッドディスパッチ機構

次のような構文にしたい。

クラスはクラス名、スーパークラス及びフィーチャーリスト、インスタンス変数からなる。
    ; 構文の候補
    (struct MemoryStream :extends Object
                         :features '(Reader Writer)
                         :instance-vars '(buf bufsize))
    (struct MemoryStream (Object Reader Writer) buf bufsize)
    (struct MemoryStream (:super Object :features '(Reader Writer)) buf bufsize)

メソッドは定義するクラス/フィーチャー、及び、メソッド名、及び仮引数と処理からなる。
    (generics String ->string () self)
    (generics String + () self)

    (struct Point () x y)

    (generics Point .init (:key (x 0) (y 0))
        (.x self x)
        (.y self y)
        self)

    (generics Point + (q)
        (.init (new Point) :x (+ (.x self) (.x q))
                           :y (+ (.y self) (.y q))))

    (generics String + (o)
              ...)

    (+ "abc" "cde") ; "abcde"
    (<- p (.init (new Point) :x 0 :y 1) q (.init (new Point) :x 1 :y 0))
    (+ p q) ; (Point :x 1 :y 1)

# parenによるparenコンパイラ作成までの流れ
Cによるparenコンパイラでcore.pを解釈できるようになっため、今後はparenによるparenコンパイラを実装することになる。

このとき、parenによるparenコンパイラはCによるparenコンパイラよりも十分に強力なため、同じcore.pを読み込む際に次の問題点が生じる。
- Cによるparenコンパイラはリードマクロが貧弱なため、文字列リーダー等実装が困難。
下は展開イメージ
    "hello" <=> (.init (.new :String) :val (byte-array 104 101 108 108 111 119))

結論
Cによるparenコンパイラで実装が困難なリードマクロは単純に無視すればよいか。

# 例外のクラス階層
現在考えている例外の階層は次の通り。

    Exception
        ShouldNotBeHandledException
            AssertionFailedException
            OutOfMemoryException
            QuitException
        IOException
        ArithmeticException
        PreconditionException
        PostconditionException

すべての例外はExceptionクラスを継承している。

アプリケーションで補足すべきでない例外はShouldNotBeHandledExceptionを継承する。
