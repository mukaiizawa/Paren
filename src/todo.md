# todo
parenにおけるtodoを羅列する。

# 未実装項目
- GC
- importメソッドの実装
- チルダリードマクロ
- 一般化代入
- マクロ

# 検討項目
- プリミティブ`new`
- プリミティブ`struct` => プリミティブにしない?
- 末尾再帰最適化
- goto機構

# バグ対応

# 覚書
## コンセプト
既存の言語がありふれている中、
新しい言語を作るにはそれなりに強い信念が必要である。
parenを作るにあたり、コンセプトを述べる。
- 短く完結に
超軽量スクリプト言語を目指す。
コード数はもちろんのこと、
コーディング時間が他の言語を使うよりも短くすることを目標とする。
- 書くのが楽しい言語にする
Javaは大変優れた言語だと(自分で言語を作ってみてより一層)思うが、
個人的には書いていて楽しいとは思わない。
プログラミング言語はそれを記述する人に喜びを与えなければならない。
- ネストを浅くしやすくする
インデントの方法上括弧がネストしていくと、
行頭の空白文字が多くなっていきがちである。
また、環境を追加していく性質上`let`等はネストがかかりやすい。
そのため、`let`を使う場面はなるべく`def`と`<-`を組み合わせる書き方を推奨する。
一般にlisp系の言語で推奨される書き方
    (let (a 1)
      ...
      (let (b 2 c 3)
         ...))
意図的にネストが低くなるようにする書き方
    (def a b c)
    (<- a 1)
    ...
    (<- b 2 c 3)
    ...
- 利用者に選択を残す
言語の仕様として決めかねるような決断は
基本的に利用時に決定できるように柔軟な設計とする。

## 目指さないこと
parenが目標としない事象について述べる。
- 大規模開発
大きなプロジェクトで使用するような言語にはしない。
- 実行速度にこだわらない
実行速度をとるよりも、コンセプトで述べたようなことを重視する。

## オートインデントについて
オートインデントは(すくなくともvimのlispindentを使なら)あきらめる必要がある。
次のような場合にCライクなインデントが必要になる。
    (if test trueClause
        longLongPredicate
            thenClause
        elseClause)
これは、一行に欠ける場合は次のように書くべきである。
    (if test trueClause
        longLongPredicate thenClause
        elseClause)
これは、構文解析上不要な括弧は省く思想で言語を作成していることによる。
`let`も同じ思想で設計されているため、当該懸案が起こりうる。
    (let (va1 val1
          var2 val2)
      body)
一行で書ける場合はそうするのが望ましい。
    (let (va1 val1 var2 val2)
      body)

## ラムダリストについて
現在のparenは引数が可変長の場合は次のようにしている
    (fn x body)
    (fn (x . y) body)
一方で統一感を重視して
    (fn (. x) body)
とするのもよいのではないか。
キーワードパラメタ―とオプショナルパラメタ―
clではよくラムダリストに`&optional`と`&key`を使用したものだが、
parenにも同様の機能を組み込むべきか。
組み込み時の候補
### オプショナルパラメタ―
    (fn (? x) body) ; xはoptionalパラメター
    (fn (x ? y1 y2 z1 z2) body) ; y1, z1はオプショナルパラメターでその初期値(省略不可)はy2, z2
### キーワードパラメタ―
    (fn (x :key1 val1) body)
    (fn (x :key1 val1 :key2 val2) body)
    (fn (x ? y1 y2 :key1 val1 :key2 val2) body)
### 注意事項
キーワードパラメターとオプショナルパラメタ―は同時に指定可能であるが、
必ずオプショナルパラメターを先に指定することとする。
### 呼び出し例
    (defun f (. a) body)
    ) (f 1 2 3 4) ; => (let (a (1 2 3 4)) body)

    (defun f (a ? b :nil) body)
    ) (f 1) ; => (let (a 1 b :nil) body)
    ) (f 1 2) ; => (let (a 1 b 2) body)

    (defun f (a :b :nil :c :nil) body)
    ) (f 1) ; => (let (a 1 b :nil c :nil) body)
    ) (f 1 :b 2 :c 3) ; => (let (a 1 b 2 c 3) body)
