# todo
parenにおけるtodoを羅列する。

# 未実装項目
- GC
- importメソッドの実装
- チルダリードマクロ
- 一般化代入
- マクロ

# 検討項目
- プリミティブ`new`
- プリミティブ`struct` => プリミティブにしない?
- 末尾再帰最適化
- goto機構

# バグ対応

# 覚書
## コンセプト
既存の言語がありふれている中、
新しい言語を作るにはそれなりに強い信念が必要である。
parenを作るにあたり、コンセプトを述べる。
- 短く完結に
超軽量スクリプト言語を目指す。
コード数はもちろんのこと、
コーディング時間が他の言語を使うよりも短くすることを目標とする。
- 書くのが楽しい言語にする
Javaは大変優れた言語だと(自分で言語を作ってみてより一層)思うが、
個人的には書いていて楽しいとは思わない。
プログラミング言語はそれを記述する人に喜びを与えなければならない。
- ネストを浅くしやすくする
インデントの方法上括弧がネストしていくと、
行頭の空白文字が多くなっていきがちである。
また、環境を追加していく性質上`let`等はネストがかかりやすい。
そのため、`let`を使う場面はなるべく`def`と`<-`を組み合わせる書き方を推奨する。
一般にlisp系の言語で推奨される書き方
    (let (a 1)
      ...
      (let (b 2 c 3)
         ...))
意図的にネストが低くなるようにする書き方
    (def a b c)
    (<- a 1)
    ...
    (<- b 2 c 3)
    ...
- 利用者に選択を残す
言語の仕様として決めかねるような決断は
基本的に利用時に決定できるように柔軟な設計とする。

## 目指さないこと
parenが目標としない事象について述べる。
- 大規模開発
大きなプロジェクトで使用するような言語にはしない。
- 実行速度にこだわらない
実行速度をとるよりも、コンセプトで述べたようなことを重視する。

## オートインデントについて
Parenのソースコードはすべてオートインデントを用いることは不可能である。
たとえば、Parenのifでは次のようなインデントが推奨される。
    (if test trueClause
        longLongPredicate
            thenClause
        elseClause)
一行に記述できる場合は次のように書くべきである。
    (if test trueClause
        predicate thenClause
        elseClause)

Parenには構文があってないようなものなので、
仮に今現在の言語の構文に対応できるオートインデントが存在したとしても、
ユーザがその後に作成したマクロにより新しく構文が作成された場合対応できない。
これは、Lisp系の言語すべてに言えることである。

## ラムダリストについて
現在のparenは引数が可変長の場合は次のようにしている
    (fn x body)
    (fn (x . y) body)
一方で統一感を重視して
    (fn (. x) body)
とするのもよいのではないか。
キーワードパラメタ―とオプショナルパラメタ―
clではよくラムダリストに`&optional`と`&key`を使用したものだが、
parenにも同様の機能を組み込むべきか。
組み込み時の候補
### オプショナルパラメタ―
    (fn (? x) body) ; xはoptionalパラメター
    (fn (x ? y1 y2 z1 z2) body) ; y1, z1はオプショナルパラメターでその初期値(省略不可)はy2, z2
### キーワードパラメタ―
    (fn (x :key1 val1) body)
    (fn (x :key1 val1 :key2 val2) body)
    (fn (x ? y1 y2 :key1 val1 :key2 val2) body)
### 注意事項
キーワードパラメターとオプショナルパラメタ―は同時に指定可能であるが、
必ずオプショナルパラメターを先に指定することとする。
### 呼び出し例
    (defun f (. a) body)
    ) (f 1 2 3 4) ; => (let (a (1 2 3 4)) body)

    (defun f (a ? b :nil) body)
    ) (f 1) ; => (let (a 1 b :nil) body)
    ) (f 1 2) ; => (let (a 1 b 2) body)

    (defun f (a :b :nil :c :nil) body)
    ) (f 1) ; => (let (a 1 b :nil c :nil) body)
    ) (f 1 :b 2 :c 3) ; => (let (a 1 b 2 c 3) body)

## リーダマクロ{}, []
マップと配列を生成するS式に変換するリーダマクロを作成してもいいかもしれない。
    (def map arr)
    (<- map {
          :key1 val1
          :key2 val2
        }
        arr [0 1 2 3])

## 型について
parenにおける型とは何かが整理できていない。
また、ユーザが定義するクラスの仕様(そもそも実装するか)等も未検討。
