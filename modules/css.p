; css module.

(class CSS.SelectorCompiler ()
  reader)

(method CSS.SelectorCompiler .init ()
  (<- self->reader (.new AheadReader))
  self)

(method CSS.SelectorCompiler .parse-selector0 ()
  (let (selectors nil next nil
                  lead-selector? (f (rd) (in? (.next rd) '("#" "." "[")))
                  read-ident (f (rd)
                               (while (.next? rd alnum?)
                                 (.get rd))
                               (.token rd)))
    (if (! (lead-selector? self->reader)) (push! `(:type ,(read-ident self->reader)) selectors))
    (while (lead-selector? self->reader)
      (<- next (.skip self->reader))
      (push!
        (if (= next "#") `(:id ,(read-ident self->reader))
            (= next ".") `(:class ,(read-ident self->reader))
            (= next "[") (let (name (read-ident self->reader) next (.skip self->reader)
                                    read-val (f (rd)
                                               (let (ch (.skip rd))
                                                 (while (!= (.next rd) ch)
                                                   (.get rd))
                                                 (.skip rd ch)
                                                 (.skip self->reader "]")
                                                 (.token rd))))
                           (if (= next "]") `(:attr ,name)
                               (= next "=") `(:attr= ,(list name (read-val self->reader)))
                               (in? next '("~" "|" "^" "$" "*")) (let (ope (keyword (str "attr" next (.skip self->reader "="))))
                                                                   `(,ope ,(list name (read-val self->reader))))
                               (raise Error "unexpected attribute selector"))))
        selectors))
    (apply concat (reverse! selectors))))

(method CSS.SelectorCompiler .parse-selector ()
  (let (selector (list (.parse-selector0 self)) next nil)
    (while (<- next (.next (.skip-space self->reader)))
      (if (= next ",") (break)
          (= next ">") (begin (.skip self->reader) (push! :child-combinator selector))
          (= next "~") (begin (.skip self->reader) (push! :general-sibling-combinator selector))
          (= next "+") (begin (.skip self->reader) (push! :adjacent-sibling-combinator selector))
          (push! :descendant-combinator selector))
      (.skip-space self->reader)
      (push! (.parse-selector0 self) selector))
    (reverse! selector)))

(method CSS.SelectorCompiler .compile ()
  (let (selectors nil)
    (push! (.parse-selector self) selectors)
    (while (= (.next (.skip-space self->reader)) ",")
      (.skip self->reader)
      (.skip-space self->reader)
      (push! (.parse-selector self) selectors))
    (if (nil? (cdr selectors)) (car selectors)
        (cons :selector-list (reverse! selectors)))))

(function css.compile-selector (selector)
  (with-memory-stream ($in selector)
    (.compile (.new CSS.SelectorCompiler))))

(function! main (args)
  (assert (= (css.compile-selector "input")
             '((:type "input"))))
  (assert (= (css.compile-selector "#id")
             '((:id "id"))))
  (assert (= (css.compile-selector ".small")
             '((:class "small"))))
  (assert (= (css.compile-selector "[title]")
             '((:attr "title"))))
  (assert (= (css.compile-selector "[title='foo']")
             '((:attr= ("title" "foo")))))
  (assert (= (css.compile-selector "[title|='foo']")
             '((:attr|= ("title" "foo")))))
  (assert (= (css.compile-selector "input.small")
             '((:type "input" :class "small"))))
  (assert (= (css.compile-selector ".red.blue")
             '((:class "red" :class "blue"))))
  (assert (= (css.compile-selector "img.xxx[src^='https']")
             '((:type "img" :class "xxx" :attr^= ("src" "https")))))
  (assert (= (css.compile-selector "div p")
             '((:type "div") :descendant-combinator (:type "p"))))
  (assert (= (css.compile-selector "ul > li")
             '((:type "ul") :child-combinator (:type "li"))))
  (assert (= (css.compile-selector "img + p")
             '((:type "img") :adjacent-sibling-combinator (:type "p"))))
  (assert (= (css.compile-selector "a.a #id > .cls")
             '((:type "a" :class "a") :descendant-combinator (:id "id") :child-combinator (:class "cls"))))
  (assert (= (css.compile-selector "a.cls, b > c.cls")
             '(:selector-list
                ((:type "a" :class "cls"))
                ((:type "b") :child-combinator (:type "c" :class "cls"))))))
