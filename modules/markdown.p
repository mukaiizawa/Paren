; markdown module.

(import :xml)

(<- $markdown.ol "1. "
    $markdown.ul "- ")

(class MarkdownReader ()
  stream)

(method MarkdownReader .init ()
  (<- self->stream (.new MemoryStream))
  (.write-bytes self->stream (read-bytes))
  self)

(method MarkdownReader .skip (:opt size)
  (dotimes (i (|| size 1))
    (.read-char self->stream))
  self)

(method MarkdownReader .match? (text)
  (let (match? true pos (.tell self->stream))
    (dostring (ch text)
      (when (!= ch (.read-char self->stream))
        (<- match? nil)
        (break)))
    (.seek self->stream pos)
    match?))

(method MarkdownReader .read-line ()
  (with-memory-stream (line)
    (let (ch nil)
      (while (<- ch (.read-char self->stream))
        (if (= ch "\n") (break)
            (.write-bytes line ch))))))

(method MarkdownReader .read-hr ()
  (.read-line self)
  '(hr ()))

(method MarkdownReader .read-header ()
  (let (n 0)
    (while (= (.peek-char self->stream) "#")
      (.read-char self->stream)
      (<- n (++ n)))
    (while (= (.peek-char self->stream) " ")
      (.skip self))
    (if (> n 6) (raise SyntaxError "illegal header")
        `(,(symbol (str 'h n)) () ,(.read-line self)))))

(method MarkdownReader .read-code-block ()
  (let (text (.new MemoryStream))
    (while (.match? self "    ")
      (.skip self 4)
      (.write-line text (.read-line self)))
    `(pre () (code () ,(.to-s text)))))

(method MarkdownReader .read-fenced-code-block ()
  (let (text (.new MemoryStream))
    (.read-line self)
    (while (! (.match? self "```"))
      (.write-line text (.read-line self)))
    (.read-line self)
    `(pre () (code () ,(.to-s text)))))

(method MarkdownReader .read-html ()
  (let ($in self->stream)
    (.read (.new XMLReader))))

(method MarkdownReader .read-list (sym lev)
  (let (li-list nil
                sym->str (f (x) (if (== x 'ol) $markdown.ol $markdown.ul))
                prefix (f (sym lev)
                         (join (concat (repeat " " (* lev 4)) (list (sym->str sym))))))
    (while (.match? self (prefix sym lev))
      (.skip self (len (prefix sym lev)))
      (push!
        (let (p (.read-paragraph self))
          (if (.match? self (prefix 'ul (++ lev))) `(li () ,p ,(.read-list self 'ul (++ lev)))
              (.match? self (prefix 'ol (++ lev))) `(li () ,p ,(.read-list self 'ol (++ lev)))
              (begin
                (car! p 'li)
                p)))
        li-list))
    `(,sym () ,@(reverse! li-list))))

(method MarkdownReader .read-tr (td)
  (let (ch nil td-list nil text (.new MemoryStream))
    (.skip self)
    (while (!= (.peek-char self->stream) "\n")
      (while (!= (<- ch (.peek-char self->stream)) "|")
        (if (nil? ch) (raise SyntaxError "missing table columns")
            (.write-bytes text (.read-char self->stream))))
      (.skip self)
      (push! `(,td () ,(.to-s text)) td-list)
      (.reset text))
    (.skip self)
    `(tr () ,@(reverse! td-list))))

(method MarkdownReader .read-table ()
  (let (th-list (.read-tr self 'th) td-list nil)
    (.read-line self)    ; skip separator.
    (while (= (.peek-char self->stream) "|")
      (push! (.read-tr self 'td) td-list))
    `(table ()
            (thead () ,th-list)
            (tbody () ,@(reverse! td-list)))))

(method MarkdownReader .read-quoted (quote)
  (with-memory-stream (text)
    (let (ch nil skip-quote (f ()
                              (while (= (.peek-char self->stream) quote)
                                (.skip self))))
      (skip-quote)
      (while (!= (<- ch (.peek-char self->stream)) quote)
        (if (nil? ch) (raise SyntaxError (str "missing " quote))
            (.write-bytes text (.read-char self->stream))))
      (skip-quote))))

(method MarkdownReader .read-em ()
  `(em () ,(.read-quoted self "*")))

(method MarkdownReader .read-code ()
  `(code () ,(.read-quoted self "`")))

(method MarkdownReader .read-blockquote ()
  (with-memory-stream (inner-blockquote)
    (while (= (.peek-char self->stream) ">")
      (.skip self)
      (if (= (.peek-char self->stream) " ") (.skip self))
      (.write-line inner-blockquote (.read-line self)))
    (let ($in inner-blockquote)
      (return `(blockquote () ,@(collect (partial .read (.new MarkdownReader))))))))

(method MarkdownReader .read-link0 (text)
  `(a (:id ,(str "fnreferr" text) :href ,(str "#fnrefere" text))
      ,(str "[" text "]")))

(method MarkdownReader .read-link1 (text)
  `(sup (:id ,(str "fnrefere" text))
        (a (:href ,(str "#fnreferr" text)) ,text)))

(method MarkdownReader .read-link2 (text)
  (let (ch nil href (.new MemoryStream))
    (.skip self)
    (while (!= (<- ch (.peek-char self->stream)) ")")
      (if (nil? ch) (raise SyntaxError "invalid link expression")
          (.write-bytes href (.read-char self->stream))))
    (.skip self)
    `(a (:href ,(.to-s href)) ,text)))

(method MarkdownReader .read-link ()
  (let (ch nil text (.new MemoryStream) caret? nil colon? nil)
    (.skip self)
    (when (= (.peek-char self->stream) "^")
      (<- caret? true)
      (.skip self))
    (while (!= (<- ch (.peek-char self->stream)) "]")
      (if (nil? ch) (raise SyntaxError "invalid link expression")
          (.write-bytes text (.read-char self->stream))))
    (.skip self)
    (when (= (.peek-char self->stream) ":")
      (<- colon? true)
      (.skip self))
    (apply (if colon? .read-link0 caret? .read-link1 .read-link2)
           (list self (.to-s text)))))

(method MarkdownReader .read-paragraph ()
  (let (ch nil text (.new MemoryStream) nodes nil
           flush (f ()
                   (when (> (.size text) 0)
                     (push! (.to-s text) nodes)
                     (.reset text))))
    (while (<- ch (.peek-char self->stream))
      (if (= ch "\n") (break)
          (= ch "`") (begin (flush) (push! (.read-code self) nodes))
          (= ch "*") (begin (flush) (push! (.read-em self) nodes))
          (= ch "[") (begin (flush) (push! (.read-link self) nodes))
          (.write-bytes text (.read-char self->stream))))
    (.skip self)
    (flush)
    `(p () ,@(reverse! nodes))))

(method MarkdownReader .read ()
  ; Read markdown.
  ; Returns a list representation of read markdown.
  (let (next (.peek-char self->stream))
    (if (nil? next) nil
        (= next "\n") (.read (.skip self))
        (= next "#") (.read-header self)
        (= next "<") (.read-html self)
        (= next ">") (.read-blockquote self)
        (= next "|") (.read-table self)
        (.match? self "---") (.read-hr self)
        (.match? self "    ") (.read-code-block self)
        (.match? self "```") (.read-fenced-code-block self)
        (.match? self $markdown.ul) (.read-list self 'ul 0)
        (.match? self $markdown.ol) (.read-list self 'ol 0)
        (.read-paragraph self))))

(function! main (args)
  ;; paragraph
  (with-memory-stream ($in "abc\n\n\na*b*c\n\n\nlink to [google](https://google.com)\n")
    (let (rd (.new MarkdownReader))
      (assert (= (.read rd) '(p () "abc")))
      (assert (= (.read rd) '(p () "a" (em () "b") "c")))
      (assert (= (.read rd) '(p () "link to " (a (:href "https://google.com") "google"))))))
  (with-memory-stream ($in "paragraph[^1]\n\n[^1]: reference\n")
    (let (rd (.new MarkdownReader))
      (assert (= (.read rd) '(p () "paragraph" (sup (:id "fnrefere1") (a (:href "#fnreferr1") "1")))))
      (assert (= (.read rd) '(p () (a (:id "fnreferr1" :href "#fnrefere1") "[1]") " reference")))))
  ;; header
  (with-memory-stream ($in "# header1\n\n###### header6\n")
    (let (rd (.new MarkdownReader))
      (assert (= (.read rd) '(h1 () "header1")))
      (assert (= (.read rd) '(h6 () "header6")))))
  ;; code-block
  (with-memory-stream ($in "    foo\n    bar\n----\n```\nfoo\nbar\n```\n")
    (let (rd (.new MarkdownReader))
      (assert (= (.read rd) '(pre () (code () "foo\nbar\n"))))
      (assert (= (.read rd) '(hr ())))
      (assert (= (.read rd) '(pre () (code () "foo\nbar\n"))))))
  ;; table
  (with-memory-stream ($in "|x|y|z|\n||||\n|a|b|c|\n|vv|ww|xx|\n")
    (let (rd (.new MarkdownReader))
      (assert (= (.read rd) '(table ()
                                    (thead ()
                                           (tr () (th () "x") (th () "y") (th () "z")))
                                    (tbody ()
                                           (tr () (td () "a") (td () "b") (td () "c"))
                                           (tr () (td () "vv") (td () "ww") (td () "xx"))))))))
  ;; html
  (with-memory-stream ($in "--- html start\n<span style='color:red'>foo</span>\n--- html end\n")
    (let (rd (.new MarkdownReader))
      (assert (= (.read rd) '(hr ())))
      (assert (= (.read rd) '(span (:style "color:red") "foo")))
      (assert (= (.read rd) '(hr ())))))
  ;; list
  (with-memory-stream ($in "- a\n- b\n- c\n-------\n- a\n    - a1\n    - a2\n- b\n1. c\n")
    (let (rd (.new MarkdownReader))
      (assert (= (.read rd) '(ul () (li () "a") (li () "b") (li () "c"))))
      (assert (= (.read rd) '(hr ())))
      (assert (= (.read rd) '(ul ()
                                 (li ()
                                     (p () "a")
                                     (ul ()
                                         (li () "a1")
                                         (li () "a2")))
                                 (li () "b"))))
      (assert (= (.read rd) '(ol () (li () "c"))))))
  (with-memory-stream ($in (join '("- ul1\n"
                                   "    1. ol1\n"
                                   "    1. ol2\n"
                                   "- ul2\n")))
    (assert (= (.read (.new MarkdownReader))
               '(ul ()
                    (li () (p () "ul1")
                        (ol ()
                            (li () "ol1")
                            (li () "ol2")))
                    (li () "ul2")))))
  ;; blockquote
  (with-memory-stream ($in "> bq1\n\n> bq1\n>> bq2\n> bq3\n")
    (let (rd (.new MarkdownReader))
      (assert (= (.read rd) '(blockquote () (p () "bq1"))))
      (assert (= (.read rd) '(blockquote ()
                                         (p () "bq1")
                                         (blockquote () (p () "bq2"))
                                         (p () "bq3")))))))
